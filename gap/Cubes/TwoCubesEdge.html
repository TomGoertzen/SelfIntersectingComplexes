<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>SimplicialSurface</title>
		<style>
			body { margin: 0; }
		</style>


	</head>
	<body>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>


<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.148.0/build/three.module.js",
			"three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/",
			"gui": "https://unpkg.com/dat.gui@0.7.9/build/dat.gui.module.js"
		}
	}
</script>


<script type="module">
	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { GUI } from 'gui';
	import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
	import { Line2 } from 'three/addons/lines/Line2.js';
	import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
	import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';

	//start scene and camera
	const scene = new THREE.Scene();
	const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 100 );

	const renderer = new THREE.WebGLRenderer({ antialias: true });
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	//Lights
	const skyColor = 0xFFFFFF;
	const skyIntensity = 0.3;
	const skyLight = new THREE.AmbientLight(skyColor, skyIntensity);
	scene.add(skyLight);

	const color = 0xFFFFFF;
	const intensity = 1;
	const light = new THREE.PointLight(color, intensity);
	light.position.set(0, 3, -5);
	scene.add(light);

	//create groups to add everything to
	const meshRoot = new THREE.Group();
	const wireRoot = new THREE.Group();
	const vertexRoot = new THREE.Group();
	const vertexlabelRoot = new THREE.Group();
	const edgeRoot = new THREE.Group();
	const ringRoot = new THREE.Group();
	const normalsRoot = new THREE.Group();
	const normalMeshRoot = new THREE.Group();

	//parameters for the controls on the top right
	var guiParameters = new function() { 
		this.speedX = 0.0; 
		this.speedY = 0.0; 
		this.speedZ = 0.0;
		this.transparency = 1;
		this.edgeVisibility = false;
		this.edgeWidth = 0.2;

		this.vertexVisibility = true;
		this.vertexlabelVisibility = false;
		this.vertexSize = 1;
		this.planeX = 0.0;
		this.minX = -1.5;
		this.maxX = 1.5;
		this.planeXactive = false;
		this.planeY = 0.0;
		this.minY = -1.5;

		this.maxY = 1.5;
		this.planeYactive = false;
		this.planeZ = 0.0;
		this.minZ = -1.5;
		this.maxZ = 1.5;
		this.planeZactive = false;
		this.normalsMaterial = false;
		this.circleVisibility = false;
		this.circleWidth = 0.005;
		this.normalsVisibility = false;
		this.normalsLength = 1;
	} ;

	//generate the plane for intersections
	const planeX = new THREE.Plane( new THREE.Vector3( -1, 0, 0 ), guiParameters.planeX );
	const planeY = new THREE.Plane( new THREE.Vector3( 0, -1, 0 ), guiParameters.planeY );
	const planeZ = new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), guiParameters.planeZ );

	// the array which ones are currently active
	var activePlanes = [];

	//rederer for lables
	const labelRenderer = new CSS2DRenderer();
	labelRenderer.setSize( window.innerWidth, window.innerHeight );
	labelRenderer.domElement.style.position = 'absolute';
	labelRenderer.domElement.style.top = '0px';
	document.body.appendChild( labelRenderer.domElement );
	
	//controls for mouse 
	const controls = new OrbitControls( camera, labelRenderer.domElement );

	//controls in the top right corner
	var gui = new GUI();

	const animationFolder = gui.addFolder("Animations");
	animationFolder.add(guiParameters, 'speedX', 0, 5);
	animationFolder.add(guiParameters, 'speedY', 0, 5);
	animationFolder.add(guiParameters, 'speedZ', 0, 5);
	animationFolder.open();

	const controlFolder = gui.addFolder("Controls");
	controlFolder.add(guiParameters, "transparency", 0, 1);
	controlFolder.add(guiParameters, "edgeVisibility");
	var edgeWidthGUI = controlFolder.add(guiParameters, "edgeWidth", 0.01, 2);
	controlFolder.add(guiParameters, "vertexVisibility");
	controlFolder.add(guiParameters, "vertexlabelVisibility");
	controlFolder.add(guiParameters, "vertexSize", 0.1, 3);
	controlFolder.add(guiParameters, "normalsMaterial");
	controlFolder.add(guiParameters, "circleVisibility");
	controlFolder.add(guiParameters, "circleWidth", 0.0001, 0.1);
	controlFolder.add(guiParameters, "normalsVisibility");
	controlFolder.add(guiParameters, "normalsLength", 0, 2);
	controlFolder.open();

	//generate a sphere geometry for the vertices
	const sphereGeometry = new THREE.SphereGeometry( 0.02, 32, 16 );
	sphereGeometry.transparent = guiParameters.vertexVisibility;
	
	//functions for later calculations

	function calulateIncenter(A, B, C){
		//we follow the math and variable names from here: https://math.stackexchange.com/questions/740111/incenter-of-triangle-in-3d
		var a = Math.sqrt((B[0]-C[0])**2 + (B[1]-C[1])**2 + (B[2]-C[2])**2);
		var b = Math.sqrt((C[0]-A[0])**2 + (C[1]-A[1])**2 + (C[2]-A[2])**2);
		var c = Math.sqrt((A[0]-B[0])**2 + (A[1]-B[1])**2 + (A[2]-B[2])**2);

		var res = [];
		res[0] = a/(a+b+c)*A[0] + b/(a+b+c)*B[0] + c/(a+b+c)*C[0];
		res[1] = a/(a+b+c)*A[1] + b/(a+b+c)*B[1] + c/(a+b+c)*C[1];
		res[2] = a/(a+b+c)*A[2] + b/(a+b+c)*B[2] + c/(a+b+c)*C[2];

		return res;
	}

	function calulateInradius(A, B, C){
		var a = Math.sqrt((B[0]-C[0])**2 + (B[1]-C[1])**2 + (B[2]-C[2])**2);
		var b = Math.sqrt((C[0]-A[0])**2 + (C[1]-A[1])**2 + (C[2]-A[2])**2);
		var c = Math.sqrt((A[0]-B[0])**2 + (A[1]-B[1])**2 + (A[2]-B[2])**2);

		var s = (a+b+c)/2;
		var inradius = Math.sqrt(((s-a)*(s-b)*(s-c)) / s );

		return inradius;
	}

	// --- start of generated output --- //

	// preperations for parameterized vertex coordinates 
	const vertexParametriziation = false;
	// generate the faces color by color 
	const geometry1 = new THREE.BufferGeometry();
	function setVertices1(){
		var vertices1 = new Float32Array( [
				-1.,-1.,1.,
			-1.,-1.,0.,
			-1.,0.,0.,

			-1.,-1.,1.,
			-1.,0.,0.,
			-1.,0.,1.,

			-1.,-1.,1.,
			-1.,-1.,0.,
			0.,-1.,0.,

			-1.,-1.,1.,
			0.,-1.,0.,
			0.,-1.,1.,

			-1.,-1.,0.,
			-1.,0.,0.,
			0.,-1.,0.,

			-1.,0.,0.,
			0.,0.,0.,
			0.,-1.,0.,

			-1.,-1.,1.,
			-1.,0.,1.,
			0.,-1.,1.,

			-1.,0.,1.,
			0.,0.,1.,
			0.,-1.,1.,

			-1.,0.,0.,
			0.,0.,0.,
			0.,0.,0.009803921568627416,

			-1.,0.,1.,
			0.,0.,1.,
			0.,0.,0.9901960784313726,

			-1.,0.,0.,
			0.,0.,0.01960784313725494,
			0.,0.,0.009803921568627416,

			-1.,0.,1.,
			0.,0.,0.9901960784313726,
			0.,0.,0.9803921568627451,

			-1.,0.,0.,
			0.,0.,0.02941176470588236,
			0.,0.,0.01960784313725494,

			-1.,0.,1.,
			0.,0.,0.9803921568627451,
			0.,0.,0.9705882352941176,

			-1.,0.,0.,
			0.,0.,0.03921568627450978,
			0.,0.,0.02941176470588236,

			-1.,0.,1.,
			0.,0.,0.9705882352941176,
			0.,0.,0.9607843137254902,

			-1.,0.,0.,
			0.,0.,0.0490196078431373,
			0.,0.,0.03921568627450978,

			-1.,0.,1.,
			0.,0.,0.9607843137254902,
			0.,0.,0.9509803921568627,

			-1.,0.,0.,
			0.,0.,0.05882352941176472,
			0.,0.,0.0490196078431373,

			-1.,0.,1.,
			0.,0.,0.9509803921568627,
			0.,0.,0.9411764705882353,

			-1.,0.,0.,
			0.,0.,0.06862745098039214,
			0.,0.,0.05882352941176472,

			-1.,0.,1.,
			0.,0.,0.9411764705882353,
			0.,0.,0.9313725490196079,

			-1.,0.,0.,
			0.,0.,0.07843137254901966,
			0.,0.,0.06862745098039214,

			-1.,0.,1.,
			0.,0.,0.9313725490196079,
			0.,0.,0.9215686274509804,

			-1.,0.,0.,
			0.,0.,0.08823529411764708,
			0.,0.,0.07843137254901966,

			-1.,0.,1.,
			0.,0.,0.9215686274509804,
			0.,0.,0.9117647058823529,

			-1.,0.,0.,
			0.,0.,0.09803921568627449,
			0.,0.,0.08823529411764708,

			-1.,0.,1.,
			0.,0.,0.9117647058823529,
			0.,0.,0.9019607843137255,

			-1.,0.,0.,
			0.,0.,0.107843137254902,
			0.,0.,0.09803921568627449,

			-1.,0.,1.,
			0.,0.,0.9019607843137255,
			0.,0.,0.892156862745098,

			-1.,0.,0.,
			0.,0.,0.1176470588235294,
			0.,0.,0.107843137254902,

			-1.,0.,1.,
			0.,0.,0.892156862745098,
			0.,0.,0.8823529411764706,

			-1.,0.,0.,
			0.,0.,0.1274509803921569,
			0.,0.,0.1176470588235294,

			-1.,0.,1.,
			0.,0.,0.8823529411764706,
			0.,0.,0.8725490196078431,

			-1.,0.,0.,
			0.,0.,0.1372549019607843,
			0.,0.,0.1274509803921569,

			-1.,0.,1.,
			0.,0.,0.8725490196078431,
			0.,0.,0.8627450980392157,

			-1.,0.,0.,
			0.,0.,0.1470588235294118,
			0.,0.,0.1372549019607843,

			-1.,0.,1.,
			0.,0.,0.8627450980392157,
			0.,0.,0.8529411764705882,

			-1.,0.,0.,
			0.,0.,0.1568627450980392,
			0.,0.,0.1470588235294118,

			-1.,0.,1.,
			0.,0.,0.8529411764705882,
			0.,0.,0.8431372549019608,

			-1.,0.,0.,
			0.,0.,0.1666666666666666,
			0.,0.,0.1568627450980392,

			-1.,0.,1.,
			0.,0.,0.8431372549019608,
			0.,0.,0.8333333333333334,

			-1.,0.,0.,
			0.,0.,0.1764705882352942,
			0.,0.,0.1666666666666666,

			-1.,0.,1.,
			0.,0.,0.8333333333333334,
			0.,0.,0.8235294117647058,

			-1.,0.,0.,
			0.,0.,0.1862745098039216,
			0.,0.,0.1764705882352942,

			-1.,0.,1.,
			0.,0.,0.8235294117647058,
			0.,0.,0.8137254901960784,

			-1.,0.,0.,
			0.,0.,0.196078431372549,
			0.,0.,0.1862745098039216,

			-1.,0.,1.,
			0.,0.,0.8137254901960784,
			0.,0.,0.803921568627451,

			-1.,0.,0.,
			0.,0.,0.2058823529411765,
			0.,0.,0.196078431372549,

			-1.,0.,1.,
			0.,0.,0.803921568627451,
			0.,0.,0.7941176470588236,

			-1.,0.,0.,
			0.,0.,0.2156862745098039,
			0.,0.,0.2058823529411765,

			-1.,0.,1.,
			0.,0.,0.7941176470588236,
			0.,0.,0.7843137254901961,

			-1.,0.,0.,
			0.,0.,0.2254901960784313,
			0.,0.,0.2156862745098039,

			-1.,0.,1.,
			0.,0.,0.7843137254901961,
			0.,0.,0.7745098039215687,

			-1.,0.,0.,
			0.,0.,0.2352941176470589,
			0.,0.,0.2254901960784313,

			-1.,0.,1.,
			0.,0.,0.7745098039215687,
			0.,0.,0.7647058823529411,

			-1.,0.,0.,
			0.,0.,0.2450980392156863,
			0.,0.,0.2352941176470589,

			-1.,0.,1.,
			0.,0.,0.7647058823529411,
			0.,0.,0.7549019607843137,

			-1.,0.,0.,
			0.,0.,0.2549019607843137,
			0.,0.,0.2450980392156863,

			-1.,0.,1.,
			0.,0.,0.7549019607843137,
			0.,0.,0.7450980392156863,

			-1.,0.,0.,
			0.,0.,0.2647058823529412,
			0.,0.,0.2549019607843137,

			-1.,0.,1.,
			0.,0.,0.7450980392156863,
			0.,0.,0.7352941176470589,

			-1.,0.,0.,
			0.,0.,0.2745098039215687,
			0.,0.,0.2647058823529412,

			-1.,0.,1.,
			0.,0.,0.7352941176470589,
			0.,0.,0.7254901960784313,

			-1.,0.,0.,
			0.,0.,0.2843137254901961,
			0.,0.,0.2745098039215687,

			-1.,0.,1.,
			0.,0.,0.7254901960784313,
			0.,0.,0.7156862745098039,

			-1.,0.,0.,
			0.,0.,0.2941176470588236,
			0.,0.,0.2843137254901961,

			-1.,0.,1.,
			0.,0.,0.7156862745098039,
			0.,0.,0.7058823529411764,

			-1.,0.,0.,
			0.,0.,0.303921568627451,
			0.,0.,0.2941176470588236,

			-1.,0.,1.,
			0.,0.,0.7058823529411764,
			0.,0.,0.696078431372549,

			-1.,0.,0.,
			0.,0.,0.3137254901960784,
			0.,0.,0.303921568627451,

			-1.,0.,1.,
			0.,0.,0.696078431372549,
			0.,0.,0.6862745098039216,

			-1.,0.,0.,
			0.,0.,0.3235294117647058,
			0.,0.,0.3137254901960784,

			-1.,0.,1.,
			0.,0.,0.6862745098039216,
			0.,0.,0.6764705882352942,

			-1.,0.,0.,
			0.,0.,0.3333333333333334,
			0.,0.,0.3235294117647058,

			-1.,0.,1.,
			0.,0.,0.6764705882352942,
			0.,0.,0.6666666666666667,

			-1.,0.,0.,
			0.,0.,0.3431372549019608,
			0.,0.,0.3333333333333334,

			-1.,0.,1.,
			0.,0.,0.6666666666666667,
			0.,0.,0.6568627450980392,

			-1.,0.,0.,
			0.,0.,0.3529411764705882,
			0.,0.,0.3431372549019608,

			-1.,0.,1.,
			0.,0.,0.6568627450980392,
			0.,0.,0.6470588235294118,

			-1.,0.,0.,
			0.,0.,0.3627450980392157,
			0.,0.,0.3529411764705882,

			-1.,0.,1.,
			0.,0.,0.6470588235294118,
			0.,0.,0.6372549019607843,

			-1.,0.,0.,
			0.,0.,0.3725490196078431,
			0.,0.,0.3627450980392157,

			-1.,0.,1.,
			0.,0.,0.6372549019607843,
			0.,0.,0.6274509803921569,

			-1.,0.,0.,
			0.,0.,0.3823529411764706,
			0.,0.,0.3725490196078431,

			-1.,0.,1.,
			0.,0.,0.6274509803921569,
			0.,0.,0.6176470588235294,

			-1.,0.,0.,
			0.,0.,0.3921568627450981,
			0.,0.,0.3823529411764706,

			-1.,0.,1.,
			0.,0.,0.6176470588235294,
			0.,0.,0.607843137254902,

			-1.,0.,0.,
			0.,0.,0.4019607843137255,
			0.,0.,0.3921568627450981,

			-1.,0.,1.,
			0.,0.,0.607843137254902,
			0.,0.,0.5980392156862745,

			-1.,0.,0.,
			0.,0.,0.4117647058823529,
			0.,0.,0.4019607843137255,

			-1.,0.,1.,
			0.,0.,0.5980392156862745,
			0.,0.,0.5882352941176471,

			-1.,0.,0.,
			0.,0.,0.4215686274509804,
			0.,0.,0.4117647058823529,

			-1.,0.,1.,
			0.,0.,0.5882352941176471,
			0.,0.,0.5784313725490196,

			-1.,0.,0.,
			0.,0.,0.4313725490196079,
			0.,0.,0.4215686274509804,

			-1.,0.,1.,
			0.,0.,0.5784313725490196,
			0.,0.,0.5686274509803921,

			-1.,0.,0.,
			0.,0.,0.4411764705882353,
			0.,0.,0.4313725490196079,

			-1.,0.,1.,
			0.,0.,0.5686274509803921,
			0.,0.,0.5588235294117647,

			-1.,0.,0.,
			0.,0.,0.4509803921568627,
			0.,0.,0.4411764705882353,

			-1.,0.,1.,
			0.,0.,0.5588235294117647,
			0.,0.,0.5490196078431373,

			-1.,0.,0.,
			0.,0.,0.4607843137254902,
			0.,0.,0.4509803921568627,

			-1.,0.,1.,
			0.,0.,0.5490196078431373,
			0.,0.,0.5392156862745099,

			-1.,0.,0.,
			0.,0.,0.4705882352941176,
			0.,0.,0.4607843137254902,

			-1.,0.,1.,
			0.,0.,0.5392156862745099,
			0.,0.,0.5294117647058824,

			-1.,0.,0.,
			0.,0.,0.4803921568627451,
			0.,0.,0.4705882352941176,

			-1.,0.,1.,
			0.,0.,0.5294117647058824,
			0.,0.,0.5196078431372548,

			-1.,0.,0.,
			0.,0.,0.4901960784313726,
			0.,0.,0.4803921568627451,

			-1.,0.,1.,
			0.,0.,0.5196078431372548,
			0.,0.,0.5098039215686274,

			-1.,0.,0.,
			0.,0.,0.5,
			0.,0.,0.4901960784313726,

			-1.,0.,1.,
			0.,0.,0.5098039215686274,
			0.,0.,0.5,

			-1.,0.,0.,
			-1.,0.,1.,
			0.,0.,0.5,

			0.,0.,0.,
			0.,-1.,0.,
			0.,0.,0.009803921568627416,

			0.,0.,1.,
			0.,-1.,1.,
			0.,0.,0.9901960784313726,

			0.,-1.,0.,
			0.,0.,0.01960784313725494,
			0.,0.,0.009803921568627416,

			0.,-1.,1.,
			0.,0.,0.9901960784313726,
			0.,0.,0.9803921568627451,

			0.,-1.,0.,
			0.,0.,0.02941176470588236,
			0.,0.,0.01960784313725494,

			0.,-1.,1.,
			0.,0.,0.9803921568627451,
			0.,0.,0.9705882352941176,

			0.,-1.,0.,
			0.,0.,0.03921568627450978,
			0.,0.,0.02941176470588236,

			0.,-1.,1.,
			0.,0.,0.9705882352941176,
			0.,0.,0.9607843137254902,

			0.,-1.,0.,
			0.,0.,0.0490196078431373,
			0.,0.,0.03921568627450978,

			0.,-1.,1.,
			0.,0.,0.9607843137254902,
			0.,0.,0.9509803921568627,

			0.,-1.,0.,
			0.,0.,0.05882352941176472,
			0.,0.,0.0490196078431373,

			0.,-1.,1.,
			0.,0.,0.9509803921568627,
			0.,0.,0.9411764705882353,

			0.,-1.,0.,
			0.,0.,0.06862745098039214,
			0.,0.,0.05882352941176472,

			0.,-1.,1.,
			0.,0.,0.9411764705882353,
			0.,0.,0.9313725490196079,

			0.,-1.,0.,
			0.,0.,0.07843137254901966,
			0.,0.,0.06862745098039214,

			0.,-1.,1.,
			0.,0.,0.9313725490196079,
			0.,0.,0.9215686274509804,

			0.,-1.,0.,
			0.,0.,0.08823529411764708,
			0.,0.,0.07843137254901966,

			0.,-1.,1.,
			0.,0.,0.9215686274509804,
			0.,0.,0.9117647058823529,

			0.,-1.,0.,
			0.,0.,0.09803921568627449,
			0.,0.,0.08823529411764708,

			0.,-1.,1.,
			0.,0.,0.9117647058823529,
			0.,0.,0.9019607843137255,

			0.,-1.,0.,
			0.,0.,0.107843137254902,
			0.,0.,0.09803921568627449,

			0.,-1.,1.,
			0.,0.,0.9019607843137255,
			0.,0.,0.892156862745098,

			0.,-1.,0.,
			0.,0.,0.1176470588235294,
			0.,0.,0.107843137254902,

			0.,-1.,1.,
			0.,0.,0.892156862745098,
			0.,0.,0.8823529411764706,

			0.,-1.,0.,
			0.,0.,0.1274509803921569,
			0.,0.,0.1176470588235294,

			0.,-1.,1.,
			0.,0.,0.8823529411764706,
			0.,0.,0.8725490196078431,

			0.,-1.,0.,
			0.,0.,0.1372549019607843,
			0.,0.,0.1274509803921569,

			0.,-1.,1.,
			0.,0.,0.8725490196078431,
			0.,0.,0.8627450980392157,

			0.,-1.,0.,
			0.,0.,0.1470588235294118,
			0.,0.,0.1372549019607843,

			0.,-1.,1.,
			0.,0.,0.8627450980392157,
			0.,0.,0.8529411764705882,

			0.,-1.,0.,
			0.,0.,0.1568627450980392,
			0.,0.,0.1470588235294118,

			0.,-1.,1.,
			0.,0.,0.8529411764705882,
			0.,0.,0.8431372549019608,

			0.,-1.,0.,
			0.,0.,0.1666666666666666,
			0.,0.,0.1568627450980392,

			0.,-1.,1.,
			0.,0.,0.8431372549019608,
			0.,0.,0.8333333333333334,

			0.,-1.,0.,
			0.,0.,0.1764705882352942,
			0.,0.,0.1666666666666666,

			0.,-1.,1.,
			0.,0.,0.8333333333333334,
			0.,0.,0.8235294117647058,

			0.,-1.,0.,
			0.,0.,0.1862745098039216,
			0.,0.,0.1764705882352942,

			0.,-1.,1.,
			0.,0.,0.8235294117647058,
			0.,0.,0.8137254901960784,

			0.,-1.,0.,
			0.,0.,0.196078431372549,
			0.,0.,0.1862745098039216,

			0.,-1.,1.,
			0.,0.,0.8137254901960784,
			0.,0.,0.803921568627451,

			0.,-1.,0.,
			0.,0.,0.2058823529411765,
			0.,0.,0.196078431372549,

			0.,-1.,1.,
			0.,0.,0.803921568627451,
			0.,0.,0.7941176470588236,

			0.,-1.,0.,
			0.,0.,0.2156862745098039,
			0.,0.,0.2058823529411765,

			0.,-1.,1.,
			0.,0.,0.7941176470588236,
			0.,0.,0.7843137254901961,

			0.,-1.,0.,
			0.,0.,0.2254901960784313,
			0.,0.,0.2156862745098039,

			0.,-1.,1.,
			0.,0.,0.7843137254901961,
			0.,0.,0.7745098039215687,

			0.,-1.,0.,
			0.,0.,0.2352941176470589,
			0.,0.,0.2254901960784313,

			0.,-1.,1.,
			0.,0.,0.7745098039215687,
			0.,0.,0.7647058823529411,

			0.,-1.,0.,
			0.,0.,0.2450980392156863,
			0.,0.,0.2352941176470589,

			0.,-1.,1.,
			0.,0.,0.7647058823529411,
			0.,0.,0.7549019607843137,

			0.,-1.,0.,
			0.,0.,0.2549019607843137,
			0.,0.,0.2450980392156863,

			0.,-1.,1.,
			0.,0.,0.7549019607843137,
			0.,0.,0.7450980392156863,

			0.,-1.,0.,
			0.,0.,0.2647058823529412,
			0.,0.,0.2549019607843137,

			0.,-1.,1.,
			0.,0.,0.7450980392156863,
			0.,0.,0.7352941176470589,

			0.,-1.,0.,
			0.,0.,0.2745098039215687,
			0.,0.,0.2647058823529412,

			0.,-1.,1.,
			0.,0.,0.7352941176470589,
			0.,0.,0.7254901960784313,

			0.,-1.,0.,
			0.,0.,0.2843137254901961,
			0.,0.,0.2745098039215687,

			0.,-1.,1.,
			0.,0.,0.7254901960784313,
			0.,0.,0.7156862745098039,

			0.,-1.,0.,
			0.,0.,0.2941176470588236,
			0.,0.,0.2843137254901961,

			0.,-1.,1.,
			0.,0.,0.7156862745098039,
			0.,0.,0.7058823529411764,

			0.,-1.,0.,
			0.,0.,0.303921568627451,
			0.,0.,0.2941176470588236,

			0.,-1.,1.,
			0.,0.,0.7058823529411764,
			0.,0.,0.696078431372549,

			0.,-1.,0.,
			0.,0.,0.3137254901960784,
			0.,0.,0.303921568627451,

			0.,-1.,1.,
			0.,0.,0.696078431372549,
			0.,0.,0.6862745098039216,

			0.,-1.,0.,
			0.,0.,0.3235294117647058,
			0.,0.,0.3137254901960784,

			0.,-1.,1.,
			0.,0.,0.6862745098039216,
			0.,0.,0.6764705882352942,

			0.,-1.,0.,
			0.,0.,0.3333333333333334,
			0.,0.,0.3235294117647058,

			0.,-1.,1.,
			0.,0.,0.6764705882352942,
			0.,0.,0.6666666666666667,

			0.,-1.,0.,
			0.,0.,0.3431372549019608,
			0.,0.,0.3333333333333334,

			0.,-1.,1.,
			0.,0.,0.6666666666666667,
			0.,0.,0.6568627450980392,

			0.,-1.,0.,
			0.,0.,0.3529411764705882,
			0.,0.,0.3431372549019608,

			0.,-1.,1.,
			0.,0.,0.6568627450980392,
			0.,0.,0.6470588235294118,

			0.,-1.,0.,
			0.,0.,0.3627450980392157,
			0.,0.,0.3529411764705882,

			0.,-1.,1.,
			0.,0.,0.6470588235294118,
			0.,0.,0.6372549019607843,

			0.,-1.,0.,
			0.,0.,0.3725490196078431,
			0.,0.,0.3627450980392157,

			0.,-1.,1.,
			0.,0.,0.6372549019607843,
			0.,0.,0.6274509803921569,

			0.,-1.,0.,
			0.,0.,0.3823529411764706,
			0.,0.,0.3725490196078431,

			0.,-1.,1.,
			0.,0.,0.6274509803921569,
			0.,0.,0.6176470588235294,

			0.,-1.,0.,
			0.,0.,0.3921568627450981,
			0.,0.,0.3823529411764706,

			0.,-1.,1.,
			0.,0.,0.6176470588235294,
			0.,0.,0.607843137254902,

			0.,-1.,0.,
			0.,0.,0.4019607843137255,
			0.,0.,0.3921568627450981,

			0.,-1.,1.,
			0.,0.,0.607843137254902,
			0.,0.,0.5980392156862745,

			0.,-1.,0.,
			0.,0.,0.4117647058823529,
			0.,0.,0.4019607843137255,

			0.,-1.,1.,
			0.,0.,0.5980392156862745,
			0.,0.,0.5882352941176471,

			0.,-1.,0.,
			0.,0.,0.4215686274509804,
			0.,0.,0.4117647058823529,

			0.,-1.,1.,
			0.,0.,0.5882352941176471,
			0.,0.,0.5784313725490196,

			0.,-1.,0.,
			0.,0.,0.4313725490196079,
			0.,0.,0.4215686274509804,

			0.,-1.,1.,
			0.,0.,0.5784313725490196,
			0.,0.,0.5686274509803921,

			0.,-1.,0.,
			0.,0.,0.4411764705882353,
			0.,0.,0.4313725490196079,

			0.,-1.,1.,
			0.,0.,0.5686274509803921,
			0.,0.,0.5588235294117647,

			0.,-1.,0.,
			0.,0.,0.4509803921568627,
			0.,0.,0.4411764705882353,

			0.,-1.,1.,
			0.,0.,0.5588235294117647,
			0.,0.,0.5490196078431373,

			0.,-1.,0.,
			0.,0.,0.4607843137254902,
			0.,0.,0.4509803921568627,

			0.,-1.,1.,
			0.,0.,0.5490196078431373,
			0.,0.,0.5392156862745099,

			0.,-1.,0.,
			0.,0.,0.4705882352941176,
			0.,0.,0.4607843137254902,

			0.,-1.,1.,
			0.,0.,0.5392156862745099,
			0.,0.,0.5294117647058824,

			0.,-1.,0.,
			0.,0.,0.4803921568627451,
			0.,0.,0.4705882352941176,

			0.,-1.,1.,
			0.,0.,0.5294117647058824,
			0.,0.,0.5196078431372548,

			0.,-1.,0.,
			0.,0.,0.4901960784313726,
			0.,0.,0.4803921568627451,

			0.,-1.,1.,
			0.,0.,0.5196078431372548,
			0.,0.,0.5098039215686274,

			0.,-1.,0.,
			0.,0.,0.5,
			0.,0.,0.4901960784313726,

			0.,-1.,1.,
			0.,0.,0.5098039215686274,
			0.,0.,0.5,

			0.,-1.,0.,
			0.,-1.,1.,
			0.,0.,0.5,

			1.,1.,1.,
			1.,1.,0.,
			1.,0.,0.,

			1.,1.,1.,
			1.,0.,0.,
			1.,0.,1.,

			1.,1.,1.,
			1.,1.,0.,
			0.,1.,0.,

			1.,1.,1.,
			0.,1.,0.,
			0.,1.,1.,

			1.,1.,0.,
			1.,0.,0.,
			0.,1.,0.,

			1.,0.,0.,
			0.,0.,0.,
			0.,1.,0.,

			1.,1.,1.,
			1.,0.,1.,
			0.,1.,1.,

			1.,0.,1.,
			0.,0.,1.,
			0.,1.,1.,

			1.,0.,0.,
			0.,0.,0.,
			0.,0.,0.009803921568627416,

			1.,0.,1.,
			0.,0.,1.,
			0.,0.,0.9901960784313726,

			1.,0.,0.,
			0.,0.,0.01960784313725494,
			0.,0.,0.009803921568627416,

			1.,0.,1.,
			0.,0.,0.9901960784313726,
			0.,0.,0.9803921568627451,

			1.,0.,0.,
			0.,0.,0.02941176470588236,
			0.,0.,0.01960784313725494,

			1.,0.,1.,
			0.,0.,0.9803921568627451,
			0.,0.,0.9705882352941176,

			1.,0.,0.,
			0.,0.,0.03921568627450978,
			0.,0.,0.02941176470588236,

			1.,0.,1.,
			0.,0.,0.9705882352941176,
			0.,0.,0.9607843137254902,

			1.,0.,0.,
			0.,0.,0.0490196078431373,
			0.,0.,0.03921568627450978,

			1.,0.,1.,
			0.,0.,0.9607843137254902,
			0.,0.,0.9509803921568627,

			1.,0.,0.,
			0.,0.,0.05882352941176472,
			0.,0.,0.0490196078431373,

			1.,0.,1.,
			0.,0.,0.9509803921568627,
			0.,0.,0.9411764705882353,

			1.,0.,0.,
			0.,0.,0.06862745098039214,
			0.,0.,0.05882352941176472,

			1.,0.,1.,
			0.,0.,0.9411764705882353,
			0.,0.,0.9313725490196079,

			1.,0.,0.,
			0.,0.,0.07843137254901966,
			0.,0.,0.06862745098039214,

			1.,0.,1.,
			0.,0.,0.9313725490196079,
			0.,0.,0.9215686274509804,

			1.,0.,0.,
			0.,0.,0.08823529411764708,
			0.,0.,0.07843137254901966,

			1.,0.,1.,
			0.,0.,0.9215686274509804,
			0.,0.,0.9117647058823529,

			1.,0.,0.,
			0.,0.,0.09803921568627449,
			0.,0.,0.08823529411764708,

			1.,0.,1.,
			0.,0.,0.9117647058823529,
			0.,0.,0.9019607843137255,

			1.,0.,0.,
			0.,0.,0.107843137254902,
			0.,0.,0.09803921568627449,

			1.,0.,1.,
			0.,0.,0.9019607843137255,
			0.,0.,0.892156862745098,

			1.,0.,0.,
			0.,0.,0.1176470588235294,
			0.,0.,0.107843137254902,

			1.,0.,1.,
			0.,0.,0.892156862745098,
			0.,0.,0.8823529411764706,

			1.,0.,0.,
			0.,0.,0.1274509803921569,
			0.,0.,0.1176470588235294,

			1.,0.,1.,
			0.,0.,0.8823529411764706,
			0.,0.,0.8725490196078431,

			1.,0.,0.,
			0.,0.,0.1372549019607843,
			0.,0.,0.1274509803921569,

			1.,0.,1.,
			0.,0.,0.8725490196078431,
			0.,0.,0.8627450980392157,

			1.,0.,0.,
			0.,0.,0.1470588235294118,
			0.,0.,0.1372549019607843,

			1.,0.,1.,
			0.,0.,0.8627450980392157,
			0.,0.,0.8529411764705882,

			1.,0.,0.,
			0.,0.,0.1568627450980392,
			0.,0.,0.1470588235294118,

			1.,0.,1.,
			0.,0.,0.8529411764705882,
			0.,0.,0.8431372549019608,

			1.,0.,0.,
			0.,0.,0.1666666666666666,
			0.,0.,0.1568627450980392,

			1.,0.,1.,
			0.,0.,0.8431372549019608,
			0.,0.,0.8333333333333334,

			1.,0.,0.,
			0.,0.,0.1764705882352942,
			0.,0.,0.1666666666666666,

			1.,0.,1.,
			0.,0.,0.8333333333333334,
			0.,0.,0.8235294117647058,

			1.,0.,0.,
			0.,0.,0.1862745098039216,
			0.,0.,0.1764705882352942,

			1.,0.,1.,
			0.,0.,0.8235294117647058,
			0.,0.,0.8137254901960784,

			1.,0.,0.,
			0.,0.,0.196078431372549,
			0.,0.,0.1862745098039216,

			1.,0.,1.,
			0.,0.,0.8137254901960784,
			0.,0.,0.803921568627451,

			1.,0.,0.,
			0.,0.,0.2058823529411765,
			0.,0.,0.196078431372549,

			1.,0.,1.,
			0.,0.,0.803921568627451,
			0.,0.,0.7941176470588236,

			1.,0.,0.,
			0.,0.,0.2156862745098039,
			0.,0.,0.2058823529411765,

			1.,0.,1.,
			0.,0.,0.7941176470588236,
			0.,0.,0.7843137254901961,

			1.,0.,0.,
			0.,0.,0.2254901960784313,
			0.,0.,0.2156862745098039,

			1.,0.,1.,
			0.,0.,0.7843137254901961,
			0.,0.,0.7745098039215687,

			1.,0.,0.,
			0.,0.,0.2352941176470589,
			0.,0.,0.2254901960784313,

			1.,0.,1.,
			0.,0.,0.7745098039215687,
			0.,0.,0.7647058823529411,

			1.,0.,0.,
			0.,0.,0.2450980392156863,
			0.,0.,0.2352941176470589,

			1.,0.,1.,
			0.,0.,0.7647058823529411,
			0.,0.,0.7549019607843137,

			1.,0.,0.,
			0.,0.,0.2549019607843137,
			0.,0.,0.2450980392156863,

			1.,0.,1.,
			0.,0.,0.7549019607843137,
			0.,0.,0.7450980392156863,

			1.,0.,0.,
			0.,0.,0.2647058823529412,
			0.,0.,0.2549019607843137,

			1.,0.,1.,
			0.,0.,0.7450980392156863,
			0.,0.,0.7352941176470589,

			1.,0.,0.,
			0.,0.,0.2745098039215687,
			0.,0.,0.2647058823529412,

			1.,0.,1.,
			0.,0.,0.7352941176470589,
			0.,0.,0.7254901960784313,

			1.,0.,0.,
			0.,0.,0.2843137254901961,
			0.,0.,0.2745098039215687,

			1.,0.,1.,
			0.,0.,0.7254901960784313,
			0.,0.,0.7156862745098039,

			1.,0.,0.,
			0.,0.,0.2941176470588236,
			0.,0.,0.2843137254901961,

			1.,0.,1.,
			0.,0.,0.7156862745098039,
			0.,0.,0.7058823529411764,

			1.,0.,0.,
			0.,0.,0.303921568627451,
			0.,0.,0.2941176470588236,

			1.,0.,1.,
			0.,0.,0.7058823529411764,
			0.,0.,0.696078431372549,

			1.,0.,0.,
			0.,0.,0.3137254901960784,
			0.,0.,0.303921568627451,

			1.,0.,1.,
			0.,0.,0.696078431372549,
			0.,0.,0.6862745098039216,

			1.,0.,0.,
			0.,0.,0.3235294117647058,
			0.,0.,0.3137254901960784,

			1.,0.,1.,
			0.,0.,0.6862745098039216,
			0.,0.,0.6764705882352942,

			1.,0.,0.,
			0.,0.,0.3333333333333334,
			0.,0.,0.3235294117647058,

			1.,0.,1.,
			0.,0.,0.6764705882352942,
			0.,0.,0.6666666666666667,

			1.,0.,0.,
			0.,0.,0.3431372549019608,
			0.,0.,0.3333333333333334,

			1.,0.,1.,
			0.,0.,0.6666666666666667,
			0.,0.,0.6568627450980392,

			1.,0.,0.,
			0.,0.,0.3529411764705882,
			0.,0.,0.3431372549019608,

			1.,0.,1.,
			0.,0.,0.6568627450980392,
			0.,0.,0.6470588235294118,

			1.,0.,0.,
			0.,0.,0.3627450980392157,
			0.,0.,0.3529411764705882,

			1.,0.,1.,
			0.,0.,0.6470588235294118,
			0.,0.,0.6372549019607843,

			1.,0.,0.,
			0.,0.,0.3725490196078431,
			0.,0.,0.3627450980392157,

			1.,0.,1.,
			0.,0.,0.6372549019607843,
			0.,0.,0.6274509803921569,

			1.,0.,0.,
			0.,0.,0.3823529411764706,
			0.,0.,0.3725490196078431,

			1.,0.,1.,
			0.,0.,0.6274509803921569,
			0.,0.,0.6176470588235294,

			1.,0.,0.,
			0.,0.,0.3921568627450981,
			0.,0.,0.3823529411764706,

			1.,0.,1.,
			0.,0.,0.6176470588235294,
			0.,0.,0.607843137254902,

			1.,0.,0.,
			0.,0.,0.4019607843137255,
			0.,0.,0.3921568627450981,

			1.,0.,1.,
			0.,0.,0.607843137254902,
			0.,0.,0.5980392156862745,

			1.,0.,0.,
			0.,0.,0.4117647058823529,
			0.,0.,0.4019607843137255,

			1.,0.,1.,
			0.,0.,0.5980392156862745,
			0.,0.,0.5882352941176471,

			1.,0.,0.,
			0.,0.,0.4215686274509804,
			0.,0.,0.4117647058823529,

			1.,0.,1.,
			0.,0.,0.5882352941176471,
			0.,0.,0.5784313725490196,

			1.,0.,0.,
			0.,0.,0.4313725490196079,
			0.,0.,0.4215686274509804,

			1.,0.,1.,
			0.,0.,0.5784313725490196,
			0.,0.,0.5686274509803921,

			1.,0.,0.,
			0.,0.,0.4411764705882353,
			0.,0.,0.4313725490196079,

			1.,0.,1.,
			0.,0.,0.5686274509803921,
			0.,0.,0.5588235294117647,

			1.,0.,0.,
			0.,0.,0.4509803921568627,
			0.,0.,0.4411764705882353,

			1.,0.,1.,
			0.,0.,0.5588235294117647,
			0.,0.,0.5490196078431373,

			1.,0.,0.,
			0.,0.,0.4607843137254902,
			0.,0.,0.4509803921568627,

			1.,0.,1.,
			0.,0.,0.5490196078431373,
			0.,0.,0.5392156862745099,

			1.,0.,0.,
			0.,0.,0.4705882352941176,
			0.,0.,0.4607843137254902,

			1.,0.,1.,
			0.,0.,0.5392156862745099,
			0.,0.,0.5294117647058824,

			1.,0.,0.,
			0.,0.,0.4803921568627451,
			0.,0.,0.4705882352941176,

			1.,0.,1.,
			0.,0.,0.5294117647058824,
			0.,0.,0.5196078431372548,

			1.,0.,0.,
			0.,0.,0.4901960784313726,
			0.,0.,0.4803921568627451,

			1.,0.,1.,
			0.,0.,0.5196078431372548,
			0.,0.,0.5098039215686274,

			1.,0.,0.,
			0.,0.,0.5,
			0.,0.,0.4901960784313726,

			1.,0.,1.,
			0.,0.,0.5098039215686274,
			0.,0.,0.5,

			1.,0.,0.,
			1.,0.,1.,
			0.,0.,0.5,

			0.,0.,0.,
			0.,1.,0.,
			0.,0.,0.009803921568627416,

			0.,0.,1.,
			0.,1.,1.,
			0.,0.,0.9901960784313726,

			0.,1.,0.,
			0.,0.,0.01960784313725494,
			0.,0.,0.009803921568627416,

			0.,1.,1.,
			0.,0.,0.9901960784313726,
			0.,0.,0.9803921568627451,

			0.,1.,0.,
			0.,0.,0.02941176470588236,
			0.,0.,0.01960784313725494,

			0.,1.,1.,
			0.,0.,0.9803921568627451,
			0.,0.,0.9705882352941176,

			0.,1.,0.,
			0.,0.,0.03921568627450978,
			0.,0.,0.02941176470588236,

			0.,1.,1.,
			0.,0.,0.9705882352941176,
			0.,0.,0.9607843137254902,

			0.,1.,0.,
			0.,0.,0.0490196078431373,
			0.,0.,0.03921568627450978,

			0.,1.,1.,
			0.,0.,0.9607843137254902,
			0.,0.,0.9509803921568627,

			0.,1.,0.,
			0.,0.,0.05882352941176472,
			0.,0.,0.0490196078431373,

			0.,1.,1.,
			0.,0.,0.9509803921568627,
			0.,0.,0.9411764705882353,

			0.,1.,0.,
			0.,0.,0.06862745098039214,
			0.,0.,0.05882352941176472,

			0.,1.,1.,
			0.,0.,0.9411764705882353,
			0.,0.,0.9313725490196079,

			0.,1.,0.,
			0.,0.,0.07843137254901966,
			0.,0.,0.06862745098039214,

			0.,1.,1.,
			0.,0.,0.9313725490196079,
			0.,0.,0.9215686274509804,

			0.,1.,0.,
			0.,0.,0.08823529411764708,
			0.,0.,0.07843137254901966,

			0.,1.,1.,
			0.,0.,0.9215686274509804,
			0.,0.,0.9117647058823529,

			0.,1.,0.,
			0.,0.,0.09803921568627449,
			0.,0.,0.08823529411764708,

			0.,1.,1.,
			0.,0.,0.9117647058823529,
			0.,0.,0.9019607843137255,

			0.,1.,0.,
			0.,0.,0.107843137254902,
			0.,0.,0.09803921568627449,

			0.,1.,1.,
			0.,0.,0.9019607843137255,
			0.,0.,0.892156862745098,

			0.,1.,0.,
			0.,0.,0.1176470588235294,
			0.,0.,0.107843137254902,

			0.,1.,1.,
			0.,0.,0.892156862745098,
			0.,0.,0.8823529411764706,

			0.,1.,0.,
			0.,0.,0.1274509803921569,
			0.,0.,0.1176470588235294,

			0.,1.,1.,
			0.,0.,0.8823529411764706,
			0.,0.,0.8725490196078431,

			0.,1.,0.,
			0.,0.,0.1372549019607843,
			0.,0.,0.1274509803921569,

			0.,1.,1.,
			0.,0.,0.8725490196078431,
			0.,0.,0.8627450980392157,

			0.,1.,0.,
			0.,0.,0.1470588235294118,
			0.,0.,0.1372549019607843,

			0.,1.,1.,
			0.,0.,0.8627450980392157,
			0.,0.,0.8529411764705882,

			0.,1.,0.,
			0.,0.,0.1568627450980392,
			0.,0.,0.1470588235294118,

			0.,1.,1.,
			0.,0.,0.8529411764705882,
			0.,0.,0.8431372549019608,

			0.,1.,0.,
			0.,0.,0.1666666666666666,
			0.,0.,0.1568627450980392,

			0.,1.,1.,
			0.,0.,0.8431372549019608,
			0.,0.,0.8333333333333334,

			0.,1.,0.,
			0.,0.,0.1764705882352942,
			0.,0.,0.1666666666666666,

			0.,1.,1.,
			0.,0.,0.8333333333333334,
			0.,0.,0.8235294117647058,

			0.,1.,0.,
			0.,0.,0.1862745098039216,
			0.,0.,0.1764705882352942,

			0.,1.,1.,
			0.,0.,0.8235294117647058,
			0.,0.,0.8137254901960784,

			0.,1.,0.,
			0.,0.,0.196078431372549,
			0.,0.,0.1862745098039216,

			0.,1.,1.,
			0.,0.,0.8137254901960784,
			0.,0.,0.803921568627451,

			0.,1.,0.,
			0.,0.,0.2058823529411765,
			0.,0.,0.196078431372549,

			0.,1.,1.,
			0.,0.,0.803921568627451,
			0.,0.,0.7941176470588236,

			0.,1.,0.,
			0.,0.,0.2156862745098039,
			0.,0.,0.2058823529411765,

			0.,1.,1.,
			0.,0.,0.7941176470588236,
			0.,0.,0.7843137254901961,

			0.,1.,0.,
			0.,0.,0.2254901960784313,
			0.,0.,0.2156862745098039,

			0.,1.,1.,
			0.,0.,0.7843137254901961,
			0.,0.,0.7745098039215687,

			0.,1.,0.,
			0.,0.,0.2352941176470589,
			0.,0.,0.2254901960784313,

			0.,1.,1.,
			0.,0.,0.7745098039215687,
			0.,0.,0.7647058823529411,

			0.,1.,0.,
			0.,0.,0.2450980392156863,
			0.,0.,0.2352941176470589,

			0.,1.,1.,
			0.,0.,0.7647058823529411,
			0.,0.,0.7549019607843137,

			0.,1.,0.,
			0.,0.,0.2549019607843137,
			0.,0.,0.2450980392156863,

			0.,1.,1.,
			0.,0.,0.7549019607843137,
			0.,0.,0.7450980392156863,

			0.,1.,0.,
			0.,0.,0.2647058823529412,
			0.,0.,0.2549019607843137,

			0.,1.,1.,
			0.,0.,0.7450980392156863,
			0.,0.,0.7352941176470589,

			0.,1.,0.,
			0.,0.,0.2745098039215687,
			0.,0.,0.2647058823529412,

			0.,1.,1.,
			0.,0.,0.7352941176470589,
			0.,0.,0.7254901960784313,

			0.,1.,0.,
			0.,0.,0.2843137254901961,
			0.,0.,0.2745098039215687,

			0.,1.,1.,
			0.,0.,0.7254901960784313,
			0.,0.,0.7156862745098039,

			0.,1.,0.,
			0.,0.,0.2941176470588236,
			0.,0.,0.2843137254901961,

			0.,1.,1.,
			0.,0.,0.7156862745098039,
			0.,0.,0.7058823529411764,

			0.,1.,0.,
			0.,0.,0.303921568627451,
			0.,0.,0.2941176470588236,

			0.,1.,1.,
			0.,0.,0.7058823529411764,
			0.,0.,0.696078431372549,

			0.,1.,0.,
			0.,0.,0.3137254901960784,
			0.,0.,0.303921568627451,

			0.,1.,1.,
			0.,0.,0.696078431372549,
			0.,0.,0.6862745098039216,

			0.,1.,0.,
			0.,0.,0.3235294117647058,
			0.,0.,0.3137254901960784,

			0.,1.,1.,
			0.,0.,0.6862745098039216,
			0.,0.,0.6764705882352942,

			0.,1.,0.,
			0.,0.,0.3333333333333334,
			0.,0.,0.3235294117647058,

			0.,1.,1.,
			0.,0.,0.6764705882352942,
			0.,0.,0.6666666666666667,

			0.,1.,0.,
			0.,0.,0.3431372549019608,
			0.,0.,0.3333333333333334,

			0.,1.,1.,
			0.,0.,0.6666666666666667,
			0.,0.,0.6568627450980392,

			0.,1.,0.,
			0.,0.,0.3529411764705882,
			0.,0.,0.3431372549019608,

			0.,1.,1.,
			0.,0.,0.6568627450980392,
			0.,0.,0.6470588235294118,

			0.,1.,0.,
			0.,0.,0.3627450980392157,
			0.,0.,0.3529411764705882,

			0.,1.,1.,
			0.,0.,0.6470588235294118,
			0.,0.,0.6372549019607843,

			0.,1.,0.,
			0.,0.,0.3725490196078431,
			0.,0.,0.3627450980392157,

			0.,1.,1.,
			0.,0.,0.6372549019607843,
			0.,0.,0.6274509803921569,

			0.,1.,0.,
			0.,0.,0.3823529411764706,
			0.,0.,0.3725490196078431,

			0.,1.,1.,
			0.,0.,0.6274509803921569,
			0.,0.,0.6176470588235294,

			0.,1.,0.,
			0.,0.,0.3921568627450981,
			0.,0.,0.3823529411764706,

			0.,1.,1.,
			0.,0.,0.6176470588235294,
			0.,0.,0.607843137254902,

			0.,1.,0.,
			0.,0.,0.4019607843137255,
			0.,0.,0.3921568627450981,

			0.,1.,1.,
			0.,0.,0.607843137254902,
			0.,0.,0.5980392156862745,

			0.,1.,0.,
			0.,0.,0.4117647058823529,
			0.,0.,0.4019607843137255,

			0.,1.,1.,
			0.,0.,0.5980392156862745,
			0.,0.,0.5882352941176471,

			0.,1.,0.,
			0.,0.,0.4215686274509804,
			0.,0.,0.4117647058823529,

			0.,1.,1.,
			0.,0.,0.5882352941176471,
			0.,0.,0.5784313725490196,

			0.,1.,0.,
			0.,0.,0.4313725490196079,
			0.,0.,0.4215686274509804,

			0.,1.,1.,
			0.,0.,0.5784313725490196,
			0.,0.,0.5686274509803921,

			0.,1.,0.,
			0.,0.,0.4411764705882353,
			0.,0.,0.4313725490196079,

			0.,1.,1.,
			0.,0.,0.5686274509803921,
			0.,0.,0.5588235294117647,

			0.,1.,0.,
			0.,0.,0.4509803921568627,
			0.,0.,0.4411764705882353,

			0.,1.,1.,
			0.,0.,0.5588235294117647,
			0.,0.,0.5490196078431373,

			0.,1.,0.,
			0.,0.,0.4607843137254902,
			0.,0.,0.4509803921568627,

			0.,1.,1.,
			0.,0.,0.5490196078431373,
			0.,0.,0.5392156862745099,

			0.,1.,0.,
			0.,0.,0.4705882352941176,
			0.,0.,0.4607843137254902,

			0.,1.,1.,
			0.,0.,0.5392156862745099,
			0.,0.,0.5294117647058824,

			0.,1.,0.,
			0.,0.,0.4803921568627451,
			0.,0.,0.4705882352941176,

			0.,1.,1.,
			0.,0.,0.5294117647058824,
			0.,0.,0.5196078431372548,

			0.,1.,0.,
			0.,0.,0.4901960784313726,
			0.,0.,0.4803921568627451,

			0.,1.,1.,
			0.,0.,0.5196078431372548,
			0.,0.,0.5098039215686274,

			0.,1.,0.,
			0.,0.,0.5,
			0.,0.,0.4901960784313726,

			0.,1.,1.,
			0.,0.,0.5098039215686274,
			0.,0.,0.5,

			0.,1.,0.,
			0.,1.,1.,
			0.,0.,0.5,

					] ); 

		return vertices1; 
	}

	geometry1.setAttribute( 'position', new THREE.BufferAttribute( setVertices1(), 3 ) );

	// generate materials in the given color and normals material for the faces 

    const materialNormal1 = new THREE.MeshNormalMaterial({
        flatShading: true,
    });
    materialNormal1.transparent = true;
    materialNormal1.side = THREE.DoubleSide;
        
    const material1 = new THREE.MeshPhongMaterial({
        color: 0x049EF4,
        flatShading: true,
    });
    material1.transparent = true;
    material1.side = THREE.DoubleSide;
        
	// generate meshes for the faces from the materials with the vertex coordinates from before 

    const mesh1 = new THREE.Mesh( geometry1, material1 );
    mesh1.castShadow = true;                         
    mesh1.receiveShadow = true;                      
                                
    meshRoot.add(mesh1);
        
    const meshNormal1 = new THREE.Mesh( geometry1, materialNormal1 );
    mesh1.castShadow = true;                         
    mesh1.receiveShadow = true;                      
                                
    normalMeshRoot.add(meshNormal1);
        
	// generate the edges grouped by color
		controlFolder.remove(edgeWidthGUI);

    const edgeMaterial1 = new THREE.LineBasicMaterial( {
        color: 0x000000,
        lineWidth: 3.,
    } );
        
	function getEdges1(){
		const edges1 = new Float32Array( [
			-1.,-1.,1.,
			-1.,-1.,0.,

			-1.,-1.,1.,
			-1.,0.,0.,

			-1.,-1.,1.,
			-1.,0.,1.,

			-1.,-1.,1.,
			0.,-1.,0.,

			-1.,-1.,1.,
			0.,-1.,1.,

			-1.,-1.,0.,
			-1.,0.,0.,

			-1.,-1.,0.,
			0.,-1.,0.,

			-1.,0.,0.,
			-1.,0.,1.,

			-1.,0.,0.,
			0.,0.,0.,

			-1.,0.,0.,
			0.,-1.,0.,

			-1.,0.,0.,
			0.,0.,0.5,

			-1.,0.,0.,
			0.,0.,0.49019607843137258,

			-1.,0.,0.,
			0.,0.,0.48039215686274506,

			-1.,0.,0.,
			0.,0.,0.47058823529411764,

			-1.,0.,0.,
			0.,0.,0.46078431372549022,

			-1.,0.,0.,
			0.,0.,0.4509803921568627,

			-1.,0.,0.,
			0.,0.,0.44117647058823528,

			-1.,0.,0.,
			0.,0.,0.43137254901960786,

			-1.,0.,0.,
			0.,0.,0.42156862745098045,

			-1.,0.,0.,
			0.,0.,0.41176470588235292,

			-1.,0.,0.,
			0.,0.,0.40196078431372551,

			-1.,0.,0.,
			0.,0.,0.39215686274509809,

			-1.,0.,0.,
			0.,0.,0.38235294117647056,

			-1.,0.,0.,
			0.,0.,0.37254901960784315,

			-1.,0.,0.,
			0.,0.,0.36274509803921573,

			-1.,0.,0.,
			0.,0.,0.3529411764705882,

			-1.,0.,0.,
			0.,0.,0.34313725490196079,

			-1.,0.,0.,
			0.,0.,0.33333333333333337,

			-1.,0.,0.,
			0.,0.,0.32352941176470584,

			-1.,0.,0.,
			0.,0.,0.31372549019607843,

			-1.,0.,0.,
			0.,0.,0.30392156862745101,

			-1.,0.,0.,
			0.,0.,0.29411764705882359,

			-1.,0.,0.,
			0.,0.,0.28431372549019607,

			-1.,0.,0.,
			0.,0.,0.27450980392156865,

			-1.,0.,0.,
			0.,0.,0.26470588235294124,

			-1.,0.,0.,
			0.,0.,0.25490196078431371,

			-1.,0.,0.,
			0.,0.,0.24509803921568629,

			-1.,0.,0.,
			0.,0.,0.23529411764705888,

			-1.,0.,0.,
			0.,0.,0.22549019607843135,

			-1.,0.,0.,
			0.,0.,0.21568627450980393,

			-1.,0.,0.,
			0.,0.,0.20588235294117652,

			-1.,0.,0.,
			0.,0.,0.19607843137254899,

			-1.,0.,0.,
			0.,0.,0.18627450980392157,

			-1.,0.,0.,
			0.,0.,0.17647058823529416,

			-1.,0.,0.,
			0.,0.,0.16666666666666663,

			-1.,0.,0.,
			0.,0.,0.15686274509803921,

			-1.,0.,0.,
			0.,0.,0.1470588235294118,

			-1.,0.,0.,
			0.,0.,0.13725490196078427,

			-1.,0.,0.,
			0.,0.,0.12745098039215685,

			-1.,0.,0.,
			0.,0.,0.11764705882352944,

			-1.,0.,0.,
			0.,0.,0.10784313725490202,

			-1.,0.,0.,
			0.,0.,0.098039215686274495,

			-1.,0.,0.,
			0.,0.,0.088235294117647078,

			-1.,0.,0.,
			0.,0.,0.078431372549019662,

			-1.,0.,0.,
			0.,0.,0.068627450980392135,

			-1.,0.,0.,
			0.,0.,0.058823529411764719,

			-1.,0.,0.,
			0.,0.,0.049019607843137303,

			-1.,0.,0.,
			0.,0.,0.039215686274509776,

			-1.,0.,0.,
			0.,0.,0.029411764705882359,

			-1.,0.,0.,
			0.,0.,0.019607843137254943,

			-1.,0.,0.,
			0.,0.,0.0098039215686274161,

			-1.,0.,1.,
			0.,0.,1.,

			-1.,0.,1.,
			0.,-1.,1.,

			-1.,0.,1.,
			0.,0.,0.99019607843137258,

			-1.,0.,1.,
			0.,0.,0.98039215686274506,

			-1.,0.,1.,
			0.,0.,0.97058823529411764,

			-1.,0.,1.,
			0.,0.,0.96078431372549022,

			-1.,0.,1.,
			0.,0.,0.9509803921568627,

			-1.,0.,1.,
			0.,0.,0.94117647058823528,

			-1.,0.,1.,
			0.,0.,0.93137254901960786,

			-1.,0.,1.,
			0.,0.,0.92156862745098045,

			-1.,0.,1.,
			0.,0.,0.91176470588235292,

			-1.,0.,1.,
			0.,0.,0.90196078431372551,

			-1.,0.,1.,
			0.,0.,0.89215686274509798,

			-1.,0.,1.,
			0.,0.,0.88235294117647056,

			-1.,0.,1.,
			0.,0.,0.87254901960784315,

			-1.,0.,1.,
			0.,0.,0.86274509803921573,

			-1.,0.,1.,
			0.,0.,0.8529411764705882,

			-1.,0.,1.,
			0.,0.,0.84313725490196079,

			-1.,0.,1.,
			0.,0.,0.83333333333333337,

			-1.,0.,1.,
			0.,0.,0.82352941176470584,

			-1.,0.,1.,
			0.,0.,0.81372549019607843,

			-1.,0.,1.,
			0.,0.,0.80392156862745101,

			-1.,0.,1.,
			0.,0.,0.79411764705882359,

			-1.,0.,1.,
			0.,0.,0.78431372549019607,

			-1.,0.,1.,
			0.,0.,0.77450980392156865,

			-1.,0.,1.,
			0.,0.,0.76470588235294112,

			-1.,0.,1.,
			0.,0.,0.75490196078431371,

			-1.,0.,1.,
			0.,0.,0.74509803921568629,

			-1.,0.,1.,
			0.,0.,0.73529411764705888,

			-1.,0.,1.,
			0.,0.,0.72549019607843135,

			-1.,0.,1.,
			0.,0.,0.71568627450980393,

			-1.,0.,1.,
			0.,0.,0.70588235294117641,

			-1.,0.,1.,
			0.,0.,0.69607843137254899,

			-1.,0.,1.,
			0.,0.,0.68627450980392157,

			-1.,0.,1.,
			0.,0.,0.67647058823529416,

			-1.,0.,1.,
			0.,0.,0.66666666666666674,

			-1.,0.,1.,
			0.,0.,0.65686274509803921,

			-1.,0.,1.,
			0.,0.,0.6470588235294118,

			-1.,0.,1.,
			0.,0.,0.63725490196078427,

			-1.,0.,1.,
			0.,0.,0.62745098039215685,

			-1.,0.,1.,
			0.,0.,0.61764705882352944,

			-1.,0.,1.,
			0.,0.,0.60784313725490202,

			-1.,0.,1.,
			0.,0.,0.59803921568627449,

			-1.,0.,1.,
			0.,0.,0.58823529411764708,

			-1.,0.,1.,
			0.,0.,0.57843137254901955,

			-1.,0.,1.,
			0.,0.,0.56862745098039214,

			-1.,0.,1.,
			0.,0.,0.55882352941176472,

			-1.,0.,1.,
			0.,0.,0.5490196078431373,

			-1.,0.,1.,
			0.,0.,0.53921568627450989,

			-1.,0.,1.,
			0.,0.,0.52941176470588236,

			-1.,0.,1.,
			0.,0.,0.51960784313725483,

			-1.,0.,1.,
			0.,0.,0.50980392156862742,

			-1.,0.,1.,
			0.,0.,0.5,

			0.,0.,1.,
			0.,-1.,1.,

			0.,0.,1.,
			0.,0.,0.99019607843137258,

			0.,0.,0.,
			0.,-1.,0.,

			0.,0.,0.,
			0.,0.,0.0098039215686274161,

			0.,-1.,0.,
			0.,-1.,1.,

			0.,-1.,0.,
			0.,0.,0.5,

			0.,-1.,0.,
			0.,0.,0.49019607843137258,

			0.,-1.,0.,
			0.,0.,0.48039215686274506,

			0.,-1.,0.,
			0.,0.,0.47058823529411764,

			0.,-1.,0.,
			0.,0.,0.46078431372549022,

			0.,-1.,0.,
			0.,0.,0.4509803921568627,

			0.,-1.,0.,
			0.,0.,0.44117647058823528,

			0.,-1.,0.,
			0.,0.,0.43137254901960786,

			0.,-1.,0.,
			0.,0.,0.42156862745098045,

			0.,-1.,0.,
			0.,0.,0.41176470588235292,

			0.,-1.,0.,
			0.,0.,0.40196078431372551,

			0.,-1.,0.,
			0.,0.,0.39215686274509809,

			0.,-1.,0.,
			0.,0.,0.38235294117647056,

			0.,-1.,0.,
			0.,0.,0.37254901960784315,

			0.,-1.,0.,
			0.,0.,0.36274509803921573,

			0.,-1.,0.,
			0.,0.,0.3529411764705882,

			0.,-1.,0.,
			0.,0.,0.34313725490196079,

			0.,-1.,0.,
			0.,0.,0.33333333333333337,

			0.,-1.,0.,
			0.,0.,0.32352941176470584,

			0.,-1.,0.,
			0.,0.,0.31372549019607843,

			0.,-1.,0.,
			0.,0.,0.30392156862745101,

			0.,-1.,0.,
			0.,0.,0.29411764705882359,

			0.,-1.,0.,
			0.,0.,0.28431372549019607,

			0.,-1.,0.,
			0.,0.,0.27450980392156865,

			0.,-1.,0.,
			0.,0.,0.26470588235294124,

			0.,-1.,0.,
			0.,0.,0.25490196078431371,

			0.,-1.,0.,
			0.,0.,0.24509803921568629,

			0.,-1.,0.,
			0.,0.,0.23529411764705888,

			0.,-1.,0.,
			0.,0.,0.22549019607843135,

			0.,-1.,0.,
			0.,0.,0.21568627450980393,

			0.,-1.,0.,
			0.,0.,0.20588235294117652,

			0.,-1.,0.,
			0.,0.,0.19607843137254899,

			0.,-1.,0.,
			0.,0.,0.18627450980392157,

			0.,-1.,0.,
			0.,0.,0.17647058823529416,

			0.,-1.,0.,
			0.,0.,0.16666666666666663,

			0.,-1.,0.,
			0.,0.,0.15686274509803921,

			0.,-1.,0.,
			0.,0.,0.1470588235294118,

			0.,-1.,0.,
			0.,0.,0.13725490196078427,

			0.,-1.,0.,
			0.,0.,0.12745098039215685,

			0.,-1.,0.,
			0.,0.,0.11764705882352944,

			0.,-1.,0.,
			0.,0.,0.10784313725490202,

			0.,-1.,0.,
			0.,0.,0.098039215686274495,

			0.,-1.,0.,
			0.,0.,0.088235294117647078,

			0.,-1.,0.,
			0.,0.,0.078431372549019662,

			0.,-1.,0.,
			0.,0.,0.068627450980392135,

			0.,-1.,0.,
			0.,0.,0.058823529411764719,

			0.,-1.,0.,
			0.,0.,0.049019607843137303,

			0.,-1.,0.,
			0.,0.,0.039215686274509776,

			0.,-1.,0.,
			0.,0.,0.029411764705882359,

			0.,-1.,0.,
			0.,0.,0.019607843137254943,

			0.,-1.,0.,
			0.,0.,0.0098039215686274161,

			0.,-1.,1.,
			0.,0.,0.99019607843137258,

			0.,-1.,1.,
			0.,0.,0.98039215686274506,

			0.,-1.,1.,
			0.,0.,0.97058823529411764,

			0.,-1.,1.,
			0.,0.,0.96078431372549022,

			0.,-1.,1.,
			0.,0.,0.9509803921568627,

			0.,-1.,1.,
			0.,0.,0.94117647058823528,

			0.,-1.,1.,
			0.,0.,0.93137254901960786,

			0.,-1.,1.,
			0.,0.,0.92156862745098045,

			0.,-1.,1.,
			0.,0.,0.91176470588235292,

			0.,-1.,1.,
			0.,0.,0.90196078431372551,

			0.,-1.,1.,
			0.,0.,0.89215686274509798,

			0.,-1.,1.,
			0.,0.,0.88235294117647056,

			0.,-1.,1.,
			0.,0.,0.87254901960784315,

			0.,-1.,1.,
			0.,0.,0.86274509803921573,

			0.,-1.,1.,
			0.,0.,0.8529411764705882,

			0.,-1.,1.,
			0.,0.,0.84313725490196079,

			0.,-1.,1.,
			0.,0.,0.83333333333333337,

			0.,-1.,1.,
			0.,0.,0.82352941176470584,

			0.,-1.,1.,
			0.,0.,0.81372549019607843,

			0.,-1.,1.,
			0.,0.,0.80392156862745101,

			0.,-1.,1.,
			0.,0.,0.79411764705882359,

			0.,-1.,1.,
			0.,0.,0.78431372549019607,

			0.,-1.,1.,
			0.,0.,0.77450980392156865,

			0.,-1.,1.,
			0.,0.,0.76470588235294112,

			0.,-1.,1.,
			0.,0.,0.75490196078431371,

			0.,-1.,1.,
			0.,0.,0.74509803921568629,

			0.,-1.,1.,
			0.,0.,0.73529411764705888,

			0.,-1.,1.,
			0.,0.,0.72549019607843135,

			0.,-1.,1.,
			0.,0.,0.71568627450980393,

			0.,-1.,1.,
			0.,0.,0.70588235294117641,

			0.,-1.,1.,
			0.,0.,0.69607843137254899,

			0.,-1.,1.,
			0.,0.,0.68627450980392157,

			0.,-1.,1.,
			0.,0.,0.67647058823529416,

			0.,-1.,1.,
			0.,0.,0.66666666666666674,

			0.,-1.,1.,
			0.,0.,0.65686274509803921,

			0.,-1.,1.,
			0.,0.,0.6470588235294118,

			0.,-1.,1.,
			0.,0.,0.63725490196078427,

			0.,-1.,1.,
			0.,0.,0.62745098039215685,

			0.,-1.,1.,
			0.,0.,0.61764705882352944,

			0.,-1.,1.,
			0.,0.,0.60784313725490202,

			0.,-1.,1.,
			0.,0.,0.59803921568627449,

			0.,-1.,1.,
			0.,0.,0.58823529411764708,

			0.,-1.,1.,
			0.,0.,0.57843137254901955,

			0.,-1.,1.,
			0.,0.,0.56862745098039214,

			0.,-1.,1.,
			0.,0.,0.55882352941176472,

			0.,-1.,1.,
			0.,0.,0.5490196078431373,

			0.,-1.,1.,
			0.,0.,0.53921568627450989,

			0.,-1.,1.,
			0.,0.,0.52941176470588236,

			0.,-1.,1.,
			0.,0.,0.51960784313725483,

			0.,-1.,1.,
			0.,0.,0.50980392156862742,

			0.,-1.,1.,
			0.,0.,0.5,

			0.,0.,0.99019607843137258,
			0.,0.,0.98039215686274506,

			0.,0.,0.98039215686274506,
			0.,0.,0.97058823529411764,

			0.,0.,0.97058823529411764,
			0.,0.,0.96078431372549022,

			0.,0.,0.96078431372549022,
			0.,0.,0.9509803921568627,

			0.,0.,0.9509803921568627,
			0.,0.,0.94117647058823528,

			0.,0.,0.94117647058823528,
			0.,0.,0.93137254901960786,

			0.,0.,0.93137254901960786,
			0.,0.,0.92156862745098045,

			0.,0.,0.92156862745098045,
			0.,0.,0.91176470588235292,

			0.,0.,0.91176470588235292,
			0.,0.,0.90196078431372551,

			0.,0.,0.90196078431372551,
			0.,0.,0.89215686274509798,

			0.,0.,0.89215686274509798,
			0.,0.,0.88235294117647056,

			0.,0.,0.88235294117647056,
			0.,0.,0.87254901960784315,

			0.,0.,0.87254901960784315,
			0.,0.,0.86274509803921573,

			0.,0.,0.86274509803921573,
			0.,0.,0.8529411764705882,

			0.,0.,0.8529411764705882,
			0.,0.,0.84313725490196079,

			0.,0.,0.84313725490196079,
			0.,0.,0.83333333333333337,

			0.,0.,0.83333333333333337,
			0.,0.,0.82352941176470584,

			0.,0.,0.82352941176470584,
			0.,0.,0.81372549019607843,

			0.,0.,0.81372549019607843,
			0.,0.,0.80392156862745101,

			0.,0.,0.80392156862745101,
			0.,0.,0.79411764705882359,

			0.,0.,0.79411764705882359,
			0.,0.,0.78431372549019607,

			0.,0.,0.78431372549019607,
			0.,0.,0.77450980392156865,

			0.,0.,0.77450980392156865,
			0.,0.,0.76470588235294112,

			0.,0.,0.76470588235294112,
			0.,0.,0.75490196078431371,

			0.,0.,0.75490196078431371,
			0.,0.,0.74509803921568629,

			0.,0.,0.74509803921568629,
			0.,0.,0.73529411764705888,

			0.,0.,0.73529411764705888,
			0.,0.,0.72549019607843135,

			0.,0.,0.72549019607843135,
			0.,0.,0.71568627450980393,

			0.,0.,0.71568627450980393,
			0.,0.,0.70588235294117641,

			0.,0.,0.70588235294117641,
			0.,0.,0.69607843137254899,

			0.,0.,0.69607843137254899,
			0.,0.,0.68627450980392157,

			0.,0.,0.68627450980392157,
			0.,0.,0.67647058823529416,

			0.,0.,0.67647058823529416,
			0.,0.,0.66666666666666674,

			0.,0.,0.66666666666666674,
			0.,0.,0.65686274509803921,

			0.,0.,0.65686274509803921,
			0.,0.,0.6470588235294118,

			0.,0.,0.6470588235294118,
			0.,0.,0.63725490196078427,

			0.,0.,0.63725490196078427,
			0.,0.,0.62745098039215685,

			0.,0.,0.62745098039215685,
			0.,0.,0.61764705882352944,

			0.,0.,0.61764705882352944,
			0.,0.,0.60784313725490202,

			0.,0.,0.60784313725490202,
			0.,0.,0.59803921568627449,

			0.,0.,0.59803921568627449,
			0.,0.,0.58823529411764708,

			0.,0.,0.58823529411764708,
			0.,0.,0.57843137254901955,

			0.,0.,0.57843137254901955,
			0.,0.,0.56862745098039214,

			0.,0.,0.56862745098039214,
			0.,0.,0.55882352941176472,

			0.,0.,0.55882352941176472,
			0.,0.,0.5490196078431373,

			0.,0.,0.5490196078431373,
			0.,0.,0.53921568627450989,

			0.,0.,0.53921568627450989,
			0.,0.,0.52941176470588236,

			0.,0.,0.52941176470588236,
			0.,0.,0.51960784313725483,

			0.,0.,0.51960784313725483,
			0.,0.,0.50980392156862742,

			0.,0.,0.50980392156862742,
			0.,0.,0.5,

			0.,0.,0.5,
			0.,0.,0.49019607843137258,

			0.,0.,0.49019607843137258,
			0.,0.,0.48039215686274506,

			0.,0.,0.48039215686274506,
			0.,0.,0.47058823529411764,

			0.,0.,0.47058823529411764,
			0.,0.,0.46078431372549022,

			0.,0.,0.46078431372549022,
			0.,0.,0.4509803921568627,

			0.,0.,0.4509803921568627,
			0.,0.,0.44117647058823528,

			0.,0.,0.44117647058823528,
			0.,0.,0.43137254901960786,

			0.,0.,0.43137254901960786,
			0.,0.,0.42156862745098045,

			0.,0.,0.42156862745098045,
			0.,0.,0.41176470588235292,

			0.,0.,0.41176470588235292,
			0.,0.,0.40196078431372551,

			0.,0.,0.40196078431372551,
			0.,0.,0.39215686274509809,

			0.,0.,0.39215686274509809,
			0.,0.,0.38235294117647056,

			0.,0.,0.38235294117647056,
			0.,0.,0.37254901960784315,

			0.,0.,0.37254901960784315,
			0.,0.,0.36274509803921573,

			0.,0.,0.36274509803921573,
			0.,0.,0.3529411764705882,

			0.,0.,0.3529411764705882,
			0.,0.,0.34313725490196079,

			0.,0.,0.34313725490196079,
			0.,0.,0.33333333333333337,

			0.,0.,0.33333333333333337,
			0.,0.,0.32352941176470584,

			0.,0.,0.32352941176470584,
			0.,0.,0.31372549019607843,

			0.,0.,0.31372549019607843,
			0.,0.,0.30392156862745101,

			0.,0.,0.30392156862745101,
			0.,0.,0.29411764705882359,

			0.,0.,0.29411764705882359,
			0.,0.,0.28431372549019607,

			0.,0.,0.28431372549019607,
			0.,0.,0.27450980392156865,

			0.,0.,0.27450980392156865,
			0.,0.,0.26470588235294124,

			0.,0.,0.26470588235294124,
			0.,0.,0.25490196078431371,

			0.,0.,0.25490196078431371,
			0.,0.,0.24509803921568629,

			0.,0.,0.24509803921568629,
			0.,0.,0.23529411764705888,

			0.,0.,0.23529411764705888,
			0.,0.,0.22549019607843135,

			0.,0.,0.22549019607843135,
			0.,0.,0.21568627450980393,

			0.,0.,0.21568627450980393,
			0.,0.,0.20588235294117652,

			0.,0.,0.20588235294117652,
			0.,0.,0.19607843137254899,

			0.,0.,0.19607843137254899,
			0.,0.,0.18627450980392157,

			0.,0.,0.18627450980392157,
			0.,0.,0.17647058823529416,

			0.,0.,0.17647058823529416,
			0.,0.,0.16666666666666663,

			0.,0.,0.16666666666666663,
			0.,0.,0.15686274509803921,

			0.,0.,0.15686274509803921,
			0.,0.,0.1470588235294118,

			0.,0.,0.1470588235294118,
			0.,0.,0.13725490196078427,

			0.,0.,0.13725490196078427,
			0.,0.,0.12745098039215685,

			0.,0.,0.12745098039215685,
			0.,0.,0.11764705882352944,

			0.,0.,0.11764705882352944,
			0.,0.,0.10784313725490202,

			0.,0.,0.10784313725490202,
			0.,0.,0.098039215686274495,

			0.,0.,0.098039215686274495,
			0.,0.,0.088235294117647078,

			0.,0.,0.088235294117647078,
			0.,0.,0.078431372549019662,

			0.,0.,0.078431372549019662,
			0.,0.,0.068627450980392135,

			0.,0.,0.068627450980392135,
			0.,0.,0.058823529411764719,

			0.,0.,0.058823529411764719,
			0.,0.,0.049019607843137303,

			0.,0.,0.049019607843137303,
			0.,0.,0.039215686274509776,

			0.,0.,0.039215686274509776,
			0.,0.,0.029411764705882359,

			0.,0.,0.029411764705882359,
			0.,0.,0.019607843137254943,

			0.,0.,0.019607843137254943,
			0.,0.,0.0098039215686274161,

			1.,1.,1.,
			1.,1.,0.,

			1.,1.,1.,
			1.,0.,0.,

			1.,1.,1.,
			1.,0.,1.,

			1.,1.,1.,
			0.,1.,0.,

			1.,1.,1.,
			0.,1.,1.,

			1.,1.,0.,
			1.,0.,0.,

			1.,1.,0.,
			0.,1.,0.,

			1.,0.,0.,
			1.,0.,1.,

			1.,0.,0.,
			0.,0.,0.,

			1.,0.,0.,
			0.,1.,0.,

			1.,0.,0.,
			0.,0.,0.5,

			1.,0.,0.,
			0.,0.,0.49019607843137258,

			1.,0.,0.,
			0.,0.,0.48039215686274506,

			1.,0.,0.,
			0.,0.,0.47058823529411764,

			1.,0.,0.,
			0.,0.,0.46078431372549022,

			1.,0.,0.,
			0.,0.,0.4509803921568627,

			1.,0.,0.,
			0.,0.,0.44117647058823528,

			1.,0.,0.,
			0.,0.,0.43137254901960786,

			1.,0.,0.,
			0.,0.,0.42156862745098045,

			1.,0.,0.,
			0.,0.,0.41176470588235292,

			1.,0.,0.,
			0.,0.,0.40196078431372551,

			1.,0.,0.,
			0.,0.,0.39215686274509809,

			1.,0.,0.,
			0.,0.,0.38235294117647056,

			1.,0.,0.,
			0.,0.,0.37254901960784315,

			1.,0.,0.,
			0.,0.,0.36274509803921573,

			1.,0.,0.,
			0.,0.,0.3529411764705882,

			1.,0.,0.,
			0.,0.,0.34313725490196079,

			1.,0.,0.,
			0.,0.,0.33333333333333337,

			1.,0.,0.,
			0.,0.,0.32352941176470584,

			1.,0.,0.,
			0.,0.,0.31372549019607843,

			1.,0.,0.,
			0.,0.,0.30392156862745101,

			1.,0.,0.,
			0.,0.,0.29411764705882359,

			1.,0.,0.,
			0.,0.,0.28431372549019607,

			1.,0.,0.,
			0.,0.,0.27450980392156865,

			1.,0.,0.,
			0.,0.,0.26470588235294124,

			1.,0.,0.,
			0.,0.,0.25490196078431371,

			1.,0.,0.,
			0.,0.,0.24509803921568629,

			1.,0.,0.,
			0.,0.,0.23529411764705888,

			1.,0.,0.,
			0.,0.,0.22549019607843135,

			1.,0.,0.,
			0.,0.,0.21568627450980393,

			1.,0.,0.,
			0.,0.,0.20588235294117652,

			1.,0.,0.,
			0.,0.,0.19607843137254899,

			1.,0.,0.,
			0.,0.,0.18627450980392157,

			1.,0.,0.,
			0.,0.,0.17647058823529416,

			1.,0.,0.,
			0.,0.,0.16666666666666663,

			1.,0.,0.,
			0.,0.,0.15686274509803921,

			1.,0.,0.,
			0.,0.,0.1470588235294118,

			1.,0.,0.,
			0.,0.,0.13725490196078427,

			1.,0.,0.,
			0.,0.,0.12745098039215685,

			1.,0.,0.,
			0.,0.,0.11764705882352944,

			1.,0.,0.,
			0.,0.,0.10784313725490202,

			1.,0.,0.,
			0.,0.,0.098039215686274495,

			1.,0.,0.,
			0.,0.,0.088235294117647078,

			1.,0.,0.,
			0.,0.,0.078431372549019662,

			1.,0.,0.,
			0.,0.,0.068627450980392135,

			1.,0.,0.,
			0.,0.,0.058823529411764719,

			1.,0.,0.,
			0.,0.,0.049019607843137303,

			1.,0.,0.,
			0.,0.,0.039215686274509776,

			1.,0.,0.,
			0.,0.,0.029411764705882359,

			1.,0.,0.,
			0.,0.,0.019607843137254943,

			1.,0.,0.,
			0.,0.,0.0098039215686274161,

			1.,0.,1.,
			0.,0.,1.,

			1.,0.,1.,
			0.,1.,1.,

			1.,0.,1.,
			0.,0.,0.99019607843137258,

			1.,0.,1.,
			0.,0.,0.98039215686274506,

			1.,0.,1.,
			0.,0.,0.97058823529411764,

			1.,0.,1.,
			0.,0.,0.96078431372549022,

			1.,0.,1.,
			0.,0.,0.9509803921568627,

			1.,0.,1.,
			0.,0.,0.94117647058823528,

			1.,0.,1.,
			0.,0.,0.93137254901960786,

			1.,0.,1.,
			0.,0.,0.92156862745098045,

			1.,0.,1.,
			0.,0.,0.91176470588235292,

			1.,0.,1.,
			0.,0.,0.90196078431372551,

			1.,0.,1.,
			0.,0.,0.89215686274509798,

			1.,0.,1.,
			0.,0.,0.88235294117647056,

			1.,0.,1.,
			0.,0.,0.87254901960784315,

			1.,0.,1.,
			0.,0.,0.86274509803921573,

			1.,0.,1.,
			0.,0.,0.8529411764705882,

			1.,0.,1.,
			0.,0.,0.84313725490196079,

			1.,0.,1.,
			0.,0.,0.83333333333333337,

			1.,0.,1.,
			0.,0.,0.82352941176470584,

			1.,0.,1.,
			0.,0.,0.81372549019607843,

			1.,0.,1.,
			0.,0.,0.80392156862745101,

			1.,0.,1.,
			0.,0.,0.79411764705882359,

			1.,0.,1.,
			0.,0.,0.78431372549019607,

			1.,0.,1.,
			0.,0.,0.77450980392156865,

			1.,0.,1.,
			0.,0.,0.76470588235294112,

			1.,0.,1.,
			0.,0.,0.75490196078431371,

			1.,0.,1.,
			0.,0.,0.74509803921568629,

			1.,0.,1.,
			0.,0.,0.73529411764705888,

			1.,0.,1.,
			0.,0.,0.72549019607843135,

			1.,0.,1.,
			0.,0.,0.71568627450980393,

			1.,0.,1.,
			0.,0.,0.70588235294117641,

			1.,0.,1.,
			0.,0.,0.69607843137254899,

			1.,0.,1.,
			0.,0.,0.68627450980392157,

			1.,0.,1.,
			0.,0.,0.67647058823529416,

			1.,0.,1.,
			0.,0.,0.66666666666666674,

			1.,0.,1.,
			0.,0.,0.65686274509803921,

			1.,0.,1.,
			0.,0.,0.6470588235294118,

			1.,0.,1.,
			0.,0.,0.63725490196078427,

			1.,0.,1.,
			0.,0.,0.62745098039215685,

			1.,0.,1.,
			0.,0.,0.61764705882352944,

			1.,0.,1.,
			0.,0.,0.60784313725490202,

			1.,0.,1.,
			0.,0.,0.59803921568627449,

			1.,0.,1.,
			0.,0.,0.58823529411764708,

			1.,0.,1.,
			0.,0.,0.57843137254901955,

			1.,0.,1.,
			0.,0.,0.56862745098039214,

			1.,0.,1.,
			0.,0.,0.55882352941176472,

			1.,0.,1.,
			0.,0.,0.5490196078431373,

			1.,0.,1.,
			0.,0.,0.53921568627450989,

			1.,0.,1.,
			0.,0.,0.52941176470588236,

			1.,0.,1.,
			0.,0.,0.51960784313725483,

			1.,0.,1.,
			0.,0.,0.50980392156862742,

			1.,0.,1.,
			0.,0.,0.5,

			0.,0.,1.,
			0.,1.,1.,

			0.,0.,1.,
			0.,0.,0.99019607843137258,

			0.,0.,0.,
			0.,1.,0.,

			0.,0.,0.,
			0.,0.,0.0098039215686274161,

			0.,1.,0.,
			0.,1.,1.,

			0.,1.,0.,
			0.,0.,0.5,

			0.,1.,0.,
			0.,0.,0.49019607843137258,

			0.,1.,0.,
			0.,0.,0.48039215686274506,

			0.,1.,0.,
			0.,0.,0.47058823529411764,

			0.,1.,0.,
			0.,0.,0.46078431372549022,

			0.,1.,0.,
			0.,0.,0.4509803921568627,

			0.,1.,0.,
			0.,0.,0.44117647058823528,

			0.,1.,0.,
			0.,0.,0.43137254901960786,

			0.,1.,0.,
			0.,0.,0.42156862745098045,

			0.,1.,0.,
			0.,0.,0.41176470588235292,

			0.,1.,0.,
			0.,0.,0.40196078431372551,

			0.,1.,0.,
			0.,0.,0.39215686274509809,

			0.,1.,0.,
			0.,0.,0.38235294117647056,

			0.,1.,0.,
			0.,0.,0.37254901960784315,

			0.,1.,0.,
			0.,0.,0.36274509803921573,

			0.,1.,0.,
			0.,0.,0.3529411764705882,

			0.,1.,0.,
			0.,0.,0.34313725490196079,

			0.,1.,0.,
			0.,0.,0.33333333333333337,

			0.,1.,0.,
			0.,0.,0.32352941176470584,

			0.,1.,0.,
			0.,0.,0.31372549019607843,

			0.,1.,0.,
			0.,0.,0.30392156862745101,

			0.,1.,0.,
			0.,0.,0.29411764705882359,

			0.,1.,0.,
			0.,0.,0.28431372549019607,

			0.,1.,0.,
			0.,0.,0.27450980392156865,

			0.,1.,0.,
			0.,0.,0.26470588235294124,

			0.,1.,0.,
			0.,0.,0.25490196078431371,

			0.,1.,0.,
			0.,0.,0.24509803921568629,

			0.,1.,0.,
			0.,0.,0.23529411764705888,

			0.,1.,0.,
			0.,0.,0.22549019607843135,

			0.,1.,0.,
			0.,0.,0.21568627450980393,

			0.,1.,0.,
			0.,0.,0.20588235294117652,

			0.,1.,0.,
			0.,0.,0.19607843137254899,

			0.,1.,0.,
			0.,0.,0.18627450980392157,

			0.,1.,0.,
			0.,0.,0.17647058823529416,

			0.,1.,0.,
			0.,0.,0.16666666666666663,

			0.,1.,0.,
			0.,0.,0.15686274509803921,

			0.,1.,0.,
			0.,0.,0.1470588235294118,

			0.,1.,0.,
			0.,0.,0.13725490196078427,

			0.,1.,0.,
			0.,0.,0.12745098039215685,

			0.,1.,0.,
			0.,0.,0.11764705882352944,

			0.,1.,0.,
			0.,0.,0.10784313725490202,

			0.,1.,0.,
			0.,0.,0.098039215686274495,

			0.,1.,0.,
			0.,0.,0.088235294117647078,

			0.,1.,0.,
			0.,0.,0.078431372549019662,

			0.,1.,0.,
			0.,0.,0.068627450980392135,

			0.,1.,0.,
			0.,0.,0.058823529411764719,

			0.,1.,0.,
			0.,0.,0.049019607843137303,

			0.,1.,0.,
			0.,0.,0.039215686274509776,

			0.,1.,0.,
			0.,0.,0.029411764705882359,

			0.,1.,0.,
			0.,0.,0.019607843137254943,

			0.,1.,0.,
			0.,0.,0.0098039215686274161,

			0.,1.,1.,
			0.,0.,0.99019607843137258,

			0.,1.,1.,
			0.,0.,0.98039215686274506,

			0.,1.,1.,
			0.,0.,0.97058823529411764,

			0.,1.,1.,
			0.,0.,0.96078431372549022,

			0.,1.,1.,
			0.,0.,0.9509803921568627,

			0.,1.,1.,
			0.,0.,0.94117647058823528,

			0.,1.,1.,
			0.,0.,0.93137254901960786,

			0.,1.,1.,
			0.,0.,0.92156862745098045,

			0.,1.,1.,
			0.,0.,0.91176470588235292,

			0.,1.,1.,
			0.,0.,0.90196078431372551,

			0.,1.,1.,
			0.,0.,0.89215686274509798,

			0.,1.,1.,
			0.,0.,0.88235294117647056,

			0.,1.,1.,
			0.,0.,0.87254901960784315,

			0.,1.,1.,
			0.,0.,0.86274509803921573,

			0.,1.,1.,
			0.,0.,0.8529411764705882,

			0.,1.,1.,
			0.,0.,0.84313725490196079,

			0.,1.,1.,
			0.,0.,0.83333333333333337,

			0.,1.,1.,
			0.,0.,0.82352941176470584,

			0.,1.,1.,
			0.,0.,0.81372549019607843,

			0.,1.,1.,
			0.,0.,0.80392156862745101,

			0.,1.,1.,
			0.,0.,0.79411764705882359,

			0.,1.,1.,
			0.,0.,0.78431372549019607,

			0.,1.,1.,
			0.,0.,0.77450980392156865,

			0.,1.,1.,
			0.,0.,0.76470588235294112,

			0.,1.,1.,
			0.,0.,0.75490196078431371,

			0.,1.,1.,
			0.,0.,0.74509803921568629,

			0.,1.,1.,
			0.,0.,0.73529411764705888,

			0.,1.,1.,
			0.,0.,0.72549019607843135,

			0.,1.,1.,
			0.,0.,0.71568627450980393,

			0.,1.,1.,
			0.,0.,0.70588235294117641,

			0.,1.,1.,
			0.,0.,0.69607843137254899,

			0.,1.,1.,
			0.,0.,0.68627450980392157,

			0.,1.,1.,
			0.,0.,0.67647058823529416,

			0.,1.,1.,
			0.,0.,0.66666666666666674,

			0.,1.,1.,
			0.,0.,0.65686274509803921,

			0.,1.,1.,
			0.,0.,0.6470588235294118,

			0.,1.,1.,
			0.,0.,0.63725490196078427,

			0.,1.,1.,
			0.,0.,0.62745098039215685,

			0.,1.,1.,
			0.,0.,0.61764705882352944,

			0.,1.,1.,
			0.,0.,0.60784313725490202,

			0.,1.,1.,
			0.,0.,0.59803921568627449,

			0.,1.,1.,
			0.,0.,0.58823529411764708,

			0.,1.,1.,
			0.,0.,0.57843137254901955,

			0.,1.,1.,
			0.,0.,0.56862745098039214,

			0.,1.,1.,
			0.,0.,0.55882352941176472,

			0.,1.,1.,
			0.,0.,0.5490196078431373,

			0.,1.,1.,
			0.,0.,0.53921568627450989,

			0.,1.,1.,
			0.,0.,0.52941176470588236,

			0.,1.,1.,
			0.,0.,0.51960784313725483,

			0.,1.,1.,
			0.,0.,0.50980392156862742,

			0.,1.,1.,
			0.,0.,0.5,

			0.,0.,0.99019607843137258,
			0.,0.,0.98039215686274506,

			0.,0.,0.98039215686274506,
			0.,0.,0.97058823529411764,

			0.,0.,0.97058823529411764,
			0.,0.,0.96078431372549022,

			0.,0.,0.96078431372549022,
			0.,0.,0.9509803921568627,

			0.,0.,0.9509803921568627,
			0.,0.,0.94117647058823528,

			0.,0.,0.94117647058823528,
			0.,0.,0.93137254901960786,

			0.,0.,0.93137254901960786,
			0.,0.,0.92156862745098045,

			0.,0.,0.92156862745098045,
			0.,0.,0.91176470588235292,

			0.,0.,0.91176470588235292,
			0.,0.,0.90196078431372551,

			0.,0.,0.90196078431372551,
			0.,0.,0.89215686274509798,

			0.,0.,0.89215686274509798,
			0.,0.,0.88235294117647056,

			0.,0.,0.88235294117647056,
			0.,0.,0.87254901960784315,

			0.,0.,0.87254901960784315,
			0.,0.,0.86274509803921573,

			0.,0.,0.86274509803921573,
			0.,0.,0.8529411764705882,

			0.,0.,0.8529411764705882,
			0.,0.,0.84313725490196079,

			0.,0.,0.84313725490196079,
			0.,0.,0.83333333333333337,

			0.,0.,0.83333333333333337,
			0.,0.,0.82352941176470584,

			0.,0.,0.82352941176470584,
			0.,0.,0.81372549019607843,

			0.,0.,0.81372549019607843,
			0.,0.,0.80392156862745101,

			0.,0.,0.80392156862745101,
			0.,0.,0.79411764705882359,

			0.,0.,0.79411764705882359,
			0.,0.,0.78431372549019607,

			0.,0.,0.78431372549019607,
			0.,0.,0.77450980392156865,

			0.,0.,0.77450980392156865,
			0.,0.,0.76470588235294112,

			0.,0.,0.76470588235294112,
			0.,0.,0.75490196078431371,

			0.,0.,0.75490196078431371,
			0.,0.,0.74509803921568629,

			0.,0.,0.74509803921568629,
			0.,0.,0.73529411764705888,

			0.,0.,0.73529411764705888,
			0.,0.,0.72549019607843135,

			0.,0.,0.72549019607843135,
			0.,0.,0.71568627450980393,

			0.,0.,0.71568627450980393,
			0.,0.,0.70588235294117641,

			0.,0.,0.70588235294117641,
			0.,0.,0.69607843137254899,

			0.,0.,0.69607843137254899,
			0.,0.,0.68627450980392157,

			0.,0.,0.68627450980392157,
			0.,0.,0.67647058823529416,

			0.,0.,0.67647058823529416,
			0.,0.,0.66666666666666674,

			0.,0.,0.66666666666666674,
			0.,0.,0.65686274509803921,

			0.,0.,0.65686274509803921,
			0.,0.,0.6470588235294118,

			0.,0.,0.6470588235294118,
			0.,0.,0.63725490196078427,

			0.,0.,0.63725490196078427,
			0.,0.,0.62745098039215685,

			0.,0.,0.62745098039215685,
			0.,0.,0.61764705882352944,

			0.,0.,0.61764705882352944,
			0.,0.,0.60784313725490202,

			0.,0.,0.60784313725490202,
			0.,0.,0.59803921568627449,

			0.,0.,0.59803921568627449,
			0.,0.,0.58823529411764708,

			0.,0.,0.58823529411764708,
			0.,0.,0.57843137254901955,

			0.,0.,0.57843137254901955,
			0.,0.,0.56862745098039214,

			0.,0.,0.56862745098039214,
			0.,0.,0.55882352941176472,

			0.,0.,0.55882352941176472,
			0.,0.,0.5490196078431373,

			0.,0.,0.5490196078431373,
			0.,0.,0.53921568627450989,

			0.,0.,0.53921568627450989,
			0.,0.,0.52941176470588236,

			0.,0.,0.52941176470588236,
			0.,0.,0.51960784313725483,

			0.,0.,0.51960784313725483,
			0.,0.,0.50980392156862742,

			0.,0.,0.50980392156862742,
			0.,0.,0.5,

			0.,0.,0.5,
			0.,0.,0.49019607843137258,

			0.,0.,0.49019607843137258,
			0.,0.,0.48039215686274506,

			0.,0.,0.48039215686274506,
			0.,0.,0.47058823529411764,

			0.,0.,0.47058823529411764,
			0.,0.,0.46078431372549022,

			0.,0.,0.46078431372549022,
			0.,0.,0.4509803921568627,

			0.,0.,0.4509803921568627,
			0.,0.,0.44117647058823528,

			0.,0.,0.44117647058823528,
			0.,0.,0.43137254901960786,

			0.,0.,0.43137254901960786,
			0.,0.,0.42156862745098045,

			0.,0.,0.42156862745098045,
			0.,0.,0.41176470588235292,

			0.,0.,0.41176470588235292,
			0.,0.,0.40196078431372551,

			0.,0.,0.40196078431372551,
			0.,0.,0.39215686274509809,

			0.,0.,0.39215686274509809,
			0.,0.,0.38235294117647056,

			0.,0.,0.38235294117647056,
			0.,0.,0.37254901960784315,

			0.,0.,0.37254901960784315,
			0.,0.,0.36274509803921573,

			0.,0.,0.36274509803921573,
			0.,0.,0.3529411764705882,

			0.,0.,0.3529411764705882,
			0.,0.,0.34313725490196079,

			0.,0.,0.34313725490196079,
			0.,0.,0.33333333333333337,

			0.,0.,0.33333333333333337,
			0.,0.,0.32352941176470584,

			0.,0.,0.32352941176470584,
			0.,0.,0.31372549019607843,

			0.,0.,0.31372549019607843,
			0.,0.,0.30392156862745101,

			0.,0.,0.30392156862745101,
			0.,0.,0.29411764705882359,

			0.,0.,0.29411764705882359,
			0.,0.,0.28431372549019607,

			0.,0.,0.28431372549019607,
			0.,0.,0.27450980392156865,

			0.,0.,0.27450980392156865,
			0.,0.,0.26470588235294124,

			0.,0.,0.26470588235294124,
			0.,0.,0.25490196078431371,

			0.,0.,0.25490196078431371,
			0.,0.,0.24509803921568629,

			0.,0.,0.24509803921568629,
			0.,0.,0.23529411764705888,

			0.,0.,0.23529411764705888,
			0.,0.,0.22549019607843135,

			0.,0.,0.22549019607843135,
			0.,0.,0.21568627450980393,

			0.,0.,0.21568627450980393,
			0.,0.,0.20588235294117652,

			0.,0.,0.20588235294117652,
			0.,0.,0.19607843137254899,

			0.,0.,0.19607843137254899,
			0.,0.,0.18627450980392157,

			0.,0.,0.18627450980392157,
			0.,0.,0.17647058823529416,

			0.,0.,0.17647058823529416,
			0.,0.,0.16666666666666663,

			0.,0.,0.16666666666666663,
			0.,0.,0.15686274509803921,

			0.,0.,0.15686274509803921,
			0.,0.,0.1470588235294118,

			0.,0.,0.1470588235294118,
			0.,0.,0.13725490196078427,

			0.,0.,0.13725490196078427,
			0.,0.,0.12745098039215685,

			0.,0.,0.12745098039215685,
			0.,0.,0.11764705882352944,

			0.,0.,0.11764705882352944,
			0.,0.,0.10784313725490202,

			0.,0.,0.10784313725490202,
			0.,0.,0.098039215686274495,

			0.,0.,0.098039215686274495,
			0.,0.,0.088235294117647078,

			0.,0.,0.088235294117647078,
			0.,0.,0.078431372549019662,

			0.,0.,0.078431372549019662,
			0.,0.,0.068627450980392135,

			0.,0.,0.068627450980392135,
			0.,0.,0.058823529411764719,

			0.,0.,0.058823529411764719,
			0.,0.,0.049019607843137303,

			0.,0.,0.049019607843137303,
			0.,0.,0.039215686274509776,

			0.,0.,0.039215686274509776,
			0.,0.,0.029411764705882359,

			0.,0.,0.029411764705882359,
			0.,0.,0.019607843137254943,

			0.,0.,0.019607843137254943,
			0.,0.,0.0098039215686274161,

		]);
		return edges1;
	}


	// generate geometries and lines for the edges 

    const edgeGeometry1 = new THREE.BufferGeometry();
    edgeGeometry1.setAttribute( 'position', new THREE.BufferAttribute( getEdges1(), 3 ) );

    const edgeLine1 = new THREE.LineSegments( edgeGeometry1, edgeMaterial1 );
    edgeRoot.add(edgeLine1);
        
	// update function to be called every frame 


	function getVertex1(){
		return [-1.,-1.,1.,];
	}


	function getVertex2(){
		return [-1.,-1.,0.,];
	}


	function getVertex3(){
		return [-1.,0.,0.,];
	}


	function getVertex4(){
		return [-1.,0.,1.,];
	}


	function getVertex5(){
		return [0.,0.,1.,];
	}


	function getVertex6(){
		return [0.,0.,0.,];
	}


	function getVertex7(){
		return [0.,-1.,0.,];
	}


	function getVertex8(){
		return [0.,-1.,1.,];
	}


	function getVertex9(){
		return [0.,0.,0.99019607843137258,];
	}


	function getVertex10(){
		return [0.,0.,0.98039215686274506,];
	}


	function getVertex11(){
		return [0.,0.,0.97058823529411764,];
	}


	function getVertex12(){
		return [0.,0.,0.96078431372549022,];
	}


	function getVertex13(){
		return [0.,0.,0.9509803921568627,];
	}


	function getVertex14(){
		return [0.,0.,0.94117647058823528,];
	}


	function getVertex15(){
		return [0.,0.,0.93137254901960786,];
	}


	function getVertex16(){
		return [0.,0.,0.92156862745098045,];
	}


	function getVertex17(){
		return [0.,0.,0.91176470588235292,];
	}


	function getVertex18(){
		return [0.,0.,0.90196078431372551,];
	}


	function getVertex19(){
		return [0.,0.,0.89215686274509798,];
	}


	function getVertex20(){
		return [0.,0.,0.88235294117647056,];
	}


	function getVertex21(){
		return [0.,0.,0.87254901960784315,];
	}


	function getVertex22(){
		return [0.,0.,0.86274509803921573,];
	}


	function getVertex23(){
		return [0.,0.,0.8529411764705882,];
	}


	function getVertex24(){
		return [0.,0.,0.84313725490196079,];
	}


	function getVertex25(){
		return [0.,0.,0.83333333333333337,];
	}


	function getVertex26(){
		return [0.,0.,0.82352941176470584,];
	}


	function getVertex27(){
		return [0.,0.,0.81372549019607843,];
	}


	function getVertex28(){
		return [0.,0.,0.80392156862745101,];
	}


	function getVertex29(){
		return [0.,0.,0.79411764705882359,];
	}


	function getVertex30(){
		return [0.,0.,0.78431372549019607,];
	}


	function getVertex31(){
		return [0.,0.,0.77450980392156865,];
	}


	function getVertex32(){
		return [0.,0.,0.76470588235294112,];
	}


	function getVertex33(){
		return [0.,0.,0.75490196078431371,];
	}


	function getVertex34(){
		return [0.,0.,0.74509803921568629,];
	}


	function getVertex35(){
		return [0.,0.,0.73529411764705888,];
	}


	function getVertex36(){
		return [0.,0.,0.72549019607843135,];
	}


	function getVertex37(){
		return [0.,0.,0.71568627450980393,];
	}


	function getVertex38(){
		return [0.,0.,0.70588235294117641,];
	}


	function getVertex39(){
		return [0.,0.,0.69607843137254899,];
	}


	function getVertex40(){
		return [0.,0.,0.68627450980392157,];
	}


	function getVertex41(){
		return [0.,0.,0.67647058823529416,];
	}


	function getVertex42(){
		return [0.,0.,0.66666666666666674,];
	}


	function getVertex43(){
		return [0.,0.,0.65686274509803921,];
	}


	function getVertex44(){
		return [0.,0.,0.6470588235294118,];
	}


	function getVertex45(){
		return [0.,0.,0.63725490196078427,];
	}


	function getVertex46(){
		return [0.,0.,0.62745098039215685,];
	}


	function getVertex47(){
		return [0.,0.,0.61764705882352944,];
	}


	function getVertex48(){
		return [0.,0.,0.60784313725490202,];
	}


	function getVertex49(){
		return [0.,0.,0.59803921568627449,];
	}


	function getVertex50(){
		return [0.,0.,0.58823529411764708,];
	}


	function getVertex51(){
		return [0.,0.,0.57843137254901955,];
	}


	function getVertex52(){
		return [0.,0.,0.56862745098039214,];
	}


	function getVertex53(){
		return [0.,0.,0.55882352941176472,];
	}


	function getVertex54(){
		return [0.,0.,0.5490196078431373,];
	}


	function getVertex55(){
		return [0.,0.,0.53921568627450989,];
	}


	function getVertex56(){
		return [0.,0.,0.52941176470588236,];
	}


	function getVertex57(){
		return [0.,0.,0.51960784313725483,];
	}


	function getVertex58(){
		return [0.,0.,0.50980392156862742,];
	}


	function getVertex59(){
		return [0.,0.,0.5,];
	}


	function getVertex60(){
		return [0.,0.,0.49019607843137258,];
	}


	function getVertex61(){
		return [0.,0.,0.48039215686274506,];
	}


	function getVertex62(){
		return [0.,0.,0.47058823529411764,];
	}


	function getVertex63(){
		return [0.,0.,0.46078431372549022,];
	}


	function getVertex64(){
		return [0.,0.,0.4509803921568627,];
	}


	function getVertex65(){
		return [0.,0.,0.44117647058823528,];
	}


	function getVertex66(){
		return [0.,0.,0.43137254901960786,];
	}


	function getVertex67(){
		return [0.,0.,0.42156862745098045,];
	}


	function getVertex68(){
		return [0.,0.,0.41176470588235292,];
	}


	function getVertex69(){
		return [0.,0.,0.40196078431372551,];
	}


	function getVertex70(){
		return [0.,0.,0.39215686274509809,];
	}


	function getVertex71(){
		return [0.,0.,0.38235294117647056,];
	}


	function getVertex72(){
		return [0.,0.,0.37254901960784315,];
	}


	function getVertex73(){
		return [0.,0.,0.36274509803921573,];
	}


	function getVertex74(){
		return [0.,0.,0.3529411764705882,];
	}


	function getVertex75(){
		return [0.,0.,0.34313725490196079,];
	}


	function getVertex76(){
		return [0.,0.,0.33333333333333337,];
	}


	function getVertex77(){
		return [0.,0.,0.32352941176470584,];
	}


	function getVertex78(){
		return [0.,0.,0.31372549019607843,];
	}


	function getVertex79(){
		return [0.,0.,0.30392156862745101,];
	}


	function getVertex80(){
		return [0.,0.,0.29411764705882359,];
	}


	function getVertex81(){
		return [0.,0.,0.28431372549019607,];
	}


	function getVertex82(){
		return [0.,0.,0.27450980392156865,];
	}


	function getVertex83(){
		return [0.,0.,0.26470588235294124,];
	}


	function getVertex84(){
		return [0.,0.,0.25490196078431371,];
	}


	function getVertex85(){
		return [0.,0.,0.24509803921568629,];
	}


	function getVertex86(){
		return [0.,0.,0.23529411764705888,];
	}


	function getVertex87(){
		return [0.,0.,0.22549019607843135,];
	}


	function getVertex88(){
		return [0.,0.,0.21568627450980393,];
	}


	function getVertex89(){
		return [0.,0.,0.20588235294117652,];
	}


	function getVertex90(){
		return [0.,0.,0.19607843137254899,];
	}


	function getVertex91(){
		return [0.,0.,0.18627450980392157,];
	}


	function getVertex92(){
		return [0.,0.,0.17647058823529416,];
	}


	function getVertex93(){
		return [0.,0.,0.16666666666666663,];
	}


	function getVertex94(){
		return [0.,0.,0.15686274509803921,];
	}


	function getVertex95(){
		return [0.,0.,0.1470588235294118,];
	}


	function getVertex96(){
		return [0.,0.,0.13725490196078427,];
	}


	function getVertex97(){
		return [0.,0.,0.12745098039215685,];
	}


	function getVertex98(){
		return [0.,0.,0.11764705882352944,];
	}


	function getVertex99(){
		return [0.,0.,0.10784313725490202,];
	}


	function getVertex100(){
		return [0.,0.,0.098039215686274495,];
	}


	function getVertex101(){
		return [0.,0.,0.088235294117647078,];
	}


	function getVertex102(){
		return [0.,0.,0.078431372549019662,];
	}


	function getVertex103(){
		return [0.,0.,0.068627450980392135,];
	}


	function getVertex104(){
		return [0.,0.,0.058823529411764719,];
	}


	function getVertex105(){
		return [0.,0.,0.049019607843137303,];
	}


	function getVertex106(){
		return [0.,0.,0.039215686274509776,];
	}


	function getVertex107(){
		return [0.,0.,0.029411764705882359,];
	}


	function getVertex108(){
		return [0.,0.,0.019607843137254943,];
	}


	function getVertex109(){
		return [0.,0.,0.0098039215686274161,];
	}


	function getVertex110(){
		return [1.,1.,1.,];
	}


	function getVertex111(){
		return [1.,1.,0.,];
	}


	function getVertex112(){
		return [1.,0.,0.,];
	}


	function getVertex113(){
		return [1.,0.,1.,];
	}


	function getVertex114(){
		return [0.,0.,1.,];
	}


	function getVertex115(){
		return [0.,0.,0.,];
	}


	function getVertex116(){
		return [0.,1.,0.,];
	}


	function getVertex117(){
		return [0.,1.,1.,];
	}


	function getVertex118(){
		return [0.,0.,0.99019607843137258,];
	}


	function getVertex119(){
		return [0.,0.,0.98039215686274506,];
	}


	function getVertex120(){
		return [0.,0.,0.97058823529411764,];
	}


	function getVertex121(){
		return [0.,0.,0.96078431372549022,];
	}


	function getVertex122(){
		return [0.,0.,0.9509803921568627,];
	}


	function getVertex123(){
		return [0.,0.,0.94117647058823528,];
	}


	function getVertex124(){
		return [0.,0.,0.93137254901960786,];
	}


	function getVertex125(){
		return [0.,0.,0.92156862745098045,];
	}


	function getVertex126(){
		return [0.,0.,0.91176470588235292,];
	}


	function getVertex127(){
		return [0.,0.,0.90196078431372551,];
	}


	function getVertex128(){
		return [0.,0.,0.89215686274509798,];
	}


	function getVertex129(){
		return [0.,0.,0.88235294117647056,];
	}


	function getVertex130(){
		return [0.,0.,0.87254901960784315,];
	}


	function getVertex131(){
		return [0.,0.,0.86274509803921573,];
	}


	function getVertex132(){
		return [0.,0.,0.8529411764705882,];
	}


	function getVertex133(){
		return [0.,0.,0.84313725490196079,];
	}


	function getVertex134(){
		return [0.,0.,0.83333333333333337,];
	}


	function getVertex135(){
		return [0.,0.,0.82352941176470584,];
	}


	function getVertex136(){
		return [0.,0.,0.81372549019607843,];
	}


	function getVertex137(){
		return [0.,0.,0.80392156862745101,];
	}


	function getVertex138(){
		return [0.,0.,0.79411764705882359,];
	}


	function getVertex139(){
		return [0.,0.,0.78431372549019607,];
	}


	function getVertex140(){
		return [0.,0.,0.77450980392156865,];
	}


	function getVertex141(){
		return [0.,0.,0.76470588235294112,];
	}


	function getVertex142(){
		return [0.,0.,0.75490196078431371,];
	}


	function getVertex143(){
		return [0.,0.,0.74509803921568629,];
	}


	function getVertex144(){
		return [0.,0.,0.73529411764705888,];
	}


	function getVertex145(){
		return [0.,0.,0.72549019607843135,];
	}


	function getVertex146(){
		return [0.,0.,0.71568627450980393,];
	}


	function getVertex147(){
		return [0.,0.,0.70588235294117641,];
	}


	function getVertex148(){
		return [0.,0.,0.69607843137254899,];
	}


	function getVertex149(){
		return [0.,0.,0.68627450980392157,];
	}


	function getVertex150(){
		return [0.,0.,0.67647058823529416,];
	}


	function getVertex151(){
		return [0.,0.,0.66666666666666674,];
	}


	function getVertex152(){
		return [0.,0.,0.65686274509803921,];
	}


	function getVertex153(){
		return [0.,0.,0.6470588235294118,];
	}


	function getVertex154(){
		return [0.,0.,0.63725490196078427,];
	}


	function getVertex155(){
		return [0.,0.,0.62745098039215685,];
	}


	function getVertex156(){
		return [0.,0.,0.61764705882352944,];
	}


	function getVertex157(){
		return [0.,0.,0.60784313725490202,];
	}


	function getVertex158(){
		return [0.,0.,0.59803921568627449,];
	}


	function getVertex159(){
		return [0.,0.,0.58823529411764708,];
	}


	function getVertex160(){
		return [0.,0.,0.57843137254901955,];
	}


	function getVertex161(){
		return [0.,0.,0.56862745098039214,];
	}


	function getVertex162(){
		return [0.,0.,0.55882352941176472,];
	}


	function getVertex163(){
		return [0.,0.,0.5490196078431373,];
	}


	function getVertex164(){
		return [0.,0.,0.53921568627450989,];
	}


	function getVertex165(){
		return [0.,0.,0.52941176470588236,];
	}


	function getVertex166(){
		return [0.,0.,0.51960784313725483,];
	}


	function getVertex167(){
		return [0.,0.,0.50980392156862742,];
	}


	function getVertex168(){
		return [0.,0.,0.5,];
	}


	function getVertex169(){
		return [0.,0.,0.49019607843137258,];
	}


	function getVertex170(){
		return [0.,0.,0.48039215686274506,];
	}


	function getVertex171(){
		return [0.,0.,0.47058823529411764,];
	}


	function getVertex172(){
		return [0.,0.,0.46078431372549022,];
	}


	function getVertex173(){
		return [0.,0.,0.4509803921568627,];
	}


	function getVertex174(){
		return [0.,0.,0.44117647058823528,];
	}


	function getVertex175(){
		return [0.,0.,0.43137254901960786,];
	}


	function getVertex176(){
		return [0.,0.,0.42156862745098045,];
	}


	function getVertex177(){
		return [0.,0.,0.41176470588235292,];
	}


	function getVertex178(){
		return [0.,0.,0.40196078431372551,];
	}


	function getVertex179(){
		return [0.,0.,0.39215686274509809,];
	}


	function getVertex180(){
		return [0.,0.,0.38235294117647056,];
	}


	function getVertex181(){
		return [0.,0.,0.37254901960784315,];
	}


	function getVertex182(){
		return [0.,0.,0.36274509803921573,];
	}


	function getVertex183(){
		return [0.,0.,0.3529411764705882,];
	}


	function getVertex184(){
		return [0.,0.,0.34313725490196079,];
	}


	function getVertex185(){
		return [0.,0.,0.33333333333333337,];
	}


	function getVertex186(){
		return [0.,0.,0.32352941176470584,];
	}


	function getVertex187(){
		return [0.,0.,0.31372549019607843,];
	}


	function getVertex188(){
		return [0.,0.,0.30392156862745101,];
	}


	function getVertex189(){
		return [0.,0.,0.29411764705882359,];
	}


	function getVertex190(){
		return [0.,0.,0.28431372549019607,];
	}


	function getVertex191(){
		return [0.,0.,0.27450980392156865,];
	}


	function getVertex192(){
		return [0.,0.,0.26470588235294124,];
	}


	function getVertex193(){
		return [0.,0.,0.25490196078431371,];
	}


	function getVertex194(){
		return [0.,0.,0.24509803921568629,];
	}


	function getVertex195(){
		return [0.,0.,0.23529411764705888,];
	}


	function getVertex196(){
		return [0.,0.,0.22549019607843135,];
	}


	function getVertex197(){
		return [0.,0.,0.21568627450980393,];
	}


	function getVertex198(){
		return [0.,0.,0.20588235294117652,];
	}


	function getVertex199(){
		return [0.,0.,0.19607843137254899,];
	}


	function getVertex200(){
		return [0.,0.,0.18627450980392157,];
	}


	function getVertex201(){
		return [0.,0.,0.17647058823529416,];
	}


	function getVertex202(){
		return [0.,0.,0.16666666666666663,];
	}


	function getVertex203(){
		return [0.,0.,0.15686274509803921,];
	}


	function getVertex204(){
		return [0.,0.,0.1470588235294118,];
	}


	function getVertex205(){
		return [0.,0.,0.13725490196078427,];
	}


	function getVertex206(){
		return [0.,0.,0.12745098039215685,];
	}


	function getVertex207(){
		return [0.,0.,0.11764705882352944,];
	}


	function getVertex208(){
		return [0.,0.,0.10784313725490202,];
	}


	function getVertex209(){
		return [0.,0.,0.098039215686274495,];
	}


	function getVertex210(){
		return [0.,0.,0.088235294117647078,];
	}


	function getVertex211(){
		return [0.,0.,0.078431372549019662,];
	}


	function getVertex212(){
		return [0.,0.,0.068627450980392135,];
	}


	function getVertex213(){
		return [0.,0.,0.058823529411764719,];
	}


	function getVertex214(){
		return [0.,0.,0.049019607843137303,];
	}


	function getVertex215(){
		return [0.,0.,0.039215686274509776,];
	}


	function getVertex216(){
		return [0.,0.,0.029411764705882359,];
	}


	function getVertex217(){
		return [0.,0.,0.019607843137254943,];
	}


	function getVertex218(){
		return [0.,0.,0.0098039215686274161,];
	}
	// generate labels and spheres for the vertices
	const sphereMaterial1 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere1 = new THREE.Mesh( sphereGeometry, sphereMaterial1 );
	vertexRoot.add(sphere1);
	sphere1.position.set(getVertex1()[0],getVertex1()[1],getVertex1()[2]);

    const lableDiv1 = document.createElement( 'div' );
    lableDiv1.className = 'label';
    lableDiv1.textContent = '1';
    lableDiv1.style.marginTop = '-1em';

    const vertexLabel1 = new CSS2DObject( lableDiv1 );
    vertexLabel1.position.set(getVertex1()[0],getVertex1()[1],getVertex1()[2]);
    vertexlabelRoot.add( vertexLabel1 );
            
            	const sphereMaterial2 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere2 = new THREE.Mesh( sphereGeometry, sphereMaterial2 );
	vertexRoot.add(sphere2);
	sphere2.position.set(getVertex2()[0],getVertex2()[1],getVertex2()[2]);

    const lableDiv2 = document.createElement( 'div' );
    lableDiv2.className = 'label';
    lableDiv2.textContent = '2';
    lableDiv2.style.marginTop = '-1em';

    const vertexLabel2 = new CSS2DObject( lableDiv2 );
    vertexLabel2.position.set(getVertex2()[0],getVertex2()[1],getVertex2()[2]);
    vertexlabelRoot.add( vertexLabel2 );
            
            	const sphereMaterial3 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere3 = new THREE.Mesh( sphereGeometry, sphereMaterial3 );
	vertexRoot.add(sphere3);
	sphere3.position.set(getVertex3()[0],getVertex3()[1],getVertex3()[2]);

    const lableDiv3 = document.createElement( 'div' );
    lableDiv3.className = 'label';
    lableDiv3.textContent = '3';
    lableDiv3.style.marginTop = '-1em';

    const vertexLabel3 = new CSS2DObject( lableDiv3 );
    vertexLabel3.position.set(getVertex3()[0],getVertex3()[1],getVertex3()[2]);
    vertexlabelRoot.add( vertexLabel3 );
            
            	const sphereMaterial4 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere4 = new THREE.Mesh( sphereGeometry, sphereMaterial4 );
	vertexRoot.add(sphere4);
	sphere4.position.set(getVertex4()[0],getVertex4()[1],getVertex4()[2]);

    const lableDiv4 = document.createElement( 'div' );
    lableDiv4.className = 'label';
    lableDiv4.textContent = '4';
    lableDiv4.style.marginTop = '-1em';

    const vertexLabel4 = new CSS2DObject( lableDiv4 );
    vertexLabel4.position.set(getVertex4()[0],getVertex4()[1],getVertex4()[2]);
    vertexlabelRoot.add( vertexLabel4 );
            
            	const sphereMaterial5 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere5 = new THREE.Mesh( sphereGeometry, sphereMaterial5 );
	vertexRoot.add(sphere5);
	sphere5.position.set(getVertex5()[0],getVertex5()[1],getVertex5()[2]);

    const lableDiv5 = document.createElement( 'div' );
    lableDiv5.className = 'label';
    lableDiv5.textContent = '5';
    lableDiv5.style.marginTop = '-1em';

    const vertexLabel5 = new CSS2DObject( lableDiv5 );
    vertexLabel5.position.set(getVertex5()[0],getVertex5()[1],getVertex5()[2]);
    vertexlabelRoot.add( vertexLabel5 );
            
            	const sphereMaterial6 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere6 = new THREE.Mesh( sphereGeometry, sphereMaterial6 );
	vertexRoot.add(sphere6);
	sphere6.position.set(getVertex6()[0],getVertex6()[1],getVertex6()[2]);

    const lableDiv6 = document.createElement( 'div' );
    lableDiv6.className = 'label';
    lableDiv6.textContent = '6';
    lableDiv6.style.marginTop = '-1em';

    const vertexLabel6 = new CSS2DObject( lableDiv6 );
    vertexLabel6.position.set(getVertex6()[0],getVertex6()[1],getVertex6()[2]);
    vertexlabelRoot.add( vertexLabel6 );
            
            	const sphereMaterial7 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere7 = new THREE.Mesh( sphereGeometry, sphereMaterial7 );
	vertexRoot.add(sphere7);
	sphere7.position.set(getVertex7()[0],getVertex7()[1],getVertex7()[2]);

    const lableDiv7 = document.createElement( 'div' );
    lableDiv7.className = 'label';
    lableDiv7.textContent = '7';
    lableDiv7.style.marginTop = '-1em';

    const vertexLabel7 = new CSS2DObject( lableDiv7 );
    vertexLabel7.position.set(getVertex7()[0],getVertex7()[1],getVertex7()[2]);
    vertexlabelRoot.add( vertexLabel7 );
            
            	const sphereMaterial8 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere8 = new THREE.Mesh( sphereGeometry, sphereMaterial8 );
	vertexRoot.add(sphere8);
	sphere8.position.set(getVertex8()[0],getVertex8()[1],getVertex8()[2]);

    const lableDiv8 = document.createElement( 'div' );
    lableDiv8.className = 'label';
    lableDiv8.textContent = '8';
    lableDiv8.style.marginTop = '-1em';

    const vertexLabel8 = new CSS2DObject( lableDiv8 );
    vertexLabel8.position.set(getVertex8()[0],getVertex8()[1],getVertex8()[2]);
    vertexlabelRoot.add( vertexLabel8 );
            
            	const sphereMaterial9 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere9 = new THREE.Mesh( sphereGeometry, sphereMaterial9 );
	vertexRoot.add(sphere9);
	sphere9.position.set(getVertex9()[0],getVertex9()[1],getVertex9()[2]);

    const lableDiv9 = document.createElement( 'div' );
    lableDiv9.className = 'label';
    lableDiv9.textContent = '9';
    lableDiv9.style.marginTop = '-1em';

    const vertexLabel9 = new CSS2DObject( lableDiv9 );
    vertexLabel9.position.set(getVertex9()[0],getVertex9()[1],getVertex9()[2]);
    vertexlabelRoot.add( vertexLabel9 );
            
            	const sphereMaterial10 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere10 = new THREE.Mesh( sphereGeometry, sphereMaterial10 );
	vertexRoot.add(sphere10);
	sphere10.position.set(getVertex10()[0],getVertex10()[1],getVertex10()[2]);

    const lableDiv10 = document.createElement( 'div' );
    lableDiv10.className = 'label';
    lableDiv10.textContent = '10';
    lableDiv10.style.marginTop = '-1em';

    const vertexLabel10 = new CSS2DObject( lableDiv10 );
    vertexLabel10.position.set(getVertex10()[0],getVertex10()[1],getVertex10()[2]);
    vertexlabelRoot.add( vertexLabel10 );
            
            	const sphereMaterial11 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere11 = new THREE.Mesh( sphereGeometry, sphereMaterial11 );
	vertexRoot.add(sphere11);
	sphere11.position.set(getVertex11()[0],getVertex11()[1],getVertex11()[2]);

    const lableDiv11 = document.createElement( 'div' );
    lableDiv11.className = 'label';
    lableDiv11.textContent = '11';
    lableDiv11.style.marginTop = '-1em';

    const vertexLabel11 = new CSS2DObject( lableDiv11 );
    vertexLabel11.position.set(getVertex11()[0],getVertex11()[1],getVertex11()[2]);
    vertexlabelRoot.add( vertexLabel11 );
            
            	const sphereMaterial12 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere12 = new THREE.Mesh( sphereGeometry, sphereMaterial12 );
	vertexRoot.add(sphere12);
	sphere12.position.set(getVertex12()[0],getVertex12()[1],getVertex12()[2]);

    const lableDiv12 = document.createElement( 'div' );
    lableDiv12.className = 'label';
    lableDiv12.textContent = '12';
    lableDiv12.style.marginTop = '-1em';

    const vertexLabel12 = new CSS2DObject( lableDiv12 );
    vertexLabel12.position.set(getVertex12()[0],getVertex12()[1],getVertex12()[2]);
    vertexlabelRoot.add( vertexLabel12 );
            
            	const sphereMaterial13 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere13 = new THREE.Mesh( sphereGeometry, sphereMaterial13 );
	vertexRoot.add(sphere13);
	sphere13.position.set(getVertex13()[0],getVertex13()[1],getVertex13()[2]);

    const lableDiv13 = document.createElement( 'div' );
    lableDiv13.className = 'label';
    lableDiv13.textContent = '13';
    lableDiv13.style.marginTop = '-1em';

    const vertexLabel13 = new CSS2DObject( lableDiv13 );
    vertexLabel13.position.set(getVertex13()[0],getVertex13()[1],getVertex13()[2]);
    vertexlabelRoot.add( vertexLabel13 );
            
            	const sphereMaterial14 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere14 = new THREE.Mesh( sphereGeometry, sphereMaterial14 );
	vertexRoot.add(sphere14);
	sphere14.position.set(getVertex14()[0],getVertex14()[1],getVertex14()[2]);

    const lableDiv14 = document.createElement( 'div' );
    lableDiv14.className = 'label';
    lableDiv14.textContent = '14';
    lableDiv14.style.marginTop = '-1em';

    const vertexLabel14 = new CSS2DObject( lableDiv14 );
    vertexLabel14.position.set(getVertex14()[0],getVertex14()[1],getVertex14()[2]);
    vertexlabelRoot.add( vertexLabel14 );
            
            	const sphereMaterial15 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere15 = new THREE.Mesh( sphereGeometry, sphereMaterial15 );
	vertexRoot.add(sphere15);
	sphere15.position.set(getVertex15()[0],getVertex15()[1],getVertex15()[2]);

    const lableDiv15 = document.createElement( 'div' );
    lableDiv15.className = 'label';
    lableDiv15.textContent = '15';
    lableDiv15.style.marginTop = '-1em';

    const vertexLabel15 = new CSS2DObject( lableDiv15 );
    vertexLabel15.position.set(getVertex15()[0],getVertex15()[1],getVertex15()[2]);
    vertexlabelRoot.add( vertexLabel15 );
            
            	const sphereMaterial16 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere16 = new THREE.Mesh( sphereGeometry, sphereMaterial16 );
	vertexRoot.add(sphere16);
	sphere16.position.set(getVertex16()[0],getVertex16()[1],getVertex16()[2]);

    const lableDiv16 = document.createElement( 'div' );
    lableDiv16.className = 'label';
    lableDiv16.textContent = '16';
    lableDiv16.style.marginTop = '-1em';

    const vertexLabel16 = new CSS2DObject( lableDiv16 );
    vertexLabel16.position.set(getVertex16()[0],getVertex16()[1],getVertex16()[2]);
    vertexlabelRoot.add( vertexLabel16 );
            
            	const sphereMaterial17 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere17 = new THREE.Mesh( sphereGeometry, sphereMaterial17 );
	vertexRoot.add(sphere17);
	sphere17.position.set(getVertex17()[0],getVertex17()[1],getVertex17()[2]);

    const lableDiv17 = document.createElement( 'div' );
    lableDiv17.className = 'label';
    lableDiv17.textContent = '17';
    lableDiv17.style.marginTop = '-1em';

    const vertexLabel17 = new CSS2DObject( lableDiv17 );
    vertexLabel17.position.set(getVertex17()[0],getVertex17()[1],getVertex17()[2]);
    vertexlabelRoot.add( vertexLabel17 );
            
            	const sphereMaterial18 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere18 = new THREE.Mesh( sphereGeometry, sphereMaterial18 );
	vertexRoot.add(sphere18);
	sphere18.position.set(getVertex18()[0],getVertex18()[1],getVertex18()[2]);

    const lableDiv18 = document.createElement( 'div' );
    lableDiv18.className = 'label';
    lableDiv18.textContent = '18';
    lableDiv18.style.marginTop = '-1em';

    const vertexLabel18 = new CSS2DObject( lableDiv18 );
    vertexLabel18.position.set(getVertex18()[0],getVertex18()[1],getVertex18()[2]);
    vertexlabelRoot.add( vertexLabel18 );
            
            	const sphereMaterial19 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere19 = new THREE.Mesh( sphereGeometry, sphereMaterial19 );
	vertexRoot.add(sphere19);
	sphere19.position.set(getVertex19()[0],getVertex19()[1],getVertex19()[2]);

    const lableDiv19 = document.createElement( 'div' );
    lableDiv19.className = 'label';
    lableDiv19.textContent = '19';
    lableDiv19.style.marginTop = '-1em';

    const vertexLabel19 = new CSS2DObject( lableDiv19 );
    vertexLabel19.position.set(getVertex19()[0],getVertex19()[1],getVertex19()[2]);
    vertexlabelRoot.add( vertexLabel19 );
            
            	const sphereMaterial20 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere20 = new THREE.Mesh( sphereGeometry, sphereMaterial20 );
	vertexRoot.add(sphere20);
	sphere20.position.set(getVertex20()[0],getVertex20()[1],getVertex20()[2]);

    const lableDiv20 = document.createElement( 'div' );
    lableDiv20.className = 'label';
    lableDiv20.textContent = '20';
    lableDiv20.style.marginTop = '-1em';

    const vertexLabel20 = new CSS2DObject( lableDiv20 );
    vertexLabel20.position.set(getVertex20()[0],getVertex20()[1],getVertex20()[2]);
    vertexlabelRoot.add( vertexLabel20 );
            
            	const sphereMaterial21 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere21 = new THREE.Mesh( sphereGeometry, sphereMaterial21 );
	vertexRoot.add(sphere21);
	sphere21.position.set(getVertex21()[0],getVertex21()[1],getVertex21()[2]);

    const lableDiv21 = document.createElement( 'div' );
    lableDiv21.className = 'label';
    lableDiv21.textContent = '21';
    lableDiv21.style.marginTop = '-1em';

    const vertexLabel21 = new CSS2DObject( lableDiv21 );
    vertexLabel21.position.set(getVertex21()[0],getVertex21()[1],getVertex21()[2]);
    vertexlabelRoot.add( vertexLabel21 );
            
            	const sphereMaterial22 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere22 = new THREE.Mesh( sphereGeometry, sphereMaterial22 );
	vertexRoot.add(sphere22);
	sphere22.position.set(getVertex22()[0],getVertex22()[1],getVertex22()[2]);

    const lableDiv22 = document.createElement( 'div' );
    lableDiv22.className = 'label';
    lableDiv22.textContent = '22';
    lableDiv22.style.marginTop = '-1em';

    const vertexLabel22 = new CSS2DObject( lableDiv22 );
    vertexLabel22.position.set(getVertex22()[0],getVertex22()[1],getVertex22()[2]);
    vertexlabelRoot.add( vertexLabel22 );
            
            	const sphereMaterial23 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere23 = new THREE.Mesh( sphereGeometry, sphereMaterial23 );
	vertexRoot.add(sphere23);
	sphere23.position.set(getVertex23()[0],getVertex23()[1],getVertex23()[2]);

    const lableDiv23 = document.createElement( 'div' );
    lableDiv23.className = 'label';
    lableDiv23.textContent = '23';
    lableDiv23.style.marginTop = '-1em';

    const vertexLabel23 = new CSS2DObject( lableDiv23 );
    vertexLabel23.position.set(getVertex23()[0],getVertex23()[1],getVertex23()[2]);
    vertexlabelRoot.add( vertexLabel23 );
            
            	const sphereMaterial24 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere24 = new THREE.Mesh( sphereGeometry, sphereMaterial24 );
	vertexRoot.add(sphere24);
	sphere24.position.set(getVertex24()[0],getVertex24()[1],getVertex24()[2]);

    const lableDiv24 = document.createElement( 'div' );
    lableDiv24.className = 'label';
    lableDiv24.textContent = '24';
    lableDiv24.style.marginTop = '-1em';

    const vertexLabel24 = new CSS2DObject( lableDiv24 );
    vertexLabel24.position.set(getVertex24()[0],getVertex24()[1],getVertex24()[2]);
    vertexlabelRoot.add( vertexLabel24 );
            
            	const sphereMaterial25 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere25 = new THREE.Mesh( sphereGeometry, sphereMaterial25 );
	vertexRoot.add(sphere25);
	sphere25.position.set(getVertex25()[0],getVertex25()[1],getVertex25()[2]);

    const lableDiv25 = document.createElement( 'div' );
    lableDiv25.className = 'label';
    lableDiv25.textContent = '25';
    lableDiv25.style.marginTop = '-1em';

    const vertexLabel25 = new CSS2DObject( lableDiv25 );
    vertexLabel25.position.set(getVertex25()[0],getVertex25()[1],getVertex25()[2]);
    vertexlabelRoot.add( vertexLabel25 );
            
            	const sphereMaterial26 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere26 = new THREE.Mesh( sphereGeometry, sphereMaterial26 );
	vertexRoot.add(sphere26);
	sphere26.position.set(getVertex26()[0],getVertex26()[1],getVertex26()[2]);

    const lableDiv26 = document.createElement( 'div' );
    lableDiv26.className = 'label';
    lableDiv26.textContent = '26';
    lableDiv26.style.marginTop = '-1em';

    const vertexLabel26 = new CSS2DObject( lableDiv26 );
    vertexLabel26.position.set(getVertex26()[0],getVertex26()[1],getVertex26()[2]);
    vertexlabelRoot.add( vertexLabel26 );
            
            	const sphereMaterial27 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere27 = new THREE.Mesh( sphereGeometry, sphereMaterial27 );
	vertexRoot.add(sphere27);
	sphere27.position.set(getVertex27()[0],getVertex27()[1],getVertex27()[2]);

    const lableDiv27 = document.createElement( 'div' );
    lableDiv27.className = 'label';
    lableDiv27.textContent = '27';
    lableDiv27.style.marginTop = '-1em';

    const vertexLabel27 = new CSS2DObject( lableDiv27 );
    vertexLabel27.position.set(getVertex27()[0],getVertex27()[1],getVertex27()[2]);
    vertexlabelRoot.add( vertexLabel27 );
            
            	const sphereMaterial28 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere28 = new THREE.Mesh( sphereGeometry, sphereMaterial28 );
	vertexRoot.add(sphere28);
	sphere28.position.set(getVertex28()[0],getVertex28()[1],getVertex28()[2]);

    const lableDiv28 = document.createElement( 'div' );
    lableDiv28.className = 'label';
    lableDiv28.textContent = '28';
    lableDiv28.style.marginTop = '-1em';

    const vertexLabel28 = new CSS2DObject( lableDiv28 );
    vertexLabel28.position.set(getVertex28()[0],getVertex28()[1],getVertex28()[2]);
    vertexlabelRoot.add( vertexLabel28 );
            
            	const sphereMaterial29 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere29 = new THREE.Mesh( sphereGeometry, sphereMaterial29 );
	vertexRoot.add(sphere29);
	sphere29.position.set(getVertex29()[0],getVertex29()[1],getVertex29()[2]);

    const lableDiv29 = document.createElement( 'div' );
    lableDiv29.className = 'label';
    lableDiv29.textContent = '29';
    lableDiv29.style.marginTop = '-1em';

    const vertexLabel29 = new CSS2DObject( lableDiv29 );
    vertexLabel29.position.set(getVertex29()[0],getVertex29()[1],getVertex29()[2]);
    vertexlabelRoot.add( vertexLabel29 );
            
            	const sphereMaterial30 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere30 = new THREE.Mesh( sphereGeometry, sphereMaterial30 );
	vertexRoot.add(sphere30);
	sphere30.position.set(getVertex30()[0],getVertex30()[1],getVertex30()[2]);

    const lableDiv30 = document.createElement( 'div' );
    lableDiv30.className = 'label';
    lableDiv30.textContent = '30';
    lableDiv30.style.marginTop = '-1em';

    const vertexLabel30 = new CSS2DObject( lableDiv30 );
    vertexLabel30.position.set(getVertex30()[0],getVertex30()[1],getVertex30()[2]);
    vertexlabelRoot.add( vertexLabel30 );
            
            	const sphereMaterial31 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere31 = new THREE.Mesh( sphereGeometry, sphereMaterial31 );
	vertexRoot.add(sphere31);
	sphere31.position.set(getVertex31()[0],getVertex31()[1],getVertex31()[2]);

    const lableDiv31 = document.createElement( 'div' );
    lableDiv31.className = 'label';
    lableDiv31.textContent = '31';
    lableDiv31.style.marginTop = '-1em';

    const vertexLabel31 = new CSS2DObject( lableDiv31 );
    vertexLabel31.position.set(getVertex31()[0],getVertex31()[1],getVertex31()[2]);
    vertexlabelRoot.add( vertexLabel31 );
            
            	const sphereMaterial32 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere32 = new THREE.Mesh( sphereGeometry, sphereMaterial32 );
	vertexRoot.add(sphere32);
	sphere32.position.set(getVertex32()[0],getVertex32()[1],getVertex32()[2]);

    const lableDiv32 = document.createElement( 'div' );
    lableDiv32.className = 'label';
    lableDiv32.textContent = '32';
    lableDiv32.style.marginTop = '-1em';

    const vertexLabel32 = new CSS2DObject( lableDiv32 );
    vertexLabel32.position.set(getVertex32()[0],getVertex32()[1],getVertex32()[2]);
    vertexlabelRoot.add( vertexLabel32 );
            
            	const sphereMaterial33 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere33 = new THREE.Mesh( sphereGeometry, sphereMaterial33 );
	vertexRoot.add(sphere33);
	sphere33.position.set(getVertex33()[0],getVertex33()[1],getVertex33()[2]);

    const lableDiv33 = document.createElement( 'div' );
    lableDiv33.className = 'label';
    lableDiv33.textContent = '33';
    lableDiv33.style.marginTop = '-1em';

    const vertexLabel33 = new CSS2DObject( lableDiv33 );
    vertexLabel33.position.set(getVertex33()[0],getVertex33()[1],getVertex33()[2]);
    vertexlabelRoot.add( vertexLabel33 );
            
            	const sphereMaterial34 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere34 = new THREE.Mesh( sphereGeometry, sphereMaterial34 );
	vertexRoot.add(sphere34);
	sphere34.position.set(getVertex34()[0],getVertex34()[1],getVertex34()[2]);

    const lableDiv34 = document.createElement( 'div' );
    lableDiv34.className = 'label';
    lableDiv34.textContent = '34';
    lableDiv34.style.marginTop = '-1em';

    const vertexLabel34 = new CSS2DObject( lableDiv34 );
    vertexLabel34.position.set(getVertex34()[0],getVertex34()[1],getVertex34()[2]);
    vertexlabelRoot.add( vertexLabel34 );
            
            	const sphereMaterial35 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere35 = new THREE.Mesh( sphereGeometry, sphereMaterial35 );
	vertexRoot.add(sphere35);
	sphere35.position.set(getVertex35()[0],getVertex35()[1],getVertex35()[2]);

    const lableDiv35 = document.createElement( 'div' );
    lableDiv35.className = 'label';
    lableDiv35.textContent = '35';
    lableDiv35.style.marginTop = '-1em';

    const vertexLabel35 = new CSS2DObject( lableDiv35 );
    vertexLabel35.position.set(getVertex35()[0],getVertex35()[1],getVertex35()[2]);
    vertexlabelRoot.add( vertexLabel35 );
            
            	const sphereMaterial36 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere36 = new THREE.Mesh( sphereGeometry, sphereMaterial36 );
	vertexRoot.add(sphere36);
	sphere36.position.set(getVertex36()[0],getVertex36()[1],getVertex36()[2]);

    const lableDiv36 = document.createElement( 'div' );
    lableDiv36.className = 'label';
    lableDiv36.textContent = '36';
    lableDiv36.style.marginTop = '-1em';

    const vertexLabel36 = new CSS2DObject( lableDiv36 );
    vertexLabel36.position.set(getVertex36()[0],getVertex36()[1],getVertex36()[2]);
    vertexlabelRoot.add( vertexLabel36 );
            
            	const sphereMaterial37 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere37 = new THREE.Mesh( sphereGeometry, sphereMaterial37 );
	vertexRoot.add(sphere37);
	sphere37.position.set(getVertex37()[0],getVertex37()[1],getVertex37()[2]);

    const lableDiv37 = document.createElement( 'div' );
    lableDiv37.className = 'label';
    lableDiv37.textContent = '37';
    lableDiv37.style.marginTop = '-1em';

    const vertexLabel37 = new CSS2DObject( lableDiv37 );
    vertexLabel37.position.set(getVertex37()[0],getVertex37()[1],getVertex37()[2]);
    vertexlabelRoot.add( vertexLabel37 );
            
            	const sphereMaterial38 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere38 = new THREE.Mesh( sphereGeometry, sphereMaterial38 );
	vertexRoot.add(sphere38);
	sphere38.position.set(getVertex38()[0],getVertex38()[1],getVertex38()[2]);

    const lableDiv38 = document.createElement( 'div' );
    lableDiv38.className = 'label';
    lableDiv38.textContent = '38';
    lableDiv38.style.marginTop = '-1em';

    const vertexLabel38 = new CSS2DObject( lableDiv38 );
    vertexLabel38.position.set(getVertex38()[0],getVertex38()[1],getVertex38()[2]);
    vertexlabelRoot.add( vertexLabel38 );
            
            	const sphereMaterial39 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere39 = new THREE.Mesh( sphereGeometry, sphereMaterial39 );
	vertexRoot.add(sphere39);
	sphere39.position.set(getVertex39()[0],getVertex39()[1],getVertex39()[2]);

    const lableDiv39 = document.createElement( 'div' );
    lableDiv39.className = 'label';
    lableDiv39.textContent = '39';
    lableDiv39.style.marginTop = '-1em';

    const vertexLabel39 = new CSS2DObject( lableDiv39 );
    vertexLabel39.position.set(getVertex39()[0],getVertex39()[1],getVertex39()[2]);
    vertexlabelRoot.add( vertexLabel39 );
            
            	const sphereMaterial40 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere40 = new THREE.Mesh( sphereGeometry, sphereMaterial40 );
	vertexRoot.add(sphere40);
	sphere40.position.set(getVertex40()[0],getVertex40()[1],getVertex40()[2]);

    const lableDiv40 = document.createElement( 'div' );
    lableDiv40.className = 'label';
    lableDiv40.textContent = '40';
    lableDiv40.style.marginTop = '-1em';

    const vertexLabel40 = new CSS2DObject( lableDiv40 );
    vertexLabel40.position.set(getVertex40()[0],getVertex40()[1],getVertex40()[2]);
    vertexlabelRoot.add( vertexLabel40 );
            
            	const sphereMaterial41 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere41 = new THREE.Mesh( sphereGeometry, sphereMaterial41 );
	vertexRoot.add(sphere41);
	sphere41.position.set(getVertex41()[0],getVertex41()[1],getVertex41()[2]);

    const lableDiv41 = document.createElement( 'div' );
    lableDiv41.className = 'label';
    lableDiv41.textContent = '41';
    lableDiv41.style.marginTop = '-1em';

    const vertexLabel41 = new CSS2DObject( lableDiv41 );
    vertexLabel41.position.set(getVertex41()[0],getVertex41()[1],getVertex41()[2]);
    vertexlabelRoot.add( vertexLabel41 );
            
            	const sphereMaterial42 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere42 = new THREE.Mesh( sphereGeometry, sphereMaterial42 );
	vertexRoot.add(sphere42);
	sphere42.position.set(getVertex42()[0],getVertex42()[1],getVertex42()[2]);

    const lableDiv42 = document.createElement( 'div' );
    lableDiv42.className = 'label';
    lableDiv42.textContent = '42';
    lableDiv42.style.marginTop = '-1em';

    const vertexLabel42 = new CSS2DObject( lableDiv42 );
    vertexLabel42.position.set(getVertex42()[0],getVertex42()[1],getVertex42()[2]);
    vertexlabelRoot.add( vertexLabel42 );
            
            	const sphereMaterial43 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere43 = new THREE.Mesh( sphereGeometry, sphereMaterial43 );
	vertexRoot.add(sphere43);
	sphere43.position.set(getVertex43()[0],getVertex43()[1],getVertex43()[2]);

    const lableDiv43 = document.createElement( 'div' );
    lableDiv43.className = 'label';
    lableDiv43.textContent = '43';
    lableDiv43.style.marginTop = '-1em';

    const vertexLabel43 = new CSS2DObject( lableDiv43 );
    vertexLabel43.position.set(getVertex43()[0],getVertex43()[1],getVertex43()[2]);
    vertexlabelRoot.add( vertexLabel43 );
            
            	const sphereMaterial44 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere44 = new THREE.Mesh( sphereGeometry, sphereMaterial44 );
	vertexRoot.add(sphere44);
	sphere44.position.set(getVertex44()[0],getVertex44()[1],getVertex44()[2]);

    const lableDiv44 = document.createElement( 'div' );
    lableDiv44.className = 'label';
    lableDiv44.textContent = '44';
    lableDiv44.style.marginTop = '-1em';

    const vertexLabel44 = new CSS2DObject( lableDiv44 );
    vertexLabel44.position.set(getVertex44()[0],getVertex44()[1],getVertex44()[2]);
    vertexlabelRoot.add( vertexLabel44 );
            
            	const sphereMaterial45 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere45 = new THREE.Mesh( sphereGeometry, sphereMaterial45 );
	vertexRoot.add(sphere45);
	sphere45.position.set(getVertex45()[0],getVertex45()[1],getVertex45()[2]);

    const lableDiv45 = document.createElement( 'div' );
    lableDiv45.className = 'label';
    lableDiv45.textContent = '45';
    lableDiv45.style.marginTop = '-1em';

    const vertexLabel45 = new CSS2DObject( lableDiv45 );
    vertexLabel45.position.set(getVertex45()[0],getVertex45()[1],getVertex45()[2]);
    vertexlabelRoot.add( vertexLabel45 );
            
            	const sphereMaterial46 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere46 = new THREE.Mesh( sphereGeometry, sphereMaterial46 );
	vertexRoot.add(sphere46);
	sphere46.position.set(getVertex46()[0],getVertex46()[1],getVertex46()[2]);

    const lableDiv46 = document.createElement( 'div' );
    lableDiv46.className = 'label';
    lableDiv46.textContent = '46';
    lableDiv46.style.marginTop = '-1em';

    const vertexLabel46 = new CSS2DObject( lableDiv46 );
    vertexLabel46.position.set(getVertex46()[0],getVertex46()[1],getVertex46()[2]);
    vertexlabelRoot.add( vertexLabel46 );
            
            	const sphereMaterial47 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere47 = new THREE.Mesh( sphereGeometry, sphereMaterial47 );
	vertexRoot.add(sphere47);
	sphere47.position.set(getVertex47()[0],getVertex47()[1],getVertex47()[2]);

    const lableDiv47 = document.createElement( 'div' );
    lableDiv47.className = 'label';
    lableDiv47.textContent = '47';
    lableDiv47.style.marginTop = '-1em';

    const vertexLabel47 = new CSS2DObject( lableDiv47 );
    vertexLabel47.position.set(getVertex47()[0],getVertex47()[1],getVertex47()[2]);
    vertexlabelRoot.add( vertexLabel47 );
            
            	const sphereMaterial48 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere48 = new THREE.Mesh( sphereGeometry, sphereMaterial48 );
	vertexRoot.add(sphere48);
	sphere48.position.set(getVertex48()[0],getVertex48()[1],getVertex48()[2]);

    const lableDiv48 = document.createElement( 'div' );
    lableDiv48.className = 'label';
    lableDiv48.textContent = '48';
    lableDiv48.style.marginTop = '-1em';

    const vertexLabel48 = new CSS2DObject( lableDiv48 );
    vertexLabel48.position.set(getVertex48()[0],getVertex48()[1],getVertex48()[2]);
    vertexlabelRoot.add( vertexLabel48 );
            
            	const sphereMaterial49 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere49 = new THREE.Mesh( sphereGeometry, sphereMaterial49 );
	vertexRoot.add(sphere49);
	sphere49.position.set(getVertex49()[0],getVertex49()[1],getVertex49()[2]);

    const lableDiv49 = document.createElement( 'div' );
    lableDiv49.className = 'label';
    lableDiv49.textContent = '49';
    lableDiv49.style.marginTop = '-1em';

    const vertexLabel49 = new CSS2DObject( lableDiv49 );
    vertexLabel49.position.set(getVertex49()[0],getVertex49()[1],getVertex49()[2]);
    vertexlabelRoot.add( vertexLabel49 );
            
            	const sphereMaterial50 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere50 = new THREE.Mesh( sphereGeometry, sphereMaterial50 );
	vertexRoot.add(sphere50);
	sphere50.position.set(getVertex50()[0],getVertex50()[1],getVertex50()[2]);

    const lableDiv50 = document.createElement( 'div' );
    lableDiv50.className = 'label';
    lableDiv50.textContent = '50';
    lableDiv50.style.marginTop = '-1em';

    const vertexLabel50 = new CSS2DObject( lableDiv50 );
    vertexLabel50.position.set(getVertex50()[0],getVertex50()[1],getVertex50()[2]);
    vertexlabelRoot.add( vertexLabel50 );
            
            	const sphereMaterial51 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere51 = new THREE.Mesh( sphereGeometry, sphereMaterial51 );
	vertexRoot.add(sphere51);
	sphere51.position.set(getVertex51()[0],getVertex51()[1],getVertex51()[2]);

    const lableDiv51 = document.createElement( 'div' );
    lableDiv51.className = 'label';
    lableDiv51.textContent = '51';
    lableDiv51.style.marginTop = '-1em';

    const vertexLabel51 = new CSS2DObject( lableDiv51 );
    vertexLabel51.position.set(getVertex51()[0],getVertex51()[1],getVertex51()[2]);
    vertexlabelRoot.add( vertexLabel51 );
            
            	const sphereMaterial52 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere52 = new THREE.Mesh( sphereGeometry, sphereMaterial52 );
	vertexRoot.add(sphere52);
	sphere52.position.set(getVertex52()[0],getVertex52()[1],getVertex52()[2]);

    const lableDiv52 = document.createElement( 'div' );
    lableDiv52.className = 'label';
    lableDiv52.textContent = '52';
    lableDiv52.style.marginTop = '-1em';

    const vertexLabel52 = new CSS2DObject( lableDiv52 );
    vertexLabel52.position.set(getVertex52()[0],getVertex52()[1],getVertex52()[2]);
    vertexlabelRoot.add( vertexLabel52 );
            
            	const sphereMaterial53 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere53 = new THREE.Mesh( sphereGeometry, sphereMaterial53 );
	vertexRoot.add(sphere53);
	sphere53.position.set(getVertex53()[0],getVertex53()[1],getVertex53()[2]);

    const lableDiv53 = document.createElement( 'div' );
    lableDiv53.className = 'label';
    lableDiv53.textContent = '53';
    lableDiv53.style.marginTop = '-1em';

    const vertexLabel53 = new CSS2DObject( lableDiv53 );
    vertexLabel53.position.set(getVertex53()[0],getVertex53()[1],getVertex53()[2]);
    vertexlabelRoot.add( vertexLabel53 );
            
            	const sphereMaterial54 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere54 = new THREE.Mesh( sphereGeometry, sphereMaterial54 );
	vertexRoot.add(sphere54);
	sphere54.position.set(getVertex54()[0],getVertex54()[1],getVertex54()[2]);

    const lableDiv54 = document.createElement( 'div' );
    lableDiv54.className = 'label';
    lableDiv54.textContent = '54';
    lableDiv54.style.marginTop = '-1em';

    const vertexLabel54 = new CSS2DObject( lableDiv54 );
    vertexLabel54.position.set(getVertex54()[0],getVertex54()[1],getVertex54()[2]);
    vertexlabelRoot.add( vertexLabel54 );
            
            	const sphereMaterial55 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere55 = new THREE.Mesh( sphereGeometry, sphereMaterial55 );
	vertexRoot.add(sphere55);
	sphere55.position.set(getVertex55()[0],getVertex55()[1],getVertex55()[2]);

    const lableDiv55 = document.createElement( 'div' );
    lableDiv55.className = 'label';
    lableDiv55.textContent = '55';
    lableDiv55.style.marginTop = '-1em';

    const vertexLabel55 = new CSS2DObject( lableDiv55 );
    vertexLabel55.position.set(getVertex55()[0],getVertex55()[1],getVertex55()[2]);
    vertexlabelRoot.add( vertexLabel55 );
            
            	const sphereMaterial56 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere56 = new THREE.Mesh( sphereGeometry, sphereMaterial56 );
	vertexRoot.add(sphere56);
	sphere56.position.set(getVertex56()[0],getVertex56()[1],getVertex56()[2]);

    const lableDiv56 = document.createElement( 'div' );
    lableDiv56.className = 'label';
    lableDiv56.textContent = '56';
    lableDiv56.style.marginTop = '-1em';

    const vertexLabel56 = new CSS2DObject( lableDiv56 );
    vertexLabel56.position.set(getVertex56()[0],getVertex56()[1],getVertex56()[2]);
    vertexlabelRoot.add( vertexLabel56 );
            
            	const sphereMaterial57 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere57 = new THREE.Mesh( sphereGeometry, sphereMaterial57 );
	vertexRoot.add(sphere57);
	sphere57.position.set(getVertex57()[0],getVertex57()[1],getVertex57()[2]);

    const lableDiv57 = document.createElement( 'div' );
    lableDiv57.className = 'label';
    lableDiv57.textContent = '57';
    lableDiv57.style.marginTop = '-1em';

    const vertexLabel57 = new CSS2DObject( lableDiv57 );
    vertexLabel57.position.set(getVertex57()[0],getVertex57()[1],getVertex57()[2]);
    vertexlabelRoot.add( vertexLabel57 );
            
            	const sphereMaterial58 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere58 = new THREE.Mesh( sphereGeometry, sphereMaterial58 );
	vertexRoot.add(sphere58);
	sphere58.position.set(getVertex58()[0],getVertex58()[1],getVertex58()[2]);

    const lableDiv58 = document.createElement( 'div' );
    lableDiv58.className = 'label';
    lableDiv58.textContent = '58';
    lableDiv58.style.marginTop = '-1em';

    const vertexLabel58 = new CSS2DObject( lableDiv58 );
    vertexLabel58.position.set(getVertex58()[0],getVertex58()[1],getVertex58()[2]);
    vertexlabelRoot.add( vertexLabel58 );
            
            	const sphereMaterial59 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere59 = new THREE.Mesh( sphereGeometry, sphereMaterial59 );
	vertexRoot.add(sphere59);
	sphere59.position.set(getVertex59()[0],getVertex59()[1],getVertex59()[2]);

    const lableDiv59 = document.createElement( 'div' );
    lableDiv59.className = 'label';
    lableDiv59.textContent = '59';
    lableDiv59.style.marginTop = '-1em';

    const vertexLabel59 = new CSS2DObject( lableDiv59 );
    vertexLabel59.position.set(getVertex59()[0],getVertex59()[1],getVertex59()[2]);
    vertexlabelRoot.add( vertexLabel59 );
            
            	const sphereMaterial60 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere60 = new THREE.Mesh( sphereGeometry, sphereMaterial60 );
	vertexRoot.add(sphere60);
	sphere60.position.set(getVertex60()[0],getVertex60()[1],getVertex60()[2]);

    const lableDiv60 = document.createElement( 'div' );
    lableDiv60.className = 'label';
    lableDiv60.textContent = '60';
    lableDiv60.style.marginTop = '-1em';

    const vertexLabel60 = new CSS2DObject( lableDiv60 );
    vertexLabel60.position.set(getVertex60()[0],getVertex60()[1],getVertex60()[2]);
    vertexlabelRoot.add( vertexLabel60 );
            
            	const sphereMaterial61 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere61 = new THREE.Mesh( sphereGeometry, sphereMaterial61 );
	vertexRoot.add(sphere61);
	sphere61.position.set(getVertex61()[0],getVertex61()[1],getVertex61()[2]);

    const lableDiv61 = document.createElement( 'div' );
    lableDiv61.className = 'label';
    lableDiv61.textContent = '61';
    lableDiv61.style.marginTop = '-1em';

    const vertexLabel61 = new CSS2DObject( lableDiv61 );
    vertexLabel61.position.set(getVertex61()[0],getVertex61()[1],getVertex61()[2]);
    vertexlabelRoot.add( vertexLabel61 );
            
            	const sphereMaterial62 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere62 = new THREE.Mesh( sphereGeometry, sphereMaterial62 );
	vertexRoot.add(sphere62);
	sphere62.position.set(getVertex62()[0],getVertex62()[1],getVertex62()[2]);

    const lableDiv62 = document.createElement( 'div' );
    lableDiv62.className = 'label';
    lableDiv62.textContent = '62';
    lableDiv62.style.marginTop = '-1em';

    const vertexLabel62 = new CSS2DObject( lableDiv62 );
    vertexLabel62.position.set(getVertex62()[0],getVertex62()[1],getVertex62()[2]);
    vertexlabelRoot.add( vertexLabel62 );
            
            	const sphereMaterial63 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere63 = new THREE.Mesh( sphereGeometry, sphereMaterial63 );
	vertexRoot.add(sphere63);
	sphere63.position.set(getVertex63()[0],getVertex63()[1],getVertex63()[2]);

    const lableDiv63 = document.createElement( 'div' );
    lableDiv63.className = 'label';
    lableDiv63.textContent = '63';
    lableDiv63.style.marginTop = '-1em';

    const vertexLabel63 = new CSS2DObject( lableDiv63 );
    vertexLabel63.position.set(getVertex63()[0],getVertex63()[1],getVertex63()[2]);
    vertexlabelRoot.add( vertexLabel63 );
            
            	const sphereMaterial64 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere64 = new THREE.Mesh( sphereGeometry, sphereMaterial64 );
	vertexRoot.add(sphere64);
	sphere64.position.set(getVertex64()[0],getVertex64()[1],getVertex64()[2]);

    const lableDiv64 = document.createElement( 'div' );
    lableDiv64.className = 'label';
    lableDiv64.textContent = '64';
    lableDiv64.style.marginTop = '-1em';

    const vertexLabel64 = new CSS2DObject( lableDiv64 );
    vertexLabel64.position.set(getVertex64()[0],getVertex64()[1],getVertex64()[2]);
    vertexlabelRoot.add( vertexLabel64 );
            
            	const sphereMaterial65 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere65 = new THREE.Mesh( sphereGeometry, sphereMaterial65 );
	vertexRoot.add(sphere65);
	sphere65.position.set(getVertex65()[0],getVertex65()[1],getVertex65()[2]);

    const lableDiv65 = document.createElement( 'div' );
    lableDiv65.className = 'label';
    lableDiv65.textContent = '65';
    lableDiv65.style.marginTop = '-1em';

    const vertexLabel65 = new CSS2DObject( lableDiv65 );
    vertexLabel65.position.set(getVertex65()[0],getVertex65()[1],getVertex65()[2]);
    vertexlabelRoot.add( vertexLabel65 );
            
            	const sphereMaterial66 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere66 = new THREE.Mesh( sphereGeometry, sphereMaterial66 );
	vertexRoot.add(sphere66);
	sphere66.position.set(getVertex66()[0],getVertex66()[1],getVertex66()[2]);

    const lableDiv66 = document.createElement( 'div' );
    lableDiv66.className = 'label';
    lableDiv66.textContent = '66';
    lableDiv66.style.marginTop = '-1em';

    const vertexLabel66 = new CSS2DObject( lableDiv66 );
    vertexLabel66.position.set(getVertex66()[0],getVertex66()[1],getVertex66()[2]);
    vertexlabelRoot.add( vertexLabel66 );
            
            	const sphereMaterial67 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere67 = new THREE.Mesh( sphereGeometry, sphereMaterial67 );
	vertexRoot.add(sphere67);
	sphere67.position.set(getVertex67()[0],getVertex67()[1],getVertex67()[2]);

    const lableDiv67 = document.createElement( 'div' );
    lableDiv67.className = 'label';
    lableDiv67.textContent = '67';
    lableDiv67.style.marginTop = '-1em';

    const vertexLabel67 = new CSS2DObject( lableDiv67 );
    vertexLabel67.position.set(getVertex67()[0],getVertex67()[1],getVertex67()[2]);
    vertexlabelRoot.add( vertexLabel67 );
            
            	const sphereMaterial68 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere68 = new THREE.Mesh( sphereGeometry, sphereMaterial68 );
	vertexRoot.add(sphere68);
	sphere68.position.set(getVertex68()[0],getVertex68()[1],getVertex68()[2]);

    const lableDiv68 = document.createElement( 'div' );
    lableDiv68.className = 'label';
    lableDiv68.textContent = '68';
    lableDiv68.style.marginTop = '-1em';

    const vertexLabel68 = new CSS2DObject( lableDiv68 );
    vertexLabel68.position.set(getVertex68()[0],getVertex68()[1],getVertex68()[2]);
    vertexlabelRoot.add( vertexLabel68 );
            
            	const sphereMaterial69 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere69 = new THREE.Mesh( sphereGeometry, sphereMaterial69 );
	vertexRoot.add(sphere69);
	sphere69.position.set(getVertex69()[0],getVertex69()[1],getVertex69()[2]);

    const lableDiv69 = document.createElement( 'div' );
    lableDiv69.className = 'label';
    lableDiv69.textContent = '69';
    lableDiv69.style.marginTop = '-1em';

    const vertexLabel69 = new CSS2DObject( lableDiv69 );
    vertexLabel69.position.set(getVertex69()[0],getVertex69()[1],getVertex69()[2]);
    vertexlabelRoot.add( vertexLabel69 );
            
            	const sphereMaterial70 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere70 = new THREE.Mesh( sphereGeometry, sphereMaterial70 );
	vertexRoot.add(sphere70);
	sphere70.position.set(getVertex70()[0],getVertex70()[1],getVertex70()[2]);

    const lableDiv70 = document.createElement( 'div' );
    lableDiv70.className = 'label';
    lableDiv70.textContent = '70';
    lableDiv70.style.marginTop = '-1em';

    const vertexLabel70 = new CSS2DObject( lableDiv70 );
    vertexLabel70.position.set(getVertex70()[0],getVertex70()[1],getVertex70()[2]);
    vertexlabelRoot.add( vertexLabel70 );
            
            	const sphereMaterial71 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere71 = new THREE.Mesh( sphereGeometry, sphereMaterial71 );
	vertexRoot.add(sphere71);
	sphere71.position.set(getVertex71()[0],getVertex71()[1],getVertex71()[2]);

    const lableDiv71 = document.createElement( 'div' );
    lableDiv71.className = 'label';
    lableDiv71.textContent = '71';
    lableDiv71.style.marginTop = '-1em';

    const vertexLabel71 = new CSS2DObject( lableDiv71 );
    vertexLabel71.position.set(getVertex71()[0],getVertex71()[1],getVertex71()[2]);
    vertexlabelRoot.add( vertexLabel71 );
            
            	const sphereMaterial72 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere72 = new THREE.Mesh( sphereGeometry, sphereMaterial72 );
	vertexRoot.add(sphere72);
	sphere72.position.set(getVertex72()[0],getVertex72()[1],getVertex72()[2]);

    const lableDiv72 = document.createElement( 'div' );
    lableDiv72.className = 'label';
    lableDiv72.textContent = '72';
    lableDiv72.style.marginTop = '-1em';

    const vertexLabel72 = new CSS2DObject( lableDiv72 );
    vertexLabel72.position.set(getVertex72()[0],getVertex72()[1],getVertex72()[2]);
    vertexlabelRoot.add( vertexLabel72 );
            
            	const sphereMaterial73 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere73 = new THREE.Mesh( sphereGeometry, sphereMaterial73 );
	vertexRoot.add(sphere73);
	sphere73.position.set(getVertex73()[0],getVertex73()[1],getVertex73()[2]);

    const lableDiv73 = document.createElement( 'div' );
    lableDiv73.className = 'label';
    lableDiv73.textContent = '73';
    lableDiv73.style.marginTop = '-1em';

    const vertexLabel73 = new CSS2DObject( lableDiv73 );
    vertexLabel73.position.set(getVertex73()[0],getVertex73()[1],getVertex73()[2]);
    vertexlabelRoot.add( vertexLabel73 );
            
            	const sphereMaterial74 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere74 = new THREE.Mesh( sphereGeometry, sphereMaterial74 );
	vertexRoot.add(sphere74);
	sphere74.position.set(getVertex74()[0],getVertex74()[1],getVertex74()[2]);

    const lableDiv74 = document.createElement( 'div' );
    lableDiv74.className = 'label';
    lableDiv74.textContent = '74';
    lableDiv74.style.marginTop = '-1em';

    const vertexLabel74 = new CSS2DObject( lableDiv74 );
    vertexLabel74.position.set(getVertex74()[0],getVertex74()[1],getVertex74()[2]);
    vertexlabelRoot.add( vertexLabel74 );
            
            	const sphereMaterial75 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere75 = new THREE.Mesh( sphereGeometry, sphereMaterial75 );
	vertexRoot.add(sphere75);
	sphere75.position.set(getVertex75()[0],getVertex75()[1],getVertex75()[2]);

    const lableDiv75 = document.createElement( 'div' );
    lableDiv75.className = 'label';
    lableDiv75.textContent = '75';
    lableDiv75.style.marginTop = '-1em';

    const vertexLabel75 = new CSS2DObject( lableDiv75 );
    vertexLabel75.position.set(getVertex75()[0],getVertex75()[1],getVertex75()[2]);
    vertexlabelRoot.add( vertexLabel75 );
            
            	const sphereMaterial76 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere76 = new THREE.Mesh( sphereGeometry, sphereMaterial76 );
	vertexRoot.add(sphere76);
	sphere76.position.set(getVertex76()[0],getVertex76()[1],getVertex76()[2]);

    const lableDiv76 = document.createElement( 'div' );
    lableDiv76.className = 'label';
    lableDiv76.textContent = '76';
    lableDiv76.style.marginTop = '-1em';

    const vertexLabel76 = new CSS2DObject( lableDiv76 );
    vertexLabel76.position.set(getVertex76()[0],getVertex76()[1],getVertex76()[2]);
    vertexlabelRoot.add( vertexLabel76 );
            
            	const sphereMaterial77 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere77 = new THREE.Mesh( sphereGeometry, sphereMaterial77 );
	vertexRoot.add(sphere77);
	sphere77.position.set(getVertex77()[0],getVertex77()[1],getVertex77()[2]);

    const lableDiv77 = document.createElement( 'div' );
    lableDiv77.className = 'label';
    lableDiv77.textContent = '77';
    lableDiv77.style.marginTop = '-1em';

    const vertexLabel77 = new CSS2DObject( lableDiv77 );
    vertexLabel77.position.set(getVertex77()[0],getVertex77()[1],getVertex77()[2]);
    vertexlabelRoot.add( vertexLabel77 );
            
            	const sphereMaterial78 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere78 = new THREE.Mesh( sphereGeometry, sphereMaterial78 );
	vertexRoot.add(sphere78);
	sphere78.position.set(getVertex78()[0],getVertex78()[1],getVertex78()[2]);

    const lableDiv78 = document.createElement( 'div' );
    lableDiv78.className = 'label';
    lableDiv78.textContent = '78';
    lableDiv78.style.marginTop = '-1em';

    const vertexLabel78 = new CSS2DObject( lableDiv78 );
    vertexLabel78.position.set(getVertex78()[0],getVertex78()[1],getVertex78()[2]);
    vertexlabelRoot.add( vertexLabel78 );
            
            	const sphereMaterial79 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere79 = new THREE.Mesh( sphereGeometry, sphereMaterial79 );
	vertexRoot.add(sphere79);
	sphere79.position.set(getVertex79()[0],getVertex79()[1],getVertex79()[2]);

    const lableDiv79 = document.createElement( 'div' );
    lableDiv79.className = 'label';
    lableDiv79.textContent = '79';
    lableDiv79.style.marginTop = '-1em';

    const vertexLabel79 = new CSS2DObject( lableDiv79 );
    vertexLabel79.position.set(getVertex79()[0],getVertex79()[1],getVertex79()[2]);
    vertexlabelRoot.add( vertexLabel79 );
            
            	const sphereMaterial80 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere80 = new THREE.Mesh( sphereGeometry, sphereMaterial80 );
	vertexRoot.add(sphere80);
	sphere80.position.set(getVertex80()[0],getVertex80()[1],getVertex80()[2]);

    const lableDiv80 = document.createElement( 'div' );
    lableDiv80.className = 'label';
    lableDiv80.textContent = '80';
    lableDiv80.style.marginTop = '-1em';

    const vertexLabel80 = new CSS2DObject( lableDiv80 );
    vertexLabel80.position.set(getVertex80()[0],getVertex80()[1],getVertex80()[2]);
    vertexlabelRoot.add( vertexLabel80 );
            
            	const sphereMaterial81 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere81 = new THREE.Mesh( sphereGeometry, sphereMaterial81 );
	vertexRoot.add(sphere81);
	sphere81.position.set(getVertex81()[0],getVertex81()[1],getVertex81()[2]);

    const lableDiv81 = document.createElement( 'div' );
    lableDiv81.className = 'label';
    lableDiv81.textContent = '81';
    lableDiv81.style.marginTop = '-1em';

    const vertexLabel81 = new CSS2DObject( lableDiv81 );
    vertexLabel81.position.set(getVertex81()[0],getVertex81()[1],getVertex81()[2]);
    vertexlabelRoot.add( vertexLabel81 );
            
            	const sphereMaterial82 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere82 = new THREE.Mesh( sphereGeometry, sphereMaterial82 );
	vertexRoot.add(sphere82);
	sphere82.position.set(getVertex82()[0],getVertex82()[1],getVertex82()[2]);

    const lableDiv82 = document.createElement( 'div' );
    lableDiv82.className = 'label';
    lableDiv82.textContent = '82';
    lableDiv82.style.marginTop = '-1em';

    const vertexLabel82 = new CSS2DObject( lableDiv82 );
    vertexLabel82.position.set(getVertex82()[0],getVertex82()[1],getVertex82()[2]);
    vertexlabelRoot.add( vertexLabel82 );
            
            	const sphereMaterial83 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere83 = new THREE.Mesh( sphereGeometry, sphereMaterial83 );
	vertexRoot.add(sphere83);
	sphere83.position.set(getVertex83()[0],getVertex83()[1],getVertex83()[2]);

    const lableDiv83 = document.createElement( 'div' );
    lableDiv83.className = 'label';
    lableDiv83.textContent = '83';
    lableDiv83.style.marginTop = '-1em';

    const vertexLabel83 = new CSS2DObject( lableDiv83 );
    vertexLabel83.position.set(getVertex83()[0],getVertex83()[1],getVertex83()[2]);
    vertexlabelRoot.add( vertexLabel83 );
            
            	const sphereMaterial84 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere84 = new THREE.Mesh( sphereGeometry, sphereMaterial84 );
	vertexRoot.add(sphere84);
	sphere84.position.set(getVertex84()[0],getVertex84()[1],getVertex84()[2]);

    const lableDiv84 = document.createElement( 'div' );
    lableDiv84.className = 'label';
    lableDiv84.textContent = '84';
    lableDiv84.style.marginTop = '-1em';

    const vertexLabel84 = new CSS2DObject( lableDiv84 );
    vertexLabel84.position.set(getVertex84()[0],getVertex84()[1],getVertex84()[2]);
    vertexlabelRoot.add( vertexLabel84 );
            
            	const sphereMaterial85 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere85 = new THREE.Mesh( sphereGeometry, sphereMaterial85 );
	vertexRoot.add(sphere85);
	sphere85.position.set(getVertex85()[0],getVertex85()[1],getVertex85()[2]);

    const lableDiv85 = document.createElement( 'div' );
    lableDiv85.className = 'label';
    lableDiv85.textContent = '85';
    lableDiv85.style.marginTop = '-1em';

    const vertexLabel85 = new CSS2DObject( lableDiv85 );
    vertexLabel85.position.set(getVertex85()[0],getVertex85()[1],getVertex85()[2]);
    vertexlabelRoot.add( vertexLabel85 );
            
            	const sphereMaterial86 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere86 = new THREE.Mesh( sphereGeometry, sphereMaterial86 );
	vertexRoot.add(sphere86);
	sphere86.position.set(getVertex86()[0],getVertex86()[1],getVertex86()[2]);

    const lableDiv86 = document.createElement( 'div' );
    lableDiv86.className = 'label';
    lableDiv86.textContent = '86';
    lableDiv86.style.marginTop = '-1em';

    const vertexLabel86 = new CSS2DObject( lableDiv86 );
    vertexLabel86.position.set(getVertex86()[0],getVertex86()[1],getVertex86()[2]);
    vertexlabelRoot.add( vertexLabel86 );
            
            	const sphereMaterial87 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere87 = new THREE.Mesh( sphereGeometry, sphereMaterial87 );
	vertexRoot.add(sphere87);
	sphere87.position.set(getVertex87()[0],getVertex87()[1],getVertex87()[2]);

    const lableDiv87 = document.createElement( 'div' );
    lableDiv87.className = 'label';
    lableDiv87.textContent = '87';
    lableDiv87.style.marginTop = '-1em';

    const vertexLabel87 = new CSS2DObject( lableDiv87 );
    vertexLabel87.position.set(getVertex87()[0],getVertex87()[1],getVertex87()[2]);
    vertexlabelRoot.add( vertexLabel87 );
            
            	const sphereMaterial88 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere88 = new THREE.Mesh( sphereGeometry, sphereMaterial88 );
	vertexRoot.add(sphere88);
	sphere88.position.set(getVertex88()[0],getVertex88()[1],getVertex88()[2]);

    const lableDiv88 = document.createElement( 'div' );
    lableDiv88.className = 'label';
    lableDiv88.textContent = '88';
    lableDiv88.style.marginTop = '-1em';

    const vertexLabel88 = new CSS2DObject( lableDiv88 );
    vertexLabel88.position.set(getVertex88()[0],getVertex88()[1],getVertex88()[2]);
    vertexlabelRoot.add( vertexLabel88 );
            
            	const sphereMaterial89 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere89 = new THREE.Mesh( sphereGeometry, sphereMaterial89 );
	vertexRoot.add(sphere89);
	sphere89.position.set(getVertex89()[0],getVertex89()[1],getVertex89()[2]);

    const lableDiv89 = document.createElement( 'div' );
    lableDiv89.className = 'label';
    lableDiv89.textContent = '89';
    lableDiv89.style.marginTop = '-1em';

    const vertexLabel89 = new CSS2DObject( lableDiv89 );
    vertexLabel89.position.set(getVertex89()[0],getVertex89()[1],getVertex89()[2]);
    vertexlabelRoot.add( vertexLabel89 );
            
            	const sphereMaterial90 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere90 = new THREE.Mesh( sphereGeometry, sphereMaterial90 );
	vertexRoot.add(sphere90);
	sphere90.position.set(getVertex90()[0],getVertex90()[1],getVertex90()[2]);

    const lableDiv90 = document.createElement( 'div' );
    lableDiv90.className = 'label';
    lableDiv90.textContent = '90';
    lableDiv90.style.marginTop = '-1em';

    const vertexLabel90 = new CSS2DObject( lableDiv90 );
    vertexLabel90.position.set(getVertex90()[0],getVertex90()[1],getVertex90()[2]);
    vertexlabelRoot.add( vertexLabel90 );
            
            	const sphereMaterial91 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere91 = new THREE.Mesh( sphereGeometry, sphereMaterial91 );
	vertexRoot.add(sphere91);
	sphere91.position.set(getVertex91()[0],getVertex91()[1],getVertex91()[2]);

    const lableDiv91 = document.createElement( 'div' );
    lableDiv91.className = 'label';
    lableDiv91.textContent = '91';
    lableDiv91.style.marginTop = '-1em';

    const vertexLabel91 = new CSS2DObject( lableDiv91 );
    vertexLabel91.position.set(getVertex91()[0],getVertex91()[1],getVertex91()[2]);
    vertexlabelRoot.add( vertexLabel91 );
            
            	const sphereMaterial92 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere92 = new THREE.Mesh( sphereGeometry, sphereMaterial92 );
	vertexRoot.add(sphere92);
	sphere92.position.set(getVertex92()[0],getVertex92()[1],getVertex92()[2]);

    const lableDiv92 = document.createElement( 'div' );
    lableDiv92.className = 'label';
    lableDiv92.textContent = '92';
    lableDiv92.style.marginTop = '-1em';

    const vertexLabel92 = new CSS2DObject( lableDiv92 );
    vertexLabel92.position.set(getVertex92()[0],getVertex92()[1],getVertex92()[2]);
    vertexlabelRoot.add( vertexLabel92 );
            
            	const sphereMaterial93 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere93 = new THREE.Mesh( sphereGeometry, sphereMaterial93 );
	vertexRoot.add(sphere93);
	sphere93.position.set(getVertex93()[0],getVertex93()[1],getVertex93()[2]);

    const lableDiv93 = document.createElement( 'div' );
    lableDiv93.className = 'label';
    lableDiv93.textContent = '93';
    lableDiv93.style.marginTop = '-1em';

    const vertexLabel93 = new CSS2DObject( lableDiv93 );
    vertexLabel93.position.set(getVertex93()[0],getVertex93()[1],getVertex93()[2]);
    vertexlabelRoot.add( vertexLabel93 );
            
            	const sphereMaterial94 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere94 = new THREE.Mesh( sphereGeometry, sphereMaterial94 );
	vertexRoot.add(sphere94);
	sphere94.position.set(getVertex94()[0],getVertex94()[1],getVertex94()[2]);

    const lableDiv94 = document.createElement( 'div' );
    lableDiv94.className = 'label';
    lableDiv94.textContent = '94';
    lableDiv94.style.marginTop = '-1em';

    const vertexLabel94 = new CSS2DObject( lableDiv94 );
    vertexLabel94.position.set(getVertex94()[0],getVertex94()[1],getVertex94()[2]);
    vertexlabelRoot.add( vertexLabel94 );
            
            	const sphereMaterial95 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere95 = new THREE.Mesh( sphereGeometry, sphereMaterial95 );
	vertexRoot.add(sphere95);
	sphere95.position.set(getVertex95()[0],getVertex95()[1],getVertex95()[2]);

    const lableDiv95 = document.createElement( 'div' );
    lableDiv95.className = 'label';
    lableDiv95.textContent = '95';
    lableDiv95.style.marginTop = '-1em';

    const vertexLabel95 = new CSS2DObject( lableDiv95 );
    vertexLabel95.position.set(getVertex95()[0],getVertex95()[1],getVertex95()[2]);
    vertexlabelRoot.add( vertexLabel95 );
            
            	const sphereMaterial96 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere96 = new THREE.Mesh( sphereGeometry, sphereMaterial96 );
	vertexRoot.add(sphere96);
	sphere96.position.set(getVertex96()[0],getVertex96()[1],getVertex96()[2]);

    const lableDiv96 = document.createElement( 'div' );
    lableDiv96.className = 'label';
    lableDiv96.textContent = '96';
    lableDiv96.style.marginTop = '-1em';

    const vertexLabel96 = new CSS2DObject( lableDiv96 );
    vertexLabel96.position.set(getVertex96()[0],getVertex96()[1],getVertex96()[2]);
    vertexlabelRoot.add( vertexLabel96 );
            
            	const sphereMaterial97 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere97 = new THREE.Mesh( sphereGeometry, sphereMaterial97 );
	vertexRoot.add(sphere97);
	sphere97.position.set(getVertex97()[0],getVertex97()[1],getVertex97()[2]);

    const lableDiv97 = document.createElement( 'div' );
    lableDiv97.className = 'label';
    lableDiv97.textContent = '97';
    lableDiv97.style.marginTop = '-1em';

    const vertexLabel97 = new CSS2DObject( lableDiv97 );
    vertexLabel97.position.set(getVertex97()[0],getVertex97()[1],getVertex97()[2]);
    vertexlabelRoot.add( vertexLabel97 );
            
            	const sphereMaterial98 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere98 = new THREE.Mesh( sphereGeometry, sphereMaterial98 );
	vertexRoot.add(sphere98);
	sphere98.position.set(getVertex98()[0],getVertex98()[1],getVertex98()[2]);

    const lableDiv98 = document.createElement( 'div' );
    lableDiv98.className = 'label';
    lableDiv98.textContent = '98';
    lableDiv98.style.marginTop = '-1em';

    const vertexLabel98 = new CSS2DObject( lableDiv98 );
    vertexLabel98.position.set(getVertex98()[0],getVertex98()[1],getVertex98()[2]);
    vertexlabelRoot.add( vertexLabel98 );
            
            	const sphereMaterial99 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere99 = new THREE.Mesh( sphereGeometry, sphereMaterial99 );
	vertexRoot.add(sphere99);
	sphere99.position.set(getVertex99()[0],getVertex99()[1],getVertex99()[2]);

    const lableDiv99 = document.createElement( 'div' );
    lableDiv99.className = 'label';
    lableDiv99.textContent = '99';
    lableDiv99.style.marginTop = '-1em';

    const vertexLabel99 = new CSS2DObject( lableDiv99 );
    vertexLabel99.position.set(getVertex99()[0],getVertex99()[1],getVertex99()[2]);
    vertexlabelRoot.add( vertexLabel99 );
            
            	const sphereMaterial100 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere100 = new THREE.Mesh( sphereGeometry, sphereMaterial100 );
	vertexRoot.add(sphere100);
	sphere100.position.set(getVertex100()[0],getVertex100()[1],getVertex100()[2]);

    const lableDiv100 = document.createElement( 'div' );
    lableDiv100.className = 'label';
    lableDiv100.textContent = '100';
    lableDiv100.style.marginTop = '-1em';

    const vertexLabel100 = new CSS2DObject( lableDiv100 );
    vertexLabel100.position.set(getVertex100()[0],getVertex100()[1],getVertex100()[2]);
    vertexlabelRoot.add( vertexLabel100 );
            
            	const sphereMaterial101 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere101 = new THREE.Mesh( sphereGeometry, sphereMaterial101 );
	vertexRoot.add(sphere101);
	sphere101.position.set(getVertex101()[0],getVertex101()[1],getVertex101()[2]);

    const lableDiv101 = document.createElement( 'div' );
    lableDiv101.className = 'label';
    lableDiv101.textContent = '101';
    lableDiv101.style.marginTop = '-1em';

    const vertexLabel101 = new CSS2DObject( lableDiv101 );
    vertexLabel101.position.set(getVertex101()[0],getVertex101()[1],getVertex101()[2]);
    vertexlabelRoot.add( vertexLabel101 );
            
            	const sphereMaterial102 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere102 = new THREE.Mesh( sphereGeometry, sphereMaterial102 );
	vertexRoot.add(sphere102);
	sphere102.position.set(getVertex102()[0],getVertex102()[1],getVertex102()[2]);

    const lableDiv102 = document.createElement( 'div' );
    lableDiv102.className = 'label';
    lableDiv102.textContent = '102';
    lableDiv102.style.marginTop = '-1em';

    const vertexLabel102 = new CSS2DObject( lableDiv102 );
    vertexLabel102.position.set(getVertex102()[0],getVertex102()[1],getVertex102()[2]);
    vertexlabelRoot.add( vertexLabel102 );
            
            	const sphereMaterial103 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere103 = new THREE.Mesh( sphereGeometry, sphereMaterial103 );
	vertexRoot.add(sphere103);
	sphere103.position.set(getVertex103()[0],getVertex103()[1],getVertex103()[2]);

    const lableDiv103 = document.createElement( 'div' );
    lableDiv103.className = 'label';
    lableDiv103.textContent = '103';
    lableDiv103.style.marginTop = '-1em';

    const vertexLabel103 = new CSS2DObject( lableDiv103 );
    vertexLabel103.position.set(getVertex103()[0],getVertex103()[1],getVertex103()[2]);
    vertexlabelRoot.add( vertexLabel103 );
            
            	const sphereMaterial104 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere104 = new THREE.Mesh( sphereGeometry, sphereMaterial104 );
	vertexRoot.add(sphere104);
	sphere104.position.set(getVertex104()[0],getVertex104()[1],getVertex104()[2]);

    const lableDiv104 = document.createElement( 'div' );
    lableDiv104.className = 'label';
    lableDiv104.textContent = '104';
    lableDiv104.style.marginTop = '-1em';

    const vertexLabel104 = new CSS2DObject( lableDiv104 );
    vertexLabel104.position.set(getVertex104()[0],getVertex104()[1],getVertex104()[2]);
    vertexlabelRoot.add( vertexLabel104 );
            
            	const sphereMaterial105 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere105 = new THREE.Mesh( sphereGeometry, sphereMaterial105 );
	vertexRoot.add(sphere105);
	sphere105.position.set(getVertex105()[0],getVertex105()[1],getVertex105()[2]);

    const lableDiv105 = document.createElement( 'div' );
    lableDiv105.className = 'label';
    lableDiv105.textContent = '105';
    lableDiv105.style.marginTop = '-1em';

    const vertexLabel105 = new CSS2DObject( lableDiv105 );
    vertexLabel105.position.set(getVertex105()[0],getVertex105()[1],getVertex105()[2]);
    vertexlabelRoot.add( vertexLabel105 );
            
            	const sphereMaterial106 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere106 = new THREE.Mesh( sphereGeometry, sphereMaterial106 );
	vertexRoot.add(sphere106);
	sphere106.position.set(getVertex106()[0],getVertex106()[1],getVertex106()[2]);

    const lableDiv106 = document.createElement( 'div' );
    lableDiv106.className = 'label';
    lableDiv106.textContent = '106';
    lableDiv106.style.marginTop = '-1em';

    const vertexLabel106 = new CSS2DObject( lableDiv106 );
    vertexLabel106.position.set(getVertex106()[0],getVertex106()[1],getVertex106()[2]);
    vertexlabelRoot.add( vertexLabel106 );
            
            	const sphereMaterial107 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere107 = new THREE.Mesh( sphereGeometry, sphereMaterial107 );
	vertexRoot.add(sphere107);
	sphere107.position.set(getVertex107()[0],getVertex107()[1],getVertex107()[2]);

    const lableDiv107 = document.createElement( 'div' );
    lableDiv107.className = 'label';
    lableDiv107.textContent = '107';
    lableDiv107.style.marginTop = '-1em';

    const vertexLabel107 = new CSS2DObject( lableDiv107 );
    vertexLabel107.position.set(getVertex107()[0],getVertex107()[1],getVertex107()[2]);
    vertexlabelRoot.add( vertexLabel107 );
            
            	const sphereMaterial108 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere108 = new THREE.Mesh( sphereGeometry, sphereMaterial108 );
	vertexRoot.add(sphere108);
	sphere108.position.set(getVertex108()[0],getVertex108()[1],getVertex108()[2]);

    const lableDiv108 = document.createElement( 'div' );
    lableDiv108.className = 'label';
    lableDiv108.textContent = '108';
    lableDiv108.style.marginTop = '-1em';

    const vertexLabel108 = new CSS2DObject( lableDiv108 );
    vertexLabel108.position.set(getVertex108()[0],getVertex108()[1],getVertex108()[2]);
    vertexlabelRoot.add( vertexLabel108 );
            
            	const sphereMaterial109 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere109 = new THREE.Mesh( sphereGeometry, sphereMaterial109 );
	vertexRoot.add(sphere109);
	sphere109.position.set(getVertex109()[0],getVertex109()[1],getVertex109()[2]);

    const lableDiv109 = document.createElement( 'div' );
    lableDiv109.className = 'label';
    lableDiv109.textContent = '109';
    lableDiv109.style.marginTop = '-1em';

    const vertexLabel109 = new CSS2DObject( lableDiv109 );
    vertexLabel109.position.set(getVertex109()[0],getVertex109()[1],getVertex109()[2]);
    vertexlabelRoot.add( vertexLabel109 );
            
            	const sphereMaterial110 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere110 = new THREE.Mesh( sphereGeometry, sphereMaterial110 );
	vertexRoot.add(sphere110);
	sphere110.position.set(getVertex110()[0],getVertex110()[1],getVertex110()[2]);

    const lableDiv110 = document.createElement( 'div' );
    lableDiv110.className = 'label';
    lableDiv110.textContent = '110';
    lableDiv110.style.marginTop = '-1em';

    const vertexLabel110 = new CSS2DObject( lableDiv110 );
    vertexLabel110.position.set(getVertex110()[0],getVertex110()[1],getVertex110()[2]);
    vertexlabelRoot.add( vertexLabel110 );
            
            	const sphereMaterial111 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere111 = new THREE.Mesh( sphereGeometry, sphereMaterial111 );
	vertexRoot.add(sphere111);
	sphere111.position.set(getVertex111()[0],getVertex111()[1],getVertex111()[2]);

    const lableDiv111 = document.createElement( 'div' );
    lableDiv111.className = 'label';
    lableDiv111.textContent = '111';
    lableDiv111.style.marginTop = '-1em';

    const vertexLabel111 = new CSS2DObject( lableDiv111 );
    vertexLabel111.position.set(getVertex111()[0],getVertex111()[1],getVertex111()[2]);
    vertexlabelRoot.add( vertexLabel111 );
            
            	const sphereMaterial112 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere112 = new THREE.Mesh( sphereGeometry, sphereMaterial112 );
	vertexRoot.add(sphere112);
	sphere112.position.set(getVertex112()[0],getVertex112()[1],getVertex112()[2]);

    const lableDiv112 = document.createElement( 'div' );
    lableDiv112.className = 'label';
    lableDiv112.textContent = '112';
    lableDiv112.style.marginTop = '-1em';

    const vertexLabel112 = new CSS2DObject( lableDiv112 );
    vertexLabel112.position.set(getVertex112()[0],getVertex112()[1],getVertex112()[2]);
    vertexlabelRoot.add( vertexLabel112 );
            
            	const sphereMaterial113 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere113 = new THREE.Mesh( sphereGeometry, sphereMaterial113 );
	vertexRoot.add(sphere113);
	sphere113.position.set(getVertex113()[0],getVertex113()[1],getVertex113()[2]);

    const lableDiv113 = document.createElement( 'div' );
    lableDiv113.className = 'label';
    lableDiv113.textContent = '113';
    lableDiv113.style.marginTop = '-1em';

    const vertexLabel113 = new CSS2DObject( lableDiv113 );
    vertexLabel113.position.set(getVertex113()[0],getVertex113()[1],getVertex113()[2]);
    vertexlabelRoot.add( vertexLabel113 );
            
            	const sphereMaterial114 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere114 = new THREE.Mesh( sphereGeometry, sphereMaterial114 );
	vertexRoot.add(sphere114);
	sphere114.position.set(getVertex114()[0],getVertex114()[1],getVertex114()[2]);

    const lableDiv114 = document.createElement( 'div' );
    lableDiv114.className = 'label';
    lableDiv114.textContent = '114';
    lableDiv114.style.marginTop = '-1em';

    const vertexLabel114 = new CSS2DObject( lableDiv114 );
    vertexLabel114.position.set(getVertex114()[0],getVertex114()[1],getVertex114()[2]);
    vertexlabelRoot.add( vertexLabel114 );
            
            	const sphereMaterial115 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere115 = new THREE.Mesh( sphereGeometry, sphereMaterial115 );
	vertexRoot.add(sphere115);
	sphere115.position.set(getVertex115()[0],getVertex115()[1],getVertex115()[2]);

    const lableDiv115 = document.createElement( 'div' );
    lableDiv115.className = 'label';
    lableDiv115.textContent = '115';
    lableDiv115.style.marginTop = '-1em';

    const vertexLabel115 = new CSS2DObject( lableDiv115 );
    vertexLabel115.position.set(getVertex115()[0],getVertex115()[1],getVertex115()[2]);
    vertexlabelRoot.add( vertexLabel115 );
            
            	const sphereMaterial116 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere116 = new THREE.Mesh( sphereGeometry, sphereMaterial116 );
	vertexRoot.add(sphere116);
	sphere116.position.set(getVertex116()[0],getVertex116()[1],getVertex116()[2]);

    const lableDiv116 = document.createElement( 'div' );
    lableDiv116.className = 'label';
    lableDiv116.textContent = '116';
    lableDiv116.style.marginTop = '-1em';

    const vertexLabel116 = new CSS2DObject( lableDiv116 );
    vertexLabel116.position.set(getVertex116()[0],getVertex116()[1],getVertex116()[2]);
    vertexlabelRoot.add( vertexLabel116 );
            
            	const sphereMaterial117 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere117 = new THREE.Mesh( sphereGeometry, sphereMaterial117 );
	vertexRoot.add(sphere117);
	sphere117.position.set(getVertex117()[0],getVertex117()[1],getVertex117()[2]);

    const lableDiv117 = document.createElement( 'div' );
    lableDiv117.className = 'label';
    lableDiv117.textContent = '117';
    lableDiv117.style.marginTop = '-1em';

    const vertexLabel117 = new CSS2DObject( lableDiv117 );
    vertexLabel117.position.set(getVertex117()[0],getVertex117()[1],getVertex117()[2]);
    vertexlabelRoot.add( vertexLabel117 );
            
            	const sphereMaterial118 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere118 = new THREE.Mesh( sphereGeometry, sphereMaterial118 );
	vertexRoot.add(sphere118);
	sphere118.position.set(getVertex118()[0],getVertex118()[1],getVertex118()[2]);

    const lableDiv118 = document.createElement( 'div' );
    lableDiv118.className = 'label';
    lableDiv118.textContent = '118';
    lableDiv118.style.marginTop = '-1em';

    const vertexLabel118 = new CSS2DObject( lableDiv118 );
    vertexLabel118.position.set(getVertex118()[0],getVertex118()[1],getVertex118()[2]);
    vertexlabelRoot.add( vertexLabel118 );
            
            	const sphereMaterial119 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere119 = new THREE.Mesh( sphereGeometry, sphereMaterial119 );
	vertexRoot.add(sphere119);
	sphere119.position.set(getVertex119()[0],getVertex119()[1],getVertex119()[2]);

    const lableDiv119 = document.createElement( 'div' );
    lableDiv119.className = 'label';
    lableDiv119.textContent = '119';
    lableDiv119.style.marginTop = '-1em';

    const vertexLabel119 = new CSS2DObject( lableDiv119 );
    vertexLabel119.position.set(getVertex119()[0],getVertex119()[1],getVertex119()[2]);
    vertexlabelRoot.add( vertexLabel119 );
            
            	const sphereMaterial120 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere120 = new THREE.Mesh( sphereGeometry, sphereMaterial120 );
	vertexRoot.add(sphere120);
	sphere120.position.set(getVertex120()[0],getVertex120()[1],getVertex120()[2]);

    const lableDiv120 = document.createElement( 'div' );
    lableDiv120.className = 'label';
    lableDiv120.textContent = '120';
    lableDiv120.style.marginTop = '-1em';

    const vertexLabel120 = new CSS2DObject( lableDiv120 );
    vertexLabel120.position.set(getVertex120()[0],getVertex120()[1],getVertex120()[2]);
    vertexlabelRoot.add( vertexLabel120 );
            
            	const sphereMaterial121 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere121 = new THREE.Mesh( sphereGeometry, sphereMaterial121 );
	vertexRoot.add(sphere121);
	sphere121.position.set(getVertex121()[0],getVertex121()[1],getVertex121()[2]);

    const lableDiv121 = document.createElement( 'div' );
    lableDiv121.className = 'label';
    lableDiv121.textContent = '121';
    lableDiv121.style.marginTop = '-1em';

    const vertexLabel121 = new CSS2DObject( lableDiv121 );
    vertexLabel121.position.set(getVertex121()[0],getVertex121()[1],getVertex121()[2]);
    vertexlabelRoot.add( vertexLabel121 );
            
            	const sphereMaterial122 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere122 = new THREE.Mesh( sphereGeometry, sphereMaterial122 );
	vertexRoot.add(sphere122);
	sphere122.position.set(getVertex122()[0],getVertex122()[1],getVertex122()[2]);

    const lableDiv122 = document.createElement( 'div' );
    lableDiv122.className = 'label';
    lableDiv122.textContent = '122';
    lableDiv122.style.marginTop = '-1em';

    const vertexLabel122 = new CSS2DObject( lableDiv122 );
    vertexLabel122.position.set(getVertex122()[0],getVertex122()[1],getVertex122()[2]);
    vertexlabelRoot.add( vertexLabel122 );
            
            	const sphereMaterial123 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere123 = new THREE.Mesh( sphereGeometry, sphereMaterial123 );
	vertexRoot.add(sphere123);
	sphere123.position.set(getVertex123()[0],getVertex123()[1],getVertex123()[2]);

    const lableDiv123 = document.createElement( 'div' );
    lableDiv123.className = 'label';
    lableDiv123.textContent = '123';
    lableDiv123.style.marginTop = '-1em';

    const vertexLabel123 = new CSS2DObject( lableDiv123 );
    vertexLabel123.position.set(getVertex123()[0],getVertex123()[1],getVertex123()[2]);
    vertexlabelRoot.add( vertexLabel123 );
            
            	const sphereMaterial124 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere124 = new THREE.Mesh( sphereGeometry, sphereMaterial124 );
	vertexRoot.add(sphere124);
	sphere124.position.set(getVertex124()[0],getVertex124()[1],getVertex124()[2]);

    const lableDiv124 = document.createElement( 'div' );
    lableDiv124.className = 'label';
    lableDiv124.textContent = '124';
    lableDiv124.style.marginTop = '-1em';

    const vertexLabel124 = new CSS2DObject( lableDiv124 );
    vertexLabel124.position.set(getVertex124()[0],getVertex124()[1],getVertex124()[2]);
    vertexlabelRoot.add( vertexLabel124 );
            
            	const sphereMaterial125 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere125 = new THREE.Mesh( sphereGeometry, sphereMaterial125 );
	vertexRoot.add(sphere125);
	sphere125.position.set(getVertex125()[0],getVertex125()[1],getVertex125()[2]);

    const lableDiv125 = document.createElement( 'div' );
    lableDiv125.className = 'label';
    lableDiv125.textContent = '125';
    lableDiv125.style.marginTop = '-1em';

    const vertexLabel125 = new CSS2DObject( lableDiv125 );
    vertexLabel125.position.set(getVertex125()[0],getVertex125()[1],getVertex125()[2]);
    vertexlabelRoot.add( vertexLabel125 );
            
            	const sphereMaterial126 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere126 = new THREE.Mesh( sphereGeometry, sphereMaterial126 );
	vertexRoot.add(sphere126);
	sphere126.position.set(getVertex126()[0],getVertex126()[1],getVertex126()[2]);

    const lableDiv126 = document.createElement( 'div' );
    lableDiv126.className = 'label';
    lableDiv126.textContent = '126';
    lableDiv126.style.marginTop = '-1em';

    const vertexLabel126 = new CSS2DObject( lableDiv126 );
    vertexLabel126.position.set(getVertex126()[0],getVertex126()[1],getVertex126()[2]);
    vertexlabelRoot.add( vertexLabel126 );
            
            	const sphereMaterial127 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere127 = new THREE.Mesh( sphereGeometry, sphereMaterial127 );
	vertexRoot.add(sphere127);
	sphere127.position.set(getVertex127()[0],getVertex127()[1],getVertex127()[2]);

    const lableDiv127 = document.createElement( 'div' );
    lableDiv127.className = 'label';
    lableDiv127.textContent = '127';
    lableDiv127.style.marginTop = '-1em';

    const vertexLabel127 = new CSS2DObject( lableDiv127 );
    vertexLabel127.position.set(getVertex127()[0],getVertex127()[1],getVertex127()[2]);
    vertexlabelRoot.add( vertexLabel127 );
            
            	const sphereMaterial128 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere128 = new THREE.Mesh( sphereGeometry, sphereMaterial128 );
	vertexRoot.add(sphere128);
	sphere128.position.set(getVertex128()[0],getVertex128()[1],getVertex128()[2]);

    const lableDiv128 = document.createElement( 'div' );
    lableDiv128.className = 'label';
    lableDiv128.textContent = '128';
    lableDiv128.style.marginTop = '-1em';

    const vertexLabel128 = new CSS2DObject( lableDiv128 );
    vertexLabel128.position.set(getVertex128()[0],getVertex128()[1],getVertex128()[2]);
    vertexlabelRoot.add( vertexLabel128 );
            
            	const sphereMaterial129 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere129 = new THREE.Mesh( sphereGeometry, sphereMaterial129 );
	vertexRoot.add(sphere129);
	sphere129.position.set(getVertex129()[0],getVertex129()[1],getVertex129()[2]);

    const lableDiv129 = document.createElement( 'div' );
    lableDiv129.className = 'label';
    lableDiv129.textContent = '129';
    lableDiv129.style.marginTop = '-1em';

    const vertexLabel129 = new CSS2DObject( lableDiv129 );
    vertexLabel129.position.set(getVertex129()[0],getVertex129()[1],getVertex129()[2]);
    vertexlabelRoot.add( vertexLabel129 );
            
            	const sphereMaterial130 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere130 = new THREE.Mesh( sphereGeometry, sphereMaterial130 );
	vertexRoot.add(sphere130);
	sphere130.position.set(getVertex130()[0],getVertex130()[1],getVertex130()[2]);

    const lableDiv130 = document.createElement( 'div' );
    lableDiv130.className = 'label';
    lableDiv130.textContent = '130';
    lableDiv130.style.marginTop = '-1em';

    const vertexLabel130 = new CSS2DObject( lableDiv130 );
    vertexLabel130.position.set(getVertex130()[0],getVertex130()[1],getVertex130()[2]);
    vertexlabelRoot.add( vertexLabel130 );
            
            	const sphereMaterial131 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere131 = new THREE.Mesh( sphereGeometry, sphereMaterial131 );
	vertexRoot.add(sphere131);
	sphere131.position.set(getVertex131()[0],getVertex131()[1],getVertex131()[2]);

    const lableDiv131 = document.createElement( 'div' );
    lableDiv131.className = 'label';
    lableDiv131.textContent = '131';
    lableDiv131.style.marginTop = '-1em';

    const vertexLabel131 = new CSS2DObject( lableDiv131 );
    vertexLabel131.position.set(getVertex131()[0],getVertex131()[1],getVertex131()[2]);
    vertexlabelRoot.add( vertexLabel131 );
            
            	const sphereMaterial132 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere132 = new THREE.Mesh( sphereGeometry, sphereMaterial132 );
	vertexRoot.add(sphere132);
	sphere132.position.set(getVertex132()[0],getVertex132()[1],getVertex132()[2]);

    const lableDiv132 = document.createElement( 'div' );
    lableDiv132.className = 'label';
    lableDiv132.textContent = '132';
    lableDiv132.style.marginTop = '-1em';

    const vertexLabel132 = new CSS2DObject( lableDiv132 );
    vertexLabel132.position.set(getVertex132()[0],getVertex132()[1],getVertex132()[2]);
    vertexlabelRoot.add( vertexLabel132 );
            
            	const sphereMaterial133 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere133 = new THREE.Mesh( sphereGeometry, sphereMaterial133 );
	vertexRoot.add(sphere133);
	sphere133.position.set(getVertex133()[0],getVertex133()[1],getVertex133()[2]);

    const lableDiv133 = document.createElement( 'div' );
    lableDiv133.className = 'label';
    lableDiv133.textContent = '133';
    lableDiv133.style.marginTop = '-1em';

    const vertexLabel133 = new CSS2DObject( lableDiv133 );
    vertexLabel133.position.set(getVertex133()[0],getVertex133()[1],getVertex133()[2]);
    vertexlabelRoot.add( vertexLabel133 );
            
            	const sphereMaterial134 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere134 = new THREE.Mesh( sphereGeometry, sphereMaterial134 );
	vertexRoot.add(sphere134);
	sphere134.position.set(getVertex134()[0],getVertex134()[1],getVertex134()[2]);

    const lableDiv134 = document.createElement( 'div' );
    lableDiv134.className = 'label';
    lableDiv134.textContent = '134';
    lableDiv134.style.marginTop = '-1em';

    const vertexLabel134 = new CSS2DObject( lableDiv134 );
    vertexLabel134.position.set(getVertex134()[0],getVertex134()[1],getVertex134()[2]);
    vertexlabelRoot.add( vertexLabel134 );
            
            	const sphereMaterial135 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere135 = new THREE.Mesh( sphereGeometry, sphereMaterial135 );
	vertexRoot.add(sphere135);
	sphere135.position.set(getVertex135()[0],getVertex135()[1],getVertex135()[2]);

    const lableDiv135 = document.createElement( 'div' );
    lableDiv135.className = 'label';
    lableDiv135.textContent = '135';
    lableDiv135.style.marginTop = '-1em';

    const vertexLabel135 = new CSS2DObject( lableDiv135 );
    vertexLabel135.position.set(getVertex135()[0],getVertex135()[1],getVertex135()[2]);
    vertexlabelRoot.add( vertexLabel135 );
            
            	const sphereMaterial136 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere136 = new THREE.Mesh( sphereGeometry, sphereMaterial136 );
	vertexRoot.add(sphere136);
	sphere136.position.set(getVertex136()[0],getVertex136()[1],getVertex136()[2]);

    const lableDiv136 = document.createElement( 'div' );
    lableDiv136.className = 'label';
    lableDiv136.textContent = '136';
    lableDiv136.style.marginTop = '-1em';

    const vertexLabel136 = new CSS2DObject( lableDiv136 );
    vertexLabel136.position.set(getVertex136()[0],getVertex136()[1],getVertex136()[2]);
    vertexlabelRoot.add( vertexLabel136 );
            
            	const sphereMaterial137 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere137 = new THREE.Mesh( sphereGeometry, sphereMaterial137 );
	vertexRoot.add(sphere137);
	sphere137.position.set(getVertex137()[0],getVertex137()[1],getVertex137()[2]);

    const lableDiv137 = document.createElement( 'div' );
    lableDiv137.className = 'label';
    lableDiv137.textContent = '137';
    lableDiv137.style.marginTop = '-1em';

    const vertexLabel137 = new CSS2DObject( lableDiv137 );
    vertexLabel137.position.set(getVertex137()[0],getVertex137()[1],getVertex137()[2]);
    vertexlabelRoot.add( vertexLabel137 );
            
            	const sphereMaterial138 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere138 = new THREE.Mesh( sphereGeometry, sphereMaterial138 );
	vertexRoot.add(sphere138);
	sphere138.position.set(getVertex138()[0],getVertex138()[1],getVertex138()[2]);

    const lableDiv138 = document.createElement( 'div' );
    lableDiv138.className = 'label';
    lableDiv138.textContent = '138';
    lableDiv138.style.marginTop = '-1em';

    const vertexLabel138 = new CSS2DObject( lableDiv138 );
    vertexLabel138.position.set(getVertex138()[0],getVertex138()[1],getVertex138()[2]);
    vertexlabelRoot.add( vertexLabel138 );
            
            	const sphereMaterial139 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere139 = new THREE.Mesh( sphereGeometry, sphereMaterial139 );
	vertexRoot.add(sphere139);
	sphere139.position.set(getVertex139()[0],getVertex139()[1],getVertex139()[2]);

    const lableDiv139 = document.createElement( 'div' );
    lableDiv139.className = 'label';
    lableDiv139.textContent = '139';
    lableDiv139.style.marginTop = '-1em';

    const vertexLabel139 = new CSS2DObject( lableDiv139 );
    vertexLabel139.position.set(getVertex139()[0],getVertex139()[1],getVertex139()[2]);
    vertexlabelRoot.add( vertexLabel139 );
            
            	const sphereMaterial140 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere140 = new THREE.Mesh( sphereGeometry, sphereMaterial140 );
	vertexRoot.add(sphere140);
	sphere140.position.set(getVertex140()[0],getVertex140()[1],getVertex140()[2]);

    const lableDiv140 = document.createElement( 'div' );
    lableDiv140.className = 'label';
    lableDiv140.textContent = '140';
    lableDiv140.style.marginTop = '-1em';

    const vertexLabel140 = new CSS2DObject( lableDiv140 );
    vertexLabel140.position.set(getVertex140()[0],getVertex140()[1],getVertex140()[2]);
    vertexlabelRoot.add( vertexLabel140 );
            
            	const sphereMaterial141 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere141 = new THREE.Mesh( sphereGeometry, sphereMaterial141 );
	vertexRoot.add(sphere141);
	sphere141.position.set(getVertex141()[0],getVertex141()[1],getVertex141()[2]);

    const lableDiv141 = document.createElement( 'div' );
    lableDiv141.className = 'label';
    lableDiv141.textContent = '141';
    lableDiv141.style.marginTop = '-1em';

    const vertexLabel141 = new CSS2DObject( lableDiv141 );
    vertexLabel141.position.set(getVertex141()[0],getVertex141()[1],getVertex141()[2]);
    vertexlabelRoot.add( vertexLabel141 );
            
            	const sphereMaterial142 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere142 = new THREE.Mesh( sphereGeometry, sphereMaterial142 );
	vertexRoot.add(sphere142);
	sphere142.position.set(getVertex142()[0],getVertex142()[1],getVertex142()[2]);

    const lableDiv142 = document.createElement( 'div' );
    lableDiv142.className = 'label';
    lableDiv142.textContent = '142';
    lableDiv142.style.marginTop = '-1em';

    const vertexLabel142 = new CSS2DObject( lableDiv142 );
    vertexLabel142.position.set(getVertex142()[0],getVertex142()[1],getVertex142()[2]);
    vertexlabelRoot.add( vertexLabel142 );
            
            	const sphereMaterial143 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere143 = new THREE.Mesh( sphereGeometry, sphereMaterial143 );
	vertexRoot.add(sphere143);
	sphere143.position.set(getVertex143()[0],getVertex143()[1],getVertex143()[2]);

    const lableDiv143 = document.createElement( 'div' );
    lableDiv143.className = 'label';
    lableDiv143.textContent = '143';
    lableDiv143.style.marginTop = '-1em';

    const vertexLabel143 = new CSS2DObject( lableDiv143 );
    vertexLabel143.position.set(getVertex143()[0],getVertex143()[1],getVertex143()[2]);
    vertexlabelRoot.add( vertexLabel143 );
            
            	const sphereMaterial144 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere144 = new THREE.Mesh( sphereGeometry, sphereMaterial144 );
	vertexRoot.add(sphere144);
	sphere144.position.set(getVertex144()[0],getVertex144()[1],getVertex144()[2]);

    const lableDiv144 = document.createElement( 'div' );
    lableDiv144.className = 'label';
    lableDiv144.textContent = '144';
    lableDiv144.style.marginTop = '-1em';

    const vertexLabel144 = new CSS2DObject( lableDiv144 );
    vertexLabel144.position.set(getVertex144()[0],getVertex144()[1],getVertex144()[2]);
    vertexlabelRoot.add( vertexLabel144 );
            
            	const sphereMaterial145 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere145 = new THREE.Mesh( sphereGeometry, sphereMaterial145 );
	vertexRoot.add(sphere145);
	sphere145.position.set(getVertex145()[0],getVertex145()[1],getVertex145()[2]);

    const lableDiv145 = document.createElement( 'div' );
    lableDiv145.className = 'label';
    lableDiv145.textContent = '145';
    lableDiv145.style.marginTop = '-1em';

    const vertexLabel145 = new CSS2DObject( lableDiv145 );
    vertexLabel145.position.set(getVertex145()[0],getVertex145()[1],getVertex145()[2]);
    vertexlabelRoot.add( vertexLabel145 );
            
            	const sphereMaterial146 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere146 = new THREE.Mesh( sphereGeometry, sphereMaterial146 );
	vertexRoot.add(sphere146);
	sphere146.position.set(getVertex146()[0],getVertex146()[1],getVertex146()[2]);

    const lableDiv146 = document.createElement( 'div' );
    lableDiv146.className = 'label';
    lableDiv146.textContent = '146';
    lableDiv146.style.marginTop = '-1em';

    const vertexLabel146 = new CSS2DObject( lableDiv146 );
    vertexLabel146.position.set(getVertex146()[0],getVertex146()[1],getVertex146()[2]);
    vertexlabelRoot.add( vertexLabel146 );
            
            	const sphereMaterial147 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere147 = new THREE.Mesh( sphereGeometry, sphereMaterial147 );
	vertexRoot.add(sphere147);
	sphere147.position.set(getVertex147()[0],getVertex147()[1],getVertex147()[2]);

    const lableDiv147 = document.createElement( 'div' );
    lableDiv147.className = 'label';
    lableDiv147.textContent = '147';
    lableDiv147.style.marginTop = '-1em';

    const vertexLabel147 = new CSS2DObject( lableDiv147 );
    vertexLabel147.position.set(getVertex147()[0],getVertex147()[1],getVertex147()[2]);
    vertexlabelRoot.add( vertexLabel147 );
            
            	const sphereMaterial148 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere148 = new THREE.Mesh( sphereGeometry, sphereMaterial148 );
	vertexRoot.add(sphere148);
	sphere148.position.set(getVertex148()[0],getVertex148()[1],getVertex148()[2]);

    const lableDiv148 = document.createElement( 'div' );
    lableDiv148.className = 'label';
    lableDiv148.textContent = '148';
    lableDiv148.style.marginTop = '-1em';

    const vertexLabel148 = new CSS2DObject( lableDiv148 );
    vertexLabel148.position.set(getVertex148()[0],getVertex148()[1],getVertex148()[2]);
    vertexlabelRoot.add( vertexLabel148 );
            
            	const sphereMaterial149 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere149 = new THREE.Mesh( sphereGeometry, sphereMaterial149 );
	vertexRoot.add(sphere149);
	sphere149.position.set(getVertex149()[0],getVertex149()[1],getVertex149()[2]);

    const lableDiv149 = document.createElement( 'div' );
    lableDiv149.className = 'label';
    lableDiv149.textContent = '149';
    lableDiv149.style.marginTop = '-1em';

    const vertexLabel149 = new CSS2DObject( lableDiv149 );
    vertexLabel149.position.set(getVertex149()[0],getVertex149()[1],getVertex149()[2]);
    vertexlabelRoot.add( vertexLabel149 );
            
            	const sphereMaterial150 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere150 = new THREE.Mesh( sphereGeometry, sphereMaterial150 );
	vertexRoot.add(sphere150);
	sphere150.position.set(getVertex150()[0],getVertex150()[1],getVertex150()[2]);

    const lableDiv150 = document.createElement( 'div' );
    lableDiv150.className = 'label';
    lableDiv150.textContent = '150';
    lableDiv150.style.marginTop = '-1em';

    const vertexLabel150 = new CSS2DObject( lableDiv150 );
    vertexLabel150.position.set(getVertex150()[0],getVertex150()[1],getVertex150()[2]);
    vertexlabelRoot.add( vertexLabel150 );
            
            	const sphereMaterial151 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere151 = new THREE.Mesh( sphereGeometry, sphereMaterial151 );
	vertexRoot.add(sphere151);
	sphere151.position.set(getVertex151()[0],getVertex151()[1],getVertex151()[2]);

    const lableDiv151 = document.createElement( 'div' );
    lableDiv151.className = 'label';
    lableDiv151.textContent = '151';
    lableDiv151.style.marginTop = '-1em';

    const vertexLabel151 = new CSS2DObject( lableDiv151 );
    vertexLabel151.position.set(getVertex151()[0],getVertex151()[1],getVertex151()[2]);
    vertexlabelRoot.add( vertexLabel151 );
            
            	const sphereMaterial152 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere152 = new THREE.Mesh( sphereGeometry, sphereMaterial152 );
	vertexRoot.add(sphere152);
	sphere152.position.set(getVertex152()[0],getVertex152()[1],getVertex152()[2]);

    const lableDiv152 = document.createElement( 'div' );
    lableDiv152.className = 'label';
    lableDiv152.textContent = '152';
    lableDiv152.style.marginTop = '-1em';

    const vertexLabel152 = new CSS2DObject( lableDiv152 );
    vertexLabel152.position.set(getVertex152()[0],getVertex152()[1],getVertex152()[2]);
    vertexlabelRoot.add( vertexLabel152 );
            
            	const sphereMaterial153 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere153 = new THREE.Mesh( sphereGeometry, sphereMaterial153 );
	vertexRoot.add(sphere153);
	sphere153.position.set(getVertex153()[0],getVertex153()[1],getVertex153()[2]);

    const lableDiv153 = document.createElement( 'div' );
    lableDiv153.className = 'label';
    lableDiv153.textContent = '153';
    lableDiv153.style.marginTop = '-1em';

    const vertexLabel153 = new CSS2DObject( lableDiv153 );
    vertexLabel153.position.set(getVertex153()[0],getVertex153()[1],getVertex153()[2]);
    vertexlabelRoot.add( vertexLabel153 );
            
            	const sphereMaterial154 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere154 = new THREE.Mesh( sphereGeometry, sphereMaterial154 );
	vertexRoot.add(sphere154);
	sphere154.position.set(getVertex154()[0],getVertex154()[1],getVertex154()[2]);

    const lableDiv154 = document.createElement( 'div' );
    lableDiv154.className = 'label';
    lableDiv154.textContent = '154';
    lableDiv154.style.marginTop = '-1em';

    const vertexLabel154 = new CSS2DObject( lableDiv154 );
    vertexLabel154.position.set(getVertex154()[0],getVertex154()[1],getVertex154()[2]);
    vertexlabelRoot.add( vertexLabel154 );
            
            	const sphereMaterial155 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere155 = new THREE.Mesh( sphereGeometry, sphereMaterial155 );
	vertexRoot.add(sphere155);
	sphere155.position.set(getVertex155()[0],getVertex155()[1],getVertex155()[2]);

    const lableDiv155 = document.createElement( 'div' );
    lableDiv155.className = 'label';
    lableDiv155.textContent = '155';
    lableDiv155.style.marginTop = '-1em';

    const vertexLabel155 = new CSS2DObject( lableDiv155 );
    vertexLabel155.position.set(getVertex155()[0],getVertex155()[1],getVertex155()[2]);
    vertexlabelRoot.add( vertexLabel155 );
            
            	const sphereMaterial156 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere156 = new THREE.Mesh( sphereGeometry, sphereMaterial156 );
	vertexRoot.add(sphere156);
	sphere156.position.set(getVertex156()[0],getVertex156()[1],getVertex156()[2]);

    const lableDiv156 = document.createElement( 'div' );
    lableDiv156.className = 'label';
    lableDiv156.textContent = '156';
    lableDiv156.style.marginTop = '-1em';

    const vertexLabel156 = new CSS2DObject( lableDiv156 );
    vertexLabel156.position.set(getVertex156()[0],getVertex156()[1],getVertex156()[2]);
    vertexlabelRoot.add( vertexLabel156 );
            
            	const sphereMaterial157 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere157 = new THREE.Mesh( sphereGeometry, sphereMaterial157 );
	vertexRoot.add(sphere157);
	sphere157.position.set(getVertex157()[0],getVertex157()[1],getVertex157()[2]);

    const lableDiv157 = document.createElement( 'div' );
    lableDiv157.className = 'label';
    lableDiv157.textContent = '157';
    lableDiv157.style.marginTop = '-1em';

    const vertexLabel157 = new CSS2DObject( lableDiv157 );
    vertexLabel157.position.set(getVertex157()[0],getVertex157()[1],getVertex157()[2]);
    vertexlabelRoot.add( vertexLabel157 );
            
            	const sphereMaterial158 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere158 = new THREE.Mesh( sphereGeometry, sphereMaterial158 );
	vertexRoot.add(sphere158);
	sphere158.position.set(getVertex158()[0],getVertex158()[1],getVertex158()[2]);

    const lableDiv158 = document.createElement( 'div' );
    lableDiv158.className = 'label';
    lableDiv158.textContent = '158';
    lableDiv158.style.marginTop = '-1em';

    const vertexLabel158 = new CSS2DObject( lableDiv158 );
    vertexLabel158.position.set(getVertex158()[0],getVertex158()[1],getVertex158()[2]);
    vertexlabelRoot.add( vertexLabel158 );
            
            	const sphereMaterial159 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere159 = new THREE.Mesh( sphereGeometry, sphereMaterial159 );
	vertexRoot.add(sphere159);
	sphere159.position.set(getVertex159()[0],getVertex159()[1],getVertex159()[2]);

    const lableDiv159 = document.createElement( 'div' );
    lableDiv159.className = 'label';
    lableDiv159.textContent = '159';
    lableDiv159.style.marginTop = '-1em';

    const vertexLabel159 = new CSS2DObject( lableDiv159 );
    vertexLabel159.position.set(getVertex159()[0],getVertex159()[1],getVertex159()[2]);
    vertexlabelRoot.add( vertexLabel159 );
            
            	const sphereMaterial160 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere160 = new THREE.Mesh( sphereGeometry, sphereMaterial160 );
	vertexRoot.add(sphere160);
	sphere160.position.set(getVertex160()[0],getVertex160()[1],getVertex160()[2]);

    const lableDiv160 = document.createElement( 'div' );
    lableDiv160.className = 'label';
    lableDiv160.textContent = '160';
    lableDiv160.style.marginTop = '-1em';

    const vertexLabel160 = new CSS2DObject( lableDiv160 );
    vertexLabel160.position.set(getVertex160()[0],getVertex160()[1],getVertex160()[2]);
    vertexlabelRoot.add( vertexLabel160 );
            
            	const sphereMaterial161 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere161 = new THREE.Mesh( sphereGeometry, sphereMaterial161 );
	vertexRoot.add(sphere161);
	sphere161.position.set(getVertex161()[0],getVertex161()[1],getVertex161()[2]);

    const lableDiv161 = document.createElement( 'div' );
    lableDiv161.className = 'label';
    lableDiv161.textContent = '161';
    lableDiv161.style.marginTop = '-1em';

    const vertexLabel161 = new CSS2DObject( lableDiv161 );
    vertexLabel161.position.set(getVertex161()[0],getVertex161()[1],getVertex161()[2]);
    vertexlabelRoot.add( vertexLabel161 );
            
            	const sphereMaterial162 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere162 = new THREE.Mesh( sphereGeometry, sphereMaterial162 );
	vertexRoot.add(sphere162);
	sphere162.position.set(getVertex162()[0],getVertex162()[1],getVertex162()[2]);

    const lableDiv162 = document.createElement( 'div' );
    lableDiv162.className = 'label';
    lableDiv162.textContent = '162';
    lableDiv162.style.marginTop = '-1em';

    const vertexLabel162 = new CSS2DObject( lableDiv162 );
    vertexLabel162.position.set(getVertex162()[0],getVertex162()[1],getVertex162()[2]);
    vertexlabelRoot.add( vertexLabel162 );
            
            	const sphereMaterial163 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere163 = new THREE.Mesh( sphereGeometry, sphereMaterial163 );
	vertexRoot.add(sphere163);
	sphere163.position.set(getVertex163()[0],getVertex163()[1],getVertex163()[2]);

    const lableDiv163 = document.createElement( 'div' );
    lableDiv163.className = 'label';
    lableDiv163.textContent = '163';
    lableDiv163.style.marginTop = '-1em';

    const vertexLabel163 = new CSS2DObject( lableDiv163 );
    vertexLabel163.position.set(getVertex163()[0],getVertex163()[1],getVertex163()[2]);
    vertexlabelRoot.add( vertexLabel163 );
            
            	const sphereMaterial164 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere164 = new THREE.Mesh( sphereGeometry, sphereMaterial164 );
	vertexRoot.add(sphere164);
	sphere164.position.set(getVertex164()[0],getVertex164()[1],getVertex164()[2]);

    const lableDiv164 = document.createElement( 'div' );
    lableDiv164.className = 'label';
    lableDiv164.textContent = '164';
    lableDiv164.style.marginTop = '-1em';

    const vertexLabel164 = new CSS2DObject( lableDiv164 );
    vertexLabel164.position.set(getVertex164()[0],getVertex164()[1],getVertex164()[2]);
    vertexlabelRoot.add( vertexLabel164 );
            
            	const sphereMaterial165 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere165 = new THREE.Mesh( sphereGeometry, sphereMaterial165 );
	vertexRoot.add(sphere165);
	sphere165.position.set(getVertex165()[0],getVertex165()[1],getVertex165()[2]);

    const lableDiv165 = document.createElement( 'div' );
    lableDiv165.className = 'label';
    lableDiv165.textContent = '165';
    lableDiv165.style.marginTop = '-1em';

    const vertexLabel165 = new CSS2DObject( lableDiv165 );
    vertexLabel165.position.set(getVertex165()[0],getVertex165()[1],getVertex165()[2]);
    vertexlabelRoot.add( vertexLabel165 );
            
            	const sphereMaterial166 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere166 = new THREE.Mesh( sphereGeometry, sphereMaterial166 );
	vertexRoot.add(sphere166);
	sphere166.position.set(getVertex166()[0],getVertex166()[1],getVertex166()[2]);

    const lableDiv166 = document.createElement( 'div' );
    lableDiv166.className = 'label';
    lableDiv166.textContent = '166';
    lableDiv166.style.marginTop = '-1em';

    const vertexLabel166 = new CSS2DObject( lableDiv166 );
    vertexLabel166.position.set(getVertex166()[0],getVertex166()[1],getVertex166()[2]);
    vertexlabelRoot.add( vertexLabel166 );
            
            	const sphereMaterial167 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere167 = new THREE.Mesh( sphereGeometry, sphereMaterial167 );
	vertexRoot.add(sphere167);
	sphere167.position.set(getVertex167()[0],getVertex167()[1],getVertex167()[2]);

    const lableDiv167 = document.createElement( 'div' );
    lableDiv167.className = 'label';
    lableDiv167.textContent = '167';
    lableDiv167.style.marginTop = '-1em';

    const vertexLabel167 = new CSS2DObject( lableDiv167 );
    vertexLabel167.position.set(getVertex167()[0],getVertex167()[1],getVertex167()[2]);
    vertexlabelRoot.add( vertexLabel167 );
            
            	const sphereMaterial168 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere168 = new THREE.Mesh( sphereGeometry, sphereMaterial168 );
	vertexRoot.add(sphere168);
	sphere168.position.set(getVertex168()[0],getVertex168()[1],getVertex168()[2]);

    const lableDiv168 = document.createElement( 'div' );
    lableDiv168.className = 'label';
    lableDiv168.textContent = '168';
    lableDiv168.style.marginTop = '-1em';

    const vertexLabel168 = new CSS2DObject( lableDiv168 );
    vertexLabel168.position.set(getVertex168()[0],getVertex168()[1],getVertex168()[2]);
    vertexlabelRoot.add( vertexLabel168 );
            
            	const sphereMaterial169 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere169 = new THREE.Mesh( sphereGeometry, sphereMaterial169 );
	vertexRoot.add(sphere169);
	sphere169.position.set(getVertex169()[0],getVertex169()[1],getVertex169()[2]);

    const lableDiv169 = document.createElement( 'div' );
    lableDiv169.className = 'label';
    lableDiv169.textContent = '169';
    lableDiv169.style.marginTop = '-1em';

    const vertexLabel169 = new CSS2DObject( lableDiv169 );
    vertexLabel169.position.set(getVertex169()[0],getVertex169()[1],getVertex169()[2]);
    vertexlabelRoot.add( vertexLabel169 );
            
            	const sphereMaterial170 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere170 = new THREE.Mesh( sphereGeometry, sphereMaterial170 );
	vertexRoot.add(sphere170);
	sphere170.position.set(getVertex170()[0],getVertex170()[1],getVertex170()[2]);

    const lableDiv170 = document.createElement( 'div' );
    lableDiv170.className = 'label';
    lableDiv170.textContent = '170';
    lableDiv170.style.marginTop = '-1em';

    const vertexLabel170 = new CSS2DObject( lableDiv170 );
    vertexLabel170.position.set(getVertex170()[0],getVertex170()[1],getVertex170()[2]);
    vertexlabelRoot.add( vertexLabel170 );
            
            	const sphereMaterial171 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere171 = new THREE.Mesh( sphereGeometry, sphereMaterial171 );
	vertexRoot.add(sphere171);
	sphere171.position.set(getVertex171()[0],getVertex171()[1],getVertex171()[2]);

    const lableDiv171 = document.createElement( 'div' );
    lableDiv171.className = 'label';
    lableDiv171.textContent = '171';
    lableDiv171.style.marginTop = '-1em';

    const vertexLabel171 = new CSS2DObject( lableDiv171 );
    vertexLabel171.position.set(getVertex171()[0],getVertex171()[1],getVertex171()[2]);
    vertexlabelRoot.add( vertexLabel171 );
            
            	const sphereMaterial172 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere172 = new THREE.Mesh( sphereGeometry, sphereMaterial172 );
	vertexRoot.add(sphere172);
	sphere172.position.set(getVertex172()[0],getVertex172()[1],getVertex172()[2]);

    const lableDiv172 = document.createElement( 'div' );
    lableDiv172.className = 'label';
    lableDiv172.textContent = '172';
    lableDiv172.style.marginTop = '-1em';

    const vertexLabel172 = new CSS2DObject( lableDiv172 );
    vertexLabel172.position.set(getVertex172()[0],getVertex172()[1],getVertex172()[2]);
    vertexlabelRoot.add( vertexLabel172 );
            
            	const sphereMaterial173 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere173 = new THREE.Mesh( sphereGeometry, sphereMaterial173 );
	vertexRoot.add(sphere173);
	sphere173.position.set(getVertex173()[0],getVertex173()[1],getVertex173()[2]);

    const lableDiv173 = document.createElement( 'div' );
    lableDiv173.className = 'label';
    lableDiv173.textContent = '173';
    lableDiv173.style.marginTop = '-1em';

    const vertexLabel173 = new CSS2DObject( lableDiv173 );
    vertexLabel173.position.set(getVertex173()[0],getVertex173()[1],getVertex173()[2]);
    vertexlabelRoot.add( vertexLabel173 );
            
            	const sphereMaterial174 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere174 = new THREE.Mesh( sphereGeometry, sphereMaterial174 );
	vertexRoot.add(sphere174);
	sphere174.position.set(getVertex174()[0],getVertex174()[1],getVertex174()[2]);

    const lableDiv174 = document.createElement( 'div' );
    lableDiv174.className = 'label';
    lableDiv174.textContent = '174';
    lableDiv174.style.marginTop = '-1em';

    const vertexLabel174 = new CSS2DObject( lableDiv174 );
    vertexLabel174.position.set(getVertex174()[0],getVertex174()[1],getVertex174()[2]);
    vertexlabelRoot.add( vertexLabel174 );
            
            	const sphereMaterial175 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere175 = new THREE.Mesh( sphereGeometry, sphereMaterial175 );
	vertexRoot.add(sphere175);
	sphere175.position.set(getVertex175()[0],getVertex175()[1],getVertex175()[2]);

    const lableDiv175 = document.createElement( 'div' );
    lableDiv175.className = 'label';
    lableDiv175.textContent = '175';
    lableDiv175.style.marginTop = '-1em';

    const vertexLabel175 = new CSS2DObject( lableDiv175 );
    vertexLabel175.position.set(getVertex175()[0],getVertex175()[1],getVertex175()[2]);
    vertexlabelRoot.add( vertexLabel175 );
            
            	const sphereMaterial176 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere176 = new THREE.Mesh( sphereGeometry, sphereMaterial176 );
	vertexRoot.add(sphere176);
	sphere176.position.set(getVertex176()[0],getVertex176()[1],getVertex176()[2]);

    const lableDiv176 = document.createElement( 'div' );
    lableDiv176.className = 'label';
    lableDiv176.textContent = '176';
    lableDiv176.style.marginTop = '-1em';

    const vertexLabel176 = new CSS2DObject( lableDiv176 );
    vertexLabel176.position.set(getVertex176()[0],getVertex176()[1],getVertex176()[2]);
    vertexlabelRoot.add( vertexLabel176 );
            
            	const sphereMaterial177 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere177 = new THREE.Mesh( sphereGeometry, sphereMaterial177 );
	vertexRoot.add(sphere177);
	sphere177.position.set(getVertex177()[0],getVertex177()[1],getVertex177()[2]);

    const lableDiv177 = document.createElement( 'div' );
    lableDiv177.className = 'label';
    lableDiv177.textContent = '177';
    lableDiv177.style.marginTop = '-1em';

    const vertexLabel177 = new CSS2DObject( lableDiv177 );
    vertexLabel177.position.set(getVertex177()[0],getVertex177()[1],getVertex177()[2]);
    vertexlabelRoot.add( vertexLabel177 );
            
            	const sphereMaterial178 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere178 = new THREE.Mesh( sphereGeometry, sphereMaterial178 );
	vertexRoot.add(sphere178);
	sphere178.position.set(getVertex178()[0],getVertex178()[1],getVertex178()[2]);

    const lableDiv178 = document.createElement( 'div' );
    lableDiv178.className = 'label';
    lableDiv178.textContent = '178';
    lableDiv178.style.marginTop = '-1em';

    const vertexLabel178 = new CSS2DObject( lableDiv178 );
    vertexLabel178.position.set(getVertex178()[0],getVertex178()[1],getVertex178()[2]);
    vertexlabelRoot.add( vertexLabel178 );
            
            	const sphereMaterial179 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere179 = new THREE.Mesh( sphereGeometry, sphereMaterial179 );
	vertexRoot.add(sphere179);
	sphere179.position.set(getVertex179()[0],getVertex179()[1],getVertex179()[2]);

    const lableDiv179 = document.createElement( 'div' );
    lableDiv179.className = 'label';
    lableDiv179.textContent = '179';
    lableDiv179.style.marginTop = '-1em';

    const vertexLabel179 = new CSS2DObject( lableDiv179 );
    vertexLabel179.position.set(getVertex179()[0],getVertex179()[1],getVertex179()[2]);
    vertexlabelRoot.add( vertexLabel179 );
            
            	const sphereMaterial180 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere180 = new THREE.Mesh( sphereGeometry, sphereMaterial180 );
	vertexRoot.add(sphere180);
	sphere180.position.set(getVertex180()[0],getVertex180()[1],getVertex180()[2]);

    const lableDiv180 = document.createElement( 'div' );
    lableDiv180.className = 'label';
    lableDiv180.textContent = '180';
    lableDiv180.style.marginTop = '-1em';

    const vertexLabel180 = new CSS2DObject( lableDiv180 );
    vertexLabel180.position.set(getVertex180()[0],getVertex180()[1],getVertex180()[2]);
    vertexlabelRoot.add( vertexLabel180 );
            
            	const sphereMaterial181 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere181 = new THREE.Mesh( sphereGeometry, sphereMaterial181 );
	vertexRoot.add(sphere181);
	sphere181.position.set(getVertex181()[0],getVertex181()[1],getVertex181()[2]);

    const lableDiv181 = document.createElement( 'div' );
    lableDiv181.className = 'label';
    lableDiv181.textContent = '181';
    lableDiv181.style.marginTop = '-1em';

    const vertexLabel181 = new CSS2DObject( lableDiv181 );
    vertexLabel181.position.set(getVertex181()[0],getVertex181()[1],getVertex181()[2]);
    vertexlabelRoot.add( vertexLabel181 );
            
            	const sphereMaterial182 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere182 = new THREE.Mesh( sphereGeometry, sphereMaterial182 );
	vertexRoot.add(sphere182);
	sphere182.position.set(getVertex182()[0],getVertex182()[1],getVertex182()[2]);

    const lableDiv182 = document.createElement( 'div' );
    lableDiv182.className = 'label';
    lableDiv182.textContent = '182';
    lableDiv182.style.marginTop = '-1em';

    const vertexLabel182 = new CSS2DObject( lableDiv182 );
    vertexLabel182.position.set(getVertex182()[0],getVertex182()[1],getVertex182()[2]);
    vertexlabelRoot.add( vertexLabel182 );
            
            	const sphereMaterial183 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere183 = new THREE.Mesh( sphereGeometry, sphereMaterial183 );
	vertexRoot.add(sphere183);
	sphere183.position.set(getVertex183()[0],getVertex183()[1],getVertex183()[2]);

    const lableDiv183 = document.createElement( 'div' );
    lableDiv183.className = 'label';
    lableDiv183.textContent = '183';
    lableDiv183.style.marginTop = '-1em';

    const vertexLabel183 = new CSS2DObject( lableDiv183 );
    vertexLabel183.position.set(getVertex183()[0],getVertex183()[1],getVertex183()[2]);
    vertexlabelRoot.add( vertexLabel183 );
            
            	const sphereMaterial184 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere184 = new THREE.Mesh( sphereGeometry, sphereMaterial184 );
	vertexRoot.add(sphere184);
	sphere184.position.set(getVertex184()[0],getVertex184()[1],getVertex184()[2]);

    const lableDiv184 = document.createElement( 'div' );
    lableDiv184.className = 'label';
    lableDiv184.textContent = '184';
    lableDiv184.style.marginTop = '-1em';

    const vertexLabel184 = new CSS2DObject( lableDiv184 );
    vertexLabel184.position.set(getVertex184()[0],getVertex184()[1],getVertex184()[2]);
    vertexlabelRoot.add( vertexLabel184 );
            
            	const sphereMaterial185 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere185 = new THREE.Mesh( sphereGeometry, sphereMaterial185 );
	vertexRoot.add(sphere185);
	sphere185.position.set(getVertex185()[0],getVertex185()[1],getVertex185()[2]);

    const lableDiv185 = document.createElement( 'div' );
    lableDiv185.className = 'label';
    lableDiv185.textContent = '185';
    lableDiv185.style.marginTop = '-1em';

    const vertexLabel185 = new CSS2DObject( lableDiv185 );
    vertexLabel185.position.set(getVertex185()[0],getVertex185()[1],getVertex185()[2]);
    vertexlabelRoot.add( vertexLabel185 );
            
            	const sphereMaterial186 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere186 = new THREE.Mesh( sphereGeometry, sphereMaterial186 );
	vertexRoot.add(sphere186);
	sphere186.position.set(getVertex186()[0],getVertex186()[1],getVertex186()[2]);

    const lableDiv186 = document.createElement( 'div' );
    lableDiv186.className = 'label';
    lableDiv186.textContent = '186';
    lableDiv186.style.marginTop = '-1em';

    const vertexLabel186 = new CSS2DObject( lableDiv186 );
    vertexLabel186.position.set(getVertex186()[0],getVertex186()[1],getVertex186()[2]);
    vertexlabelRoot.add( vertexLabel186 );
            
            	const sphereMaterial187 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere187 = new THREE.Mesh( sphereGeometry, sphereMaterial187 );
	vertexRoot.add(sphere187);
	sphere187.position.set(getVertex187()[0],getVertex187()[1],getVertex187()[2]);

    const lableDiv187 = document.createElement( 'div' );
    lableDiv187.className = 'label';
    lableDiv187.textContent = '187';
    lableDiv187.style.marginTop = '-1em';

    const vertexLabel187 = new CSS2DObject( lableDiv187 );
    vertexLabel187.position.set(getVertex187()[0],getVertex187()[1],getVertex187()[2]);
    vertexlabelRoot.add( vertexLabel187 );
            
            	const sphereMaterial188 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere188 = new THREE.Mesh( sphereGeometry, sphereMaterial188 );
	vertexRoot.add(sphere188);
	sphere188.position.set(getVertex188()[0],getVertex188()[1],getVertex188()[2]);

    const lableDiv188 = document.createElement( 'div' );
    lableDiv188.className = 'label';
    lableDiv188.textContent = '188';
    lableDiv188.style.marginTop = '-1em';

    const vertexLabel188 = new CSS2DObject( lableDiv188 );
    vertexLabel188.position.set(getVertex188()[0],getVertex188()[1],getVertex188()[2]);
    vertexlabelRoot.add( vertexLabel188 );
            
            	const sphereMaterial189 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere189 = new THREE.Mesh( sphereGeometry, sphereMaterial189 );
	vertexRoot.add(sphere189);
	sphere189.position.set(getVertex189()[0],getVertex189()[1],getVertex189()[2]);

    const lableDiv189 = document.createElement( 'div' );
    lableDiv189.className = 'label';
    lableDiv189.textContent = '189';
    lableDiv189.style.marginTop = '-1em';

    const vertexLabel189 = new CSS2DObject( lableDiv189 );
    vertexLabel189.position.set(getVertex189()[0],getVertex189()[1],getVertex189()[2]);
    vertexlabelRoot.add( vertexLabel189 );
            
            	const sphereMaterial190 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere190 = new THREE.Mesh( sphereGeometry, sphereMaterial190 );
	vertexRoot.add(sphere190);
	sphere190.position.set(getVertex190()[0],getVertex190()[1],getVertex190()[2]);

    const lableDiv190 = document.createElement( 'div' );
    lableDiv190.className = 'label';
    lableDiv190.textContent = '190';
    lableDiv190.style.marginTop = '-1em';

    const vertexLabel190 = new CSS2DObject( lableDiv190 );
    vertexLabel190.position.set(getVertex190()[0],getVertex190()[1],getVertex190()[2]);
    vertexlabelRoot.add( vertexLabel190 );
            
            	const sphereMaterial191 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere191 = new THREE.Mesh( sphereGeometry, sphereMaterial191 );
	vertexRoot.add(sphere191);
	sphere191.position.set(getVertex191()[0],getVertex191()[1],getVertex191()[2]);

    const lableDiv191 = document.createElement( 'div' );
    lableDiv191.className = 'label';
    lableDiv191.textContent = '191';
    lableDiv191.style.marginTop = '-1em';

    const vertexLabel191 = new CSS2DObject( lableDiv191 );
    vertexLabel191.position.set(getVertex191()[0],getVertex191()[1],getVertex191()[2]);
    vertexlabelRoot.add( vertexLabel191 );
            
            	const sphereMaterial192 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere192 = new THREE.Mesh( sphereGeometry, sphereMaterial192 );
	vertexRoot.add(sphere192);
	sphere192.position.set(getVertex192()[0],getVertex192()[1],getVertex192()[2]);

    const lableDiv192 = document.createElement( 'div' );
    lableDiv192.className = 'label';
    lableDiv192.textContent = '192';
    lableDiv192.style.marginTop = '-1em';

    const vertexLabel192 = new CSS2DObject( lableDiv192 );
    vertexLabel192.position.set(getVertex192()[0],getVertex192()[1],getVertex192()[2]);
    vertexlabelRoot.add( vertexLabel192 );
            
            	const sphereMaterial193 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere193 = new THREE.Mesh( sphereGeometry, sphereMaterial193 );
	vertexRoot.add(sphere193);
	sphere193.position.set(getVertex193()[0],getVertex193()[1],getVertex193()[2]);

    const lableDiv193 = document.createElement( 'div' );
    lableDiv193.className = 'label';
    lableDiv193.textContent = '193';
    lableDiv193.style.marginTop = '-1em';

    const vertexLabel193 = new CSS2DObject( lableDiv193 );
    vertexLabel193.position.set(getVertex193()[0],getVertex193()[1],getVertex193()[2]);
    vertexlabelRoot.add( vertexLabel193 );
            
            	const sphereMaterial194 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere194 = new THREE.Mesh( sphereGeometry, sphereMaterial194 );
	vertexRoot.add(sphere194);
	sphere194.position.set(getVertex194()[0],getVertex194()[1],getVertex194()[2]);

    const lableDiv194 = document.createElement( 'div' );
    lableDiv194.className = 'label';
    lableDiv194.textContent = '194';
    lableDiv194.style.marginTop = '-1em';

    const vertexLabel194 = new CSS2DObject( lableDiv194 );
    vertexLabel194.position.set(getVertex194()[0],getVertex194()[1],getVertex194()[2]);
    vertexlabelRoot.add( vertexLabel194 );
            
            	const sphereMaterial195 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere195 = new THREE.Mesh( sphereGeometry, sphereMaterial195 );
	vertexRoot.add(sphere195);
	sphere195.position.set(getVertex195()[0],getVertex195()[1],getVertex195()[2]);

    const lableDiv195 = document.createElement( 'div' );
    lableDiv195.className = 'label';
    lableDiv195.textContent = '195';
    lableDiv195.style.marginTop = '-1em';

    const vertexLabel195 = new CSS2DObject( lableDiv195 );
    vertexLabel195.position.set(getVertex195()[0],getVertex195()[1],getVertex195()[2]);
    vertexlabelRoot.add( vertexLabel195 );
            
            	const sphereMaterial196 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere196 = new THREE.Mesh( sphereGeometry, sphereMaterial196 );
	vertexRoot.add(sphere196);
	sphere196.position.set(getVertex196()[0],getVertex196()[1],getVertex196()[2]);

    const lableDiv196 = document.createElement( 'div' );
    lableDiv196.className = 'label';
    lableDiv196.textContent = '196';
    lableDiv196.style.marginTop = '-1em';

    const vertexLabel196 = new CSS2DObject( lableDiv196 );
    vertexLabel196.position.set(getVertex196()[0],getVertex196()[1],getVertex196()[2]);
    vertexlabelRoot.add( vertexLabel196 );
            
            	const sphereMaterial197 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere197 = new THREE.Mesh( sphereGeometry, sphereMaterial197 );
	vertexRoot.add(sphere197);
	sphere197.position.set(getVertex197()[0],getVertex197()[1],getVertex197()[2]);

    const lableDiv197 = document.createElement( 'div' );
    lableDiv197.className = 'label';
    lableDiv197.textContent = '197';
    lableDiv197.style.marginTop = '-1em';

    const vertexLabel197 = new CSS2DObject( lableDiv197 );
    vertexLabel197.position.set(getVertex197()[0],getVertex197()[1],getVertex197()[2]);
    vertexlabelRoot.add( vertexLabel197 );
            
            	const sphereMaterial198 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere198 = new THREE.Mesh( sphereGeometry, sphereMaterial198 );
	vertexRoot.add(sphere198);
	sphere198.position.set(getVertex198()[0],getVertex198()[1],getVertex198()[2]);

    const lableDiv198 = document.createElement( 'div' );
    lableDiv198.className = 'label';
    lableDiv198.textContent = '198';
    lableDiv198.style.marginTop = '-1em';

    const vertexLabel198 = new CSS2DObject( lableDiv198 );
    vertexLabel198.position.set(getVertex198()[0],getVertex198()[1],getVertex198()[2]);
    vertexlabelRoot.add( vertexLabel198 );
            
            	const sphereMaterial199 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere199 = new THREE.Mesh( sphereGeometry, sphereMaterial199 );
	vertexRoot.add(sphere199);
	sphere199.position.set(getVertex199()[0],getVertex199()[1],getVertex199()[2]);

    const lableDiv199 = document.createElement( 'div' );
    lableDiv199.className = 'label';
    lableDiv199.textContent = '199';
    lableDiv199.style.marginTop = '-1em';

    const vertexLabel199 = new CSS2DObject( lableDiv199 );
    vertexLabel199.position.set(getVertex199()[0],getVertex199()[1],getVertex199()[2]);
    vertexlabelRoot.add( vertexLabel199 );
            
            	const sphereMaterial200 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere200 = new THREE.Mesh( sphereGeometry, sphereMaterial200 );
	vertexRoot.add(sphere200);
	sphere200.position.set(getVertex200()[0],getVertex200()[1],getVertex200()[2]);

    const lableDiv200 = document.createElement( 'div' );
    lableDiv200.className = 'label';
    lableDiv200.textContent = '200';
    lableDiv200.style.marginTop = '-1em';

    const vertexLabel200 = new CSS2DObject( lableDiv200 );
    vertexLabel200.position.set(getVertex200()[0],getVertex200()[1],getVertex200()[2]);
    vertexlabelRoot.add( vertexLabel200 );
            
            	const sphereMaterial201 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere201 = new THREE.Mesh( sphereGeometry, sphereMaterial201 );
	vertexRoot.add(sphere201);
	sphere201.position.set(getVertex201()[0],getVertex201()[1],getVertex201()[2]);

    const lableDiv201 = document.createElement( 'div' );
    lableDiv201.className = 'label';
    lableDiv201.textContent = '201';
    lableDiv201.style.marginTop = '-1em';

    const vertexLabel201 = new CSS2DObject( lableDiv201 );
    vertexLabel201.position.set(getVertex201()[0],getVertex201()[1],getVertex201()[2]);
    vertexlabelRoot.add( vertexLabel201 );
            
            	const sphereMaterial202 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere202 = new THREE.Mesh( sphereGeometry, sphereMaterial202 );
	vertexRoot.add(sphere202);
	sphere202.position.set(getVertex202()[0],getVertex202()[1],getVertex202()[2]);

    const lableDiv202 = document.createElement( 'div' );
    lableDiv202.className = 'label';
    lableDiv202.textContent = '202';
    lableDiv202.style.marginTop = '-1em';

    const vertexLabel202 = new CSS2DObject( lableDiv202 );
    vertexLabel202.position.set(getVertex202()[0],getVertex202()[1],getVertex202()[2]);
    vertexlabelRoot.add( vertexLabel202 );
            
            	const sphereMaterial203 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere203 = new THREE.Mesh( sphereGeometry, sphereMaterial203 );
	vertexRoot.add(sphere203);
	sphere203.position.set(getVertex203()[0],getVertex203()[1],getVertex203()[2]);

    const lableDiv203 = document.createElement( 'div' );
    lableDiv203.className = 'label';
    lableDiv203.textContent = '203';
    lableDiv203.style.marginTop = '-1em';

    const vertexLabel203 = new CSS2DObject( lableDiv203 );
    vertexLabel203.position.set(getVertex203()[0],getVertex203()[1],getVertex203()[2]);
    vertexlabelRoot.add( vertexLabel203 );
            
            	const sphereMaterial204 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere204 = new THREE.Mesh( sphereGeometry, sphereMaterial204 );
	vertexRoot.add(sphere204);
	sphere204.position.set(getVertex204()[0],getVertex204()[1],getVertex204()[2]);

    const lableDiv204 = document.createElement( 'div' );
    lableDiv204.className = 'label';
    lableDiv204.textContent = '204';
    lableDiv204.style.marginTop = '-1em';

    const vertexLabel204 = new CSS2DObject( lableDiv204 );
    vertexLabel204.position.set(getVertex204()[0],getVertex204()[1],getVertex204()[2]);
    vertexlabelRoot.add( vertexLabel204 );
            
            	const sphereMaterial205 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere205 = new THREE.Mesh( sphereGeometry, sphereMaterial205 );
	vertexRoot.add(sphere205);
	sphere205.position.set(getVertex205()[0],getVertex205()[1],getVertex205()[2]);

    const lableDiv205 = document.createElement( 'div' );
    lableDiv205.className = 'label';
    lableDiv205.textContent = '205';
    lableDiv205.style.marginTop = '-1em';

    const vertexLabel205 = new CSS2DObject( lableDiv205 );
    vertexLabel205.position.set(getVertex205()[0],getVertex205()[1],getVertex205()[2]);
    vertexlabelRoot.add( vertexLabel205 );
            
            	const sphereMaterial206 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere206 = new THREE.Mesh( sphereGeometry, sphereMaterial206 );
	vertexRoot.add(sphere206);
	sphere206.position.set(getVertex206()[0],getVertex206()[1],getVertex206()[2]);

    const lableDiv206 = document.createElement( 'div' );
    lableDiv206.className = 'label';
    lableDiv206.textContent = '206';
    lableDiv206.style.marginTop = '-1em';

    const vertexLabel206 = new CSS2DObject( lableDiv206 );
    vertexLabel206.position.set(getVertex206()[0],getVertex206()[1],getVertex206()[2]);
    vertexlabelRoot.add( vertexLabel206 );
            
            	const sphereMaterial207 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere207 = new THREE.Mesh( sphereGeometry, sphereMaterial207 );
	vertexRoot.add(sphere207);
	sphere207.position.set(getVertex207()[0],getVertex207()[1],getVertex207()[2]);

    const lableDiv207 = document.createElement( 'div' );
    lableDiv207.className = 'label';
    lableDiv207.textContent = '207';
    lableDiv207.style.marginTop = '-1em';

    const vertexLabel207 = new CSS2DObject( lableDiv207 );
    vertexLabel207.position.set(getVertex207()[0],getVertex207()[1],getVertex207()[2]);
    vertexlabelRoot.add( vertexLabel207 );
            
            	const sphereMaterial208 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere208 = new THREE.Mesh( sphereGeometry, sphereMaterial208 );
	vertexRoot.add(sphere208);
	sphere208.position.set(getVertex208()[0],getVertex208()[1],getVertex208()[2]);

    const lableDiv208 = document.createElement( 'div' );
    lableDiv208.className = 'label';
    lableDiv208.textContent = '208';
    lableDiv208.style.marginTop = '-1em';

    const vertexLabel208 = new CSS2DObject( lableDiv208 );
    vertexLabel208.position.set(getVertex208()[0],getVertex208()[1],getVertex208()[2]);
    vertexlabelRoot.add( vertexLabel208 );
            
            	const sphereMaterial209 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere209 = new THREE.Mesh( sphereGeometry, sphereMaterial209 );
	vertexRoot.add(sphere209);
	sphere209.position.set(getVertex209()[0],getVertex209()[1],getVertex209()[2]);

    const lableDiv209 = document.createElement( 'div' );
    lableDiv209.className = 'label';
    lableDiv209.textContent = '209';
    lableDiv209.style.marginTop = '-1em';

    const vertexLabel209 = new CSS2DObject( lableDiv209 );
    vertexLabel209.position.set(getVertex209()[0],getVertex209()[1],getVertex209()[2]);
    vertexlabelRoot.add( vertexLabel209 );
            
            	const sphereMaterial210 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere210 = new THREE.Mesh( sphereGeometry, sphereMaterial210 );
	vertexRoot.add(sphere210);
	sphere210.position.set(getVertex210()[0],getVertex210()[1],getVertex210()[2]);

    const lableDiv210 = document.createElement( 'div' );
    lableDiv210.className = 'label';
    lableDiv210.textContent = '210';
    lableDiv210.style.marginTop = '-1em';

    const vertexLabel210 = new CSS2DObject( lableDiv210 );
    vertexLabel210.position.set(getVertex210()[0],getVertex210()[1],getVertex210()[2]);
    vertexlabelRoot.add( vertexLabel210 );
            
            	const sphereMaterial211 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere211 = new THREE.Mesh( sphereGeometry, sphereMaterial211 );
	vertexRoot.add(sphere211);
	sphere211.position.set(getVertex211()[0],getVertex211()[1],getVertex211()[2]);

    const lableDiv211 = document.createElement( 'div' );
    lableDiv211.className = 'label';
    lableDiv211.textContent = '211';
    lableDiv211.style.marginTop = '-1em';

    const vertexLabel211 = new CSS2DObject( lableDiv211 );
    vertexLabel211.position.set(getVertex211()[0],getVertex211()[1],getVertex211()[2]);
    vertexlabelRoot.add( vertexLabel211 );
            
            	const sphereMaterial212 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere212 = new THREE.Mesh( sphereGeometry, sphereMaterial212 );
	vertexRoot.add(sphere212);
	sphere212.position.set(getVertex212()[0],getVertex212()[1],getVertex212()[2]);

    const lableDiv212 = document.createElement( 'div' );
    lableDiv212.className = 'label';
    lableDiv212.textContent = '212';
    lableDiv212.style.marginTop = '-1em';

    const vertexLabel212 = new CSS2DObject( lableDiv212 );
    vertexLabel212.position.set(getVertex212()[0],getVertex212()[1],getVertex212()[2]);
    vertexlabelRoot.add( vertexLabel212 );
            
            	const sphereMaterial213 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere213 = new THREE.Mesh( sphereGeometry, sphereMaterial213 );
	vertexRoot.add(sphere213);
	sphere213.position.set(getVertex213()[0],getVertex213()[1],getVertex213()[2]);

    const lableDiv213 = document.createElement( 'div' );
    lableDiv213.className = 'label';
    lableDiv213.textContent = '213';
    lableDiv213.style.marginTop = '-1em';

    const vertexLabel213 = new CSS2DObject( lableDiv213 );
    vertexLabel213.position.set(getVertex213()[0],getVertex213()[1],getVertex213()[2]);
    vertexlabelRoot.add( vertexLabel213 );
            
            	const sphereMaterial214 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere214 = new THREE.Mesh( sphereGeometry, sphereMaterial214 );
	vertexRoot.add(sphere214);
	sphere214.position.set(getVertex214()[0],getVertex214()[1],getVertex214()[2]);

    const lableDiv214 = document.createElement( 'div' );
    lableDiv214.className = 'label';
    lableDiv214.textContent = '214';
    lableDiv214.style.marginTop = '-1em';

    const vertexLabel214 = new CSS2DObject( lableDiv214 );
    vertexLabel214.position.set(getVertex214()[0],getVertex214()[1],getVertex214()[2]);
    vertexlabelRoot.add( vertexLabel214 );
            
            	const sphereMaterial215 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere215 = new THREE.Mesh( sphereGeometry, sphereMaterial215 );
	vertexRoot.add(sphere215);
	sphere215.position.set(getVertex215()[0],getVertex215()[1],getVertex215()[2]);

    const lableDiv215 = document.createElement( 'div' );
    lableDiv215.className = 'label';
    lableDiv215.textContent = '215';
    lableDiv215.style.marginTop = '-1em';

    const vertexLabel215 = new CSS2DObject( lableDiv215 );
    vertexLabel215.position.set(getVertex215()[0],getVertex215()[1],getVertex215()[2]);
    vertexlabelRoot.add( vertexLabel215 );
            
            	const sphereMaterial216 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere216 = new THREE.Mesh( sphereGeometry, sphereMaterial216 );
	vertexRoot.add(sphere216);
	sphere216.position.set(getVertex216()[0],getVertex216()[1],getVertex216()[2]);

    const lableDiv216 = document.createElement( 'div' );
    lableDiv216.className = 'label';
    lableDiv216.textContent = '216';
    lableDiv216.style.marginTop = '-1em';

    const vertexLabel216 = new CSS2DObject( lableDiv216 );
    vertexLabel216.position.set(getVertex216()[0],getVertex216()[1],getVertex216()[2]);
    vertexlabelRoot.add( vertexLabel216 );
            
            	const sphereMaterial217 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere217 = new THREE.Mesh( sphereGeometry, sphereMaterial217 );
	vertexRoot.add(sphere217);
	sphere217.position.set(getVertex217()[0],getVertex217()[1],getVertex217()[2]);

    const lableDiv217 = document.createElement( 'div' );
    lableDiv217.className = 'label';
    lableDiv217.textContent = '217';
    lableDiv217.style.marginTop = '-1em';

    const vertexLabel217 = new CSS2DObject( lableDiv217 );
    vertexLabel217.position.set(getVertex217()[0],getVertex217()[1],getVertex217()[2]);
    vertexlabelRoot.add( vertexLabel217 );
            
            	const sphereMaterial218 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere218 = new THREE.Mesh( sphereGeometry, sphereMaterial218 );
	vertexRoot.add(sphere218);
	sphere218.position.set(getVertex218()[0],getVertex218()[1],getVertex218()[2]);

    const lableDiv218 = document.createElement( 'div' );
    lableDiv218.className = 'label';
    lableDiv218.textContent = '218';
    lableDiv218.style.marginTop = '-1em';

    const vertexLabel218 = new CSS2DObject( lableDiv218 );
    vertexLabel218.position.set(getVertex218()[0],getVertex218()[1],getVertex218()[2]);
    vertexlabelRoot.add( vertexLabel218 );
            
            	// generate the rings for the incircles 

	var inradius1 = calulateInradius(getVertex1(), getVertex2(), getVertex3());
	var incenter1 = calulateIncenter(getVertex1(), getVertex2(), getVertex3());
	var ringGeometry1 = new THREE.RingGeometry((inradius1 - 0.005),inradius1, 32);
	const ringMaterial1 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh1 = new THREE.Mesh(ringGeometry1, ringMaterial1);

	function setCircleRotation1(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,-1.,1.],[ -1.,-1.,0.],[-1.,0.,0.]);

        ringMesh1.position.setX(incenter[0]);
        ringMesh1.position.setY(incenter[1]);
        ringMesh1.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex2(), getVertex3());
        var relRadius = inradius/inradius1;

        ringMesh1.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A1 = new THREE.Vector3(-1.,-1.,1.);
        const B1 = new THREE.Vector3(-1.,-1.,0.);
        const C1 = new THREE.Vector3(-1.,0.,0.);

        const normalVec1 = new THREE.Vector3();
        normalVec1.crossVectors(B1.sub(A1), C1.sub(A1));
        normalVec1.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal1 = new THREE.Vector3(0,0,1);

        const quaternionRotation1 = new THREE.Quaternion();
        quaternionRotation1.setFromUnitVectors(initialNormal1, normalVec1);

        ringMesh1.setRotationFromQuaternion(quaternionRotation1);

        return quaternionRotation1;
    }

    ringRoot.add(ringMesh1);
            
	var inradius2 = calulateInradius(getVertex1(), getVertex3(), getVertex4());
	var incenter2 = calulateIncenter(getVertex1(), getVertex3(), getVertex4());
	var ringGeometry2 = new THREE.RingGeometry((inradius2 - 0.005),inradius2, 32);
	const ringMaterial2 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh2 = new THREE.Mesh(ringGeometry2, ringMaterial2);

	function setCircleRotation2(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,-1.,1.],[ -1.,0.,0.],[-1.,0.,1.]);

        ringMesh2.position.setX(incenter[0]);
        ringMesh2.position.setY(incenter[1]);
        ringMesh2.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex3(), getVertex4());
        var relRadius = inradius/inradius2;

        ringMesh2.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A2 = new THREE.Vector3(-1.,-1.,1.);
        const B2 = new THREE.Vector3(-1.,0.,0.);
        const C2 = new THREE.Vector3(-1.,0.,1.);

        const normalVec2 = new THREE.Vector3();
        normalVec2.crossVectors(B2.sub(A2), C2.sub(A2));
        normalVec2.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal2 = new THREE.Vector3(0,0,1);

        const quaternionRotation2 = new THREE.Quaternion();
        quaternionRotation2.setFromUnitVectors(initialNormal2, normalVec2);

        ringMesh2.setRotationFromQuaternion(quaternionRotation2);

        return quaternionRotation2;
    }

    ringRoot.add(ringMesh2);
            
	var inradius3 = calulateInradius(getVertex1(), getVertex2(), getVertex7());
	var incenter3 = calulateIncenter(getVertex1(), getVertex2(), getVertex7());
	var ringGeometry3 = new THREE.RingGeometry((inradius3 - 0.005),inradius3, 32);
	const ringMaterial3 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh3 = new THREE.Mesh(ringGeometry3, ringMaterial3);

	function setCircleRotation3(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,-1.,1.],[ -1.,-1.,0.],[0.,-1.,0.]);

        ringMesh3.position.setX(incenter[0]);
        ringMesh3.position.setY(incenter[1]);
        ringMesh3.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex2(), getVertex7());
        var relRadius = inradius/inradius3;

        ringMesh3.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A3 = new THREE.Vector3(-1.,-1.,1.);
        const B3 = new THREE.Vector3(-1.,-1.,0.);
        const C3 = new THREE.Vector3(0.,-1.,0.);

        const normalVec3 = new THREE.Vector3();
        normalVec3.crossVectors(B3.sub(A3), C3.sub(A3));
        normalVec3.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal3 = new THREE.Vector3(0,0,1);

        const quaternionRotation3 = new THREE.Quaternion();
        quaternionRotation3.setFromUnitVectors(initialNormal3, normalVec3);

        ringMesh3.setRotationFromQuaternion(quaternionRotation3);

        return quaternionRotation3;
    }

    ringRoot.add(ringMesh3);
            
	var inradius4 = calulateInradius(getVertex1(), getVertex7(), getVertex8());
	var incenter4 = calulateIncenter(getVertex1(), getVertex7(), getVertex8());
	var ringGeometry4 = new THREE.RingGeometry((inradius4 - 0.005),inradius4, 32);
	const ringMaterial4 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh4 = new THREE.Mesh(ringGeometry4, ringMaterial4);

	function setCircleRotation4(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,-1.,1.],[ 0.,-1.,0.],[0.,-1.,1.]);

        ringMesh4.position.setX(incenter[0]);
        ringMesh4.position.setY(incenter[1]);
        ringMesh4.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex7(), getVertex8());
        var relRadius = inradius/inradius4;

        ringMesh4.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A4 = new THREE.Vector3(-1.,-1.,1.);
        const B4 = new THREE.Vector3(0.,-1.,0.);
        const C4 = new THREE.Vector3(0.,-1.,1.);

        const normalVec4 = new THREE.Vector3();
        normalVec4.crossVectors(B4.sub(A4), C4.sub(A4));
        normalVec4.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal4 = new THREE.Vector3(0,0,1);

        const quaternionRotation4 = new THREE.Quaternion();
        quaternionRotation4.setFromUnitVectors(initialNormal4, normalVec4);

        ringMesh4.setRotationFromQuaternion(quaternionRotation4);

        return quaternionRotation4;
    }

    ringRoot.add(ringMesh4);
            
	var inradius5 = calulateInradius(getVertex2(), getVertex3(), getVertex7());
	var incenter5 = calulateIncenter(getVertex2(), getVertex3(), getVertex7());
	var ringGeometry5 = new THREE.RingGeometry((inradius5 - 0.005),inradius5, 32);
	const ringMaterial5 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh5 = new THREE.Mesh(ringGeometry5, ringMaterial5);

	function setCircleRotation5(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,-1.,0.],[ -1.,0.,0.],[0.,-1.,0.]);

        ringMesh5.position.setX(incenter[0]);
        ringMesh5.position.setY(incenter[1]);
        ringMesh5.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex2(), getVertex3(), getVertex7());
        var relRadius = inradius/inradius5;

        ringMesh5.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A5 = new THREE.Vector3(-1.,-1.,0.);
        const B5 = new THREE.Vector3(-1.,0.,0.);
        const C5 = new THREE.Vector3(0.,-1.,0.);

        const normalVec5 = new THREE.Vector3();
        normalVec5.crossVectors(B5.sub(A5), C5.sub(A5));
        normalVec5.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal5 = new THREE.Vector3(0,0,1);

        const quaternionRotation5 = new THREE.Quaternion();
        quaternionRotation5.setFromUnitVectors(initialNormal5, normalVec5);

        ringMesh5.setRotationFromQuaternion(quaternionRotation5);

        return quaternionRotation5;
    }

    ringRoot.add(ringMesh5);
            
	var inradius6 = calulateInradius(getVertex3(), getVertex6(), getVertex7());
	var incenter6 = calulateIncenter(getVertex3(), getVertex6(), getVertex7());
	var ringGeometry6 = new THREE.RingGeometry((inradius6 - 0.005),inradius6, 32);
	const ringMaterial6 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh6 = new THREE.Mesh(ringGeometry6, ringMaterial6);

	function setCircleRotation6(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.],[0.,-1.,0.]);

        ringMesh6.position.setX(incenter[0]);
        ringMesh6.position.setY(incenter[1]);
        ringMesh6.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex6(), getVertex7());
        var relRadius = inradius/inradius6;

        ringMesh6.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A6 = new THREE.Vector3(-1.,0.,0.);
        const B6 = new THREE.Vector3(0.,0.,0.);
        const C6 = new THREE.Vector3(0.,-1.,0.);

        const normalVec6 = new THREE.Vector3();
        normalVec6.crossVectors(B6.sub(A6), C6.sub(A6));
        normalVec6.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal6 = new THREE.Vector3(0,0,1);

        const quaternionRotation6 = new THREE.Quaternion();
        quaternionRotation6.setFromUnitVectors(initialNormal6, normalVec6);

        ringMesh6.setRotationFromQuaternion(quaternionRotation6);

        return quaternionRotation6;
    }

    ringRoot.add(ringMesh6);
            
	var inradius7 = calulateInradius(getVertex1(), getVertex4(), getVertex8());
	var incenter7 = calulateIncenter(getVertex1(), getVertex4(), getVertex8());
	var ringGeometry7 = new THREE.RingGeometry((inradius7 - 0.005),inradius7, 32);
	const ringMaterial7 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh7 = new THREE.Mesh(ringGeometry7, ringMaterial7);

	function setCircleRotation7(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,-1.,1.],[ -1.,0.,1.],[0.,-1.,1.]);

        ringMesh7.position.setX(incenter[0]);
        ringMesh7.position.setY(incenter[1]);
        ringMesh7.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex4(), getVertex8());
        var relRadius = inradius/inradius7;

        ringMesh7.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A7 = new THREE.Vector3(-1.,-1.,1.);
        const B7 = new THREE.Vector3(-1.,0.,1.);
        const C7 = new THREE.Vector3(0.,-1.,1.);

        const normalVec7 = new THREE.Vector3();
        normalVec7.crossVectors(B7.sub(A7), C7.sub(A7));
        normalVec7.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal7 = new THREE.Vector3(0,0,1);

        const quaternionRotation7 = new THREE.Quaternion();
        quaternionRotation7.setFromUnitVectors(initialNormal7, normalVec7);

        ringMesh7.setRotationFromQuaternion(quaternionRotation7);

        return quaternionRotation7;
    }

    ringRoot.add(ringMesh7);
            
	var inradius8 = calulateInradius(getVertex4(), getVertex5(), getVertex8());
	var incenter8 = calulateIncenter(getVertex4(), getVertex5(), getVertex8());
	var ringGeometry8 = new THREE.RingGeometry((inradius8 - 0.005),inradius8, 32);
	const ringMaterial8 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh8 = new THREE.Mesh(ringGeometry8, ringMaterial8);

	function setCircleRotation8(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,1.],[0.,-1.,1.]);

        ringMesh8.position.setX(incenter[0]);
        ringMesh8.position.setY(incenter[1]);
        ringMesh8.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex5(), getVertex8());
        var relRadius = inradius/inradius8;

        ringMesh8.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A8 = new THREE.Vector3(-1.,0.,1.);
        const B8 = new THREE.Vector3(0.,0.,1.);
        const C8 = new THREE.Vector3(0.,-1.,1.);

        const normalVec8 = new THREE.Vector3();
        normalVec8.crossVectors(B8.sub(A8), C8.sub(A8));
        normalVec8.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal8 = new THREE.Vector3(0,0,1);

        const quaternionRotation8 = new THREE.Quaternion();
        quaternionRotation8.setFromUnitVectors(initialNormal8, normalVec8);

        ringMesh8.setRotationFromQuaternion(quaternionRotation8);

        return quaternionRotation8;
    }

    ringRoot.add(ringMesh8);
            
	var inradius9 = calulateInradius(getVertex3(), getVertex6(), getVertex109());
	var incenter9 = calulateIncenter(getVertex3(), getVertex6(), getVertex109());
	var ringGeometry9 = new THREE.RingGeometry((inradius9 - 0.005),inradius9, 32);
	const ringMaterial9 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh9 = new THREE.Mesh(ringGeometry9, ringMaterial9);

	function setCircleRotation9(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.],[0.,0.,0.0098039215686274161]);

        ringMesh9.position.setX(incenter[0]);
        ringMesh9.position.setY(incenter[1]);
        ringMesh9.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex6(), getVertex109());
        var relRadius = inradius/inradius9;

        ringMesh9.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A9 = new THREE.Vector3(-1.,0.,0.);
        const B9 = new THREE.Vector3(0.,0.,0.);
        const C9 = new THREE.Vector3(0.,0.,0.0098039215686274161);

        const normalVec9 = new THREE.Vector3();
        normalVec9.crossVectors(B9.sub(A9), C9.sub(A9));
        normalVec9.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal9 = new THREE.Vector3(0,0,1);

        const quaternionRotation9 = new THREE.Quaternion();
        quaternionRotation9.setFromUnitVectors(initialNormal9, normalVec9);

        ringMesh9.setRotationFromQuaternion(quaternionRotation9);

        return quaternionRotation9;
    }

    ringRoot.add(ringMesh9);
            
	var inradius10 = calulateInradius(getVertex4(), getVertex5(), getVertex9());
	var incenter10 = calulateIncenter(getVertex4(), getVertex5(), getVertex9());
	var ringGeometry10 = new THREE.RingGeometry((inradius10 - 0.005),inradius10, 32);
	const ringMaterial10 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh10 = new THREE.Mesh(ringGeometry10, ringMaterial10);

	function setCircleRotation10(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,1.],[0.,0.,0.99019607843137258]);

        ringMesh10.position.setX(incenter[0]);
        ringMesh10.position.setY(incenter[1]);
        ringMesh10.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex5(), getVertex9());
        var relRadius = inradius/inradius10;

        ringMesh10.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A10 = new THREE.Vector3(-1.,0.,1.);
        const B10 = new THREE.Vector3(0.,0.,1.);
        const C10 = new THREE.Vector3(0.,0.,0.99019607843137258);

        const normalVec10 = new THREE.Vector3();
        normalVec10.crossVectors(B10.sub(A10), C10.sub(A10));
        normalVec10.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal10 = new THREE.Vector3(0,0,1);

        const quaternionRotation10 = new THREE.Quaternion();
        quaternionRotation10.setFromUnitVectors(initialNormal10, normalVec10);

        ringMesh10.setRotationFromQuaternion(quaternionRotation10);

        return quaternionRotation10;
    }

    ringRoot.add(ringMesh10);
            
	var inradius11 = calulateInradius(getVertex3(), getVertex108(), getVertex109());
	var incenter11 = calulateIncenter(getVertex3(), getVertex108(), getVertex109());
	var ringGeometry11 = new THREE.RingGeometry((inradius11 - 0.005),inradius11, 32);
	const ringMaterial11 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh11 = new THREE.Mesh(ringGeometry11, ringMaterial11);

	function setCircleRotation11(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.019607843137254943],[0.,0.,0.0098039215686274161]);

        ringMesh11.position.setX(incenter[0]);
        ringMesh11.position.setY(incenter[1]);
        ringMesh11.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex108(), getVertex109());
        var relRadius = inradius/inradius11;

        ringMesh11.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A11 = new THREE.Vector3(-1.,0.,0.);
        const B11 = new THREE.Vector3(0.,0.,0.019607843137254943);
        const C11 = new THREE.Vector3(0.,0.,0.0098039215686274161);

        const normalVec11 = new THREE.Vector3();
        normalVec11.crossVectors(B11.sub(A11), C11.sub(A11));
        normalVec11.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal11 = new THREE.Vector3(0,0,1);

        const quaternionRotation11 = new THREE.Quaternion();
        quaternionRotation11.setFromUnitVectors(initialNormal11, normalVec11);

        ringMesh11.setRotationFromQuaternion(quaternionRotation11);

        return quaternionRotation11;
    }

    ringRoot.add(ringMesh11);
            
	var inradius12 = calulateInradius(getVertex4(), getVertex9(), getVertex10());
	var incenter12 = calulateIncenter(getVertex4(), getVertex9(), getVertex10());
	var ringGeometry12 = new THREE.RingGeometry((inradius12 - 0.005),inradius12, 32);
	const ringMaterial12 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh12 = new THREE.Mesh(ringGeometry12, ringMaterial12);

	function setCircleRotation12(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.99019607843137258],[0.,0.,0.98039215686274506]);

        ringMesh12.position.setX(incenter[0]);
        ringMesh12.position.setY(incenter[1]);
        ringMesh12.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex9(), getVertex10());
        var relRadius = inradius/inradius12;

        ringMesh12.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A12 = new THREE.Vector3(-1.,0.,1.);
        const B12 = new THREE.Vector3(0.,0.,0.99019607843137258);
        const C12 = new THREE.Vector3(0.,0.,0.98039215686274506);

        const normalVec12 = new THREE.Vector3();
        normalVec12.crossVectors(B12.sub(A12), C12.sub(A12));
        normalVec12.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal12 = new THREE.Vector3(0,0,1);

        const quaternionRotation12 = new THREE.Quaternion();
        quaternionRotation12.setFromUnitVectors(initialNormal12, normalVec12);

        ringMesh12.setRotationFromQuaternion(quaternionRotation12);

        return quaternionRotation12;
    }

    ringRoot.add(ringMesh12);
            
	var inradius13 = calulateInradius(getVertex3(), getVertex107(), getVertex108());
	var incenter13 = calulateIncenter(getVertex3(), getVertex107(), getVertex108());
	var ringGeometry13 = new THREE.RingGeometry((inradius13 - 0.005),inradius13, 32);
	const ringMaterial13 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh13 = new THREE.Mesh(ringGeometry13, ringMaterial13);

	function setCircleRotation13(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.029411764705882359],[0.,0.,0.019607843137254943]);

        ringMesh13.position.setX(incenter[0]);
        ringMesh13.position.setY(incenter[1]);
        ringMesh13.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex107(), getVertex108());
        var relRadius = inradius/inradius13;

        ringMesh13.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A13 = new THREE.Vector3(-1.,0.,0.);
        const B13 = new THREE.Vector3(0.,0.,0.029411764705882359);
        const C13 = new THREE.Vector3(0.,0.,0.019607843137254943);

        const normalVec13 = new THREE.Vector3();
        normalVec13.crossVectors(B13.sub(A13), C13.sub(A13));
        normalVec13.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal13 = new THREE.Vector3(0,0,1);

        const quaternionRotation13 = new THREE.Quaternion();
        quaternionRotation13.setFromUnitVectors(initialNormal13, normalVec13);

        ringMesh13.setRotationFromQuaternion(quaternionRotation13);

        return quaternionRotation13;
    }

    ringRoot.add(ringMesh13);
            
	var inradius14 = calulateInradius(getVertex4(), getVertex10(), getVertex11());
	var incenter14 = calulateIncenter(getVertex4(), getVertex10(), getVertex11());
	var ringGeometry14 = new THREE.RingGeometry((inradius14 - 0.005),inradius14, 32);
	const ringMaterial14 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh14 = new THREE.Mesh(ringGeometry14, ringMaterial14);

	function setCircleRotation14(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.98039215686274506],[0.,0.,0.97058823529411764]);

        ringMesh14.position.setX(incenter[0]);
        ringMesh14.position.setY(incenter[1]);
        ringMesh14.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex10(), getVertex11());
        var relRadius = inradius/inradius14;

        ringMesh14.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A14 = new THREE.Vector3(-1.,0.,1.);
        const B14 = new THREE.Vector3(0.,0.,0.98039215686274506);
        const C14 = new THREE.Vector3(0.,0.,0.97058823529411764);

        const normalVec14 = new THREE.Vector3();
        normalVec14.crossVectors(B14.sub(A14), C14.sub(A14));
        normalVec14.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal14 = new THREE.Vector3(0,0,1);

        const quaternionRotation14 = new THREE.Quaternion();
        quaternionRotation14.setFromUnitVectors(initialNormal14, normalVec14);

        ringMesh14.setRotationFromQuaternion(quaternionRotation14);

        return quaternionRotation14;
    }

    ringRoot.add(ringMesh14);
            
	var inradius15 = calulateInradius(getVertex3(), getVertex106(), getVertex107());
	var incenter15 = calulateIncenter(getVertex3(), getVertex106(), getVertex107());
	var ringGeometry15 = new THREE.RingGeometry((inradius15 - 0.005),inradius15, 32);
	const ringMaterial15 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh15 = new THREE.Mesh(ringGeometry15, ringMaterial15);

	function setCircleRotation15(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.039215686274509776],[0.,0.,0.029411764705882359]);

        ringMesh15.position.setX(incenter[0]);
        ringMesh15.position.setY(incenter[1]);
        ringMesh15.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex106(), getVertex107());
        var relRadius = inradius/inradius15;

        ringMesh15.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A15 = new THREE.Vector3(-1.,0.,0.);
        const B15 = new THREE.Vector3(0.,0.,0.039215686274509776);
        const C15 = new THREE.Vector3(0.,0.,0.029411764705882359);

        const normalVec15 = new THREE.Vector3();
        normalVec15.crossVectors(B15.sub(A15), C15.sub(A15));
        normalVec15.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal15 = new THREE.Vector3(0,0,1);

        const quaternionRotation15 = new THREE.Quaternion();
        quaternionRotation15.setFromUnitVectors(initialNormal15, normalVec15);

        ringMesh15.setRotationFromQuaternion(quaternionRotation15);

        return quaternionRotation15;
    }

    ringRoot.add(ringMesh15);
            
	var inradius16 = calulateInradius(getVertex4(), getVertex11(), getVertex12());
	var incenter16 = calulateIncenter(getVertex4(), getVertex11(), getVertex12());
	var ringGeometry16 = new THREE.RingGeometry((inradius16 - 0.005),inradius16, 32);
	const ringMaterial16 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh16 = new THREE.Mesh(ringGeometry16, ringMaterial16);

	function setCircleRotation16(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.97058823529411764],[0.,0.,0.96078431372549022]);

        ringMesh16.position.setX(incenter[0]);
        ringMesh16.position.setY(incenter[1]);
        ringMesh16.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex11(), getVertex12());
        var relRadius = inradius/inradius16;

        ringMesh16.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A16 = new THREE.Vector3(-1.,0.,1.);
        const B16 = new THREE.Vector3(0.,0.,0.97058823529411764);
        const C16 = new THREE.Vector3(0.,0.,0.96078431372549022);

        const normalVec16 = new THREE.Vector3();
        normalVec16.crossVectors(B16.sub(A16), C16.sub(A16));
        normalVec16.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal16 = new THREE.Vector3(0,0,1);

        const quaternionRotation16 = new THREE.Quaternion();
        quaternionRotation16.setFromUnitVectors(initialNormal16, normalVec16);

        ringMesh16.setRotationFromQuaternion(quaternionRotation16);

        return quaternionRotation16;
    }

    ringRoot.add(ringMesh16);
            
	var inradius17 = calulateInradius(getVertex3(), getVertex105(), getVertex106());
	var incenter17 = calulateIncenter(getVertex3(), getVertex105(), getVertex106());
	var ringGeometry17 = new THREE.RingGeometry((inradius17 - 0.005),inradius17, 32);
	const ringMaterial17 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh17 = new THREE.Mesh(ringGeometry17, ringMaterial17);

	function setCircleRotation17(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.049019607843137303],[0.,0.,0.039215686274509776]);

        ringMesh17.position.setX(incenter[0]);
        ringMesh17.position.setY(incenter[1]);
        ringMesh17.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex105(), getVertex106());
        var relRadius = inradius/inradius17;

        ringMesh17.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A17 = new THREE.Vector3(-1.,0.,0.);
        const B17 = new THREE.Vector3(0.,0.,0.049019607843137303);
        const C17 = new THREE.Vector3(0.,0.,0.039215686274509776);

        const normalVec17 = new THREE.Vector3();
        normalVec17.crossVectors(B17.sub(A17), C17.sub(A17));
        normalVec17.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal17 = new THREE.Vector3(0,0,1);

        const quaternionRotation17 = new THREE.Quaternion();
        quaternionRotation17.setFromUnitVectors(initialNormal17, normalVec17);

        ringMesh17.setRotationFromQuaternion(quaternionRotation17);

        return quaternionRotation17;
    }

    ringRoot.add(ringMesh17);
            
	var inradius18 = calulateInradius(getVertex4(), getVertex12(), getVertex13());
	var incenter18 = calulateIncenter(getVertex4(), getVertex12(), getVertex13());
	var ringGeometry18 = new THREE.RingGeometry((inradius18 - 0.005),inradius18, 32);
	const ringMaterial18 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh18 = new THREE.Mesh(ringGeometry18, ringMaterial18);

	function setCircleRotation18(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.96078431372549022],[0.,0.,0.9509803921568627]);

        ringMesh18.position.setX(incenter[0]);
        ringMesh18.position.setY(incenter[1]);
        ringMesh18.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex12(), getVertex13());
        var relRadius = inradius/inradius18;

        ringMesh18.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A18 = new THREE.Vector3(-1.,0.,1.);
        const B18 = new THREE.Vector3(0.,0.,0.96078431372549022);
        const C18 = new THREE.Vector3(0.,0.,0.9509803921568627);

        const normalVec18 = new THREE.Vector3();
        normalVec18.crossVectors(B18.sub(A18), C18.sub(A18));
        normalVec18.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal18 = new THREE.Vector3(0,0,1);

        const quaternionRotation18 = new THREE.Quaternion();
        quaternionRotation18.setFromUnitVectors(initialNormal18, normalVec18);

        ringMesh18.setRotationFromQuaternion(quaternionRotation18);

        return quaternionRotation18;
    }

    ringRoot.add(ringMesh18);
            
	var inradius19 = calulateInradius(getVertex3(), getVertex104(), getVertex105());
	var incenter19 = calulateIncenter(getVertex3(), getVertex104(), getVertex105());
	var ringGeometry19 = new THREE.RingGeometry((inradius19 - 0.005),inradius19, 32);
	const ringMaterial19 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh19 = new THREE.Mesh(ringGeometry19, ringMaterial19);

	function setCircleRotation19(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.058823529411764719],[0.,0.,0.049019607843137303]);

        ringMesh19.position.setX(incenter[0]);
        ringMesh19.position.setY(incenter[1]);
        ringMesh19.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex104(), getVertex105());
        var relRadius = inradius/inradius19;

        ringMesh19.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A19 = new THREE.Vector3(-1.,0.,0.);
        const B19 = new THREE.Vector3(0.,0.,0.058823529411764719);
        const C19 = new THREE.Vector3(0.,0.,0.049019607843137303);

        const normalVec19 = new THREE.Vector3();
        normalVec19.crossVectors(B19.sub(A19), C19.sub(A19));
        normalVec19.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal19 = new THREE.Vector3(0,0,1);

        const quaternionRotation19 = new THREE.Quaternion();
        quaternionRotation19.setFromUnitVectors(initialNormal19, normalVec19);

        ringMesh19.setRotationFromQuaternion(quaternionRotation19);

        return quaternionRotation19;
    }

    ringRoot.add(ringMesh19);
            
	var inradius20 = calulateInradius(getVertex4(), getVertex13(), getVertex14());
	var incenter20 = calulateIncenter(getVertex4(), getVertex13(), getVertex14());
	var ringGeometry20 = new THREE.RingGeometry((inradius20 - 0.005),inradius20, 32);
	const ringMaterial20 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh20 = new THREE.Mesh(ringGeometry20, ringMaterial20);

	function setCircleRotation20(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.9509803921568627],[0.,0.,0.94117647058823528]);

        ringMesh20.position.setX(incenter[0]);
        ringMesh20.position.setY(incenter[1]);
        ringMesh20.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex13(), getVertex14());
        var relRadius = inradius/inradius20;

        ringMesh20.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A20 = new THREE.Vector3(-1.,0.,1.);
        const B20 = new THREE.Vector3(0.,0.,0.9509803921568627);
        const C20 = new THREE.Vector3(0.,0.,0.94117647058823528);

        const normalVec20 = new THREE.Vector3();
        normalVec20.crossVectors(B20.sub(A20), C20.sub(A20));
        normalVec20.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal20 = new THREE.Vector3(0,0,1);

        const quaternionRotation20 = new THREE.Quaternion();
        quaternionRotation20.setFromUnitVectors(initialNormal20, normalVec20);

        ringMesh20.setRotationFromQuaternion(quaternionRotation20);

        return quaternionRotation20;
    }

    ringRoot.add(ringMesh20);
            
	var inradius21 = calulateInradius(getVertex3(), getVertex103(), getVertex104());
	var incenter21 = calulateIncenter(getVertex3(), getVertex103(), getVertex104());
	var ringGeometry21 = new THREE.RingGeometry((inradius21 - 0.005),inradius21, 32);
	const ringMaterial21 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh21 = new THREE.Mesh(ringGeometry21, ringMaterial21);

	function setCircleRotation21(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.068627450980392135],[0.,0.,0.058823529411764719]);

        ringMesh21.position.setX(incenter[0]);
        ringMesh21.position.setY(incenter[1]);
        ringMesh21.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex103(), getVertex104());
        var relRadius = inradius/inradius21;

        ringMesh21.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A21 = new THREE.Vector3(-1.,0.,0.);
        const B21 = new THREE.Vector3(0.,0.,0.068627450980392135);
        const C21 = new THREE.Vector3(0.,0.,0.058823529411764719);

        const normalVec21 = new THREE.Vector3();
        normalVec21.crossVectors(B21.sub(A21), C21.sub(A21));
        normalVec21.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal21 = new THREE.Vector3(0,0,1);

        const quaternionRotation21 = new THREE.Quaternion();
        quaternionRotation21.setFromUnitVectors(initialNormal21, normalVec21);

        ringMesh21.setRotationFromQuaternion(quaternionRotation21);

        return quaternionRotation21;
    }

    ringRoot.add(ringMesh21);
            
	var inradius22 = calulateInradius(getVertex4(), getVertex14(), getVertex15());
	var incenter22 = calulateIncenter(getVertex4(), getVertex14(), getVertex15());
	var ringGeometry22 = new THREE.RingGeometry((inradius22 - 0.005),inradius22, 32);
	const ringMaterial22 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh22 = new THREE.Mesh(ringGeometry22, ringMaterial22);

	function setCircleRotation22(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.94117647058823528],[0.,0.,0.93137254901960786]);

        ringMesh22.position.setX(incenter[0]);
        ringMesh22.position.setY(incenter[1]);
        ringMesh22.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex14(), getVertex15());
        var relRadius = inradius/inradius22;

        ringMesh22.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A22 = new THREE.Vector3(-1.,0.,1.);
        const B22 = new THREE.Vector3(0.,0.,0.94117647058823528);
        const C22 = new THREE.Vector3(0.,0.,0.93137254901960786);

        const normalVec22 = new THREE.Vector3();
        normalVec22.crossVectors(B22.sub(A22), C22.sub(A22));
        normalVec22.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal22 = new THREE.Vector3(0,0,1);

        const quaternionRotation22 = new THREE.Quaternion();
        quaternionRotation22.setFromUnitVectors(initialNormal22, normalVec22);

        ringMesh22.setRotationFromQuaternion(quaternionRotation22);

        return quaternionRotation22;
    }

    ringRoot.add(ringMesh22);
            
	var inradius23 = calulateInradius(getVertex3(), getVertex102(), getVertex103());
	var incenter23 = calulateIncenter(getVertex3(), getVertex102(), getVertex103());
	var ringGeometry23 = new THREE.RingGeometry((inradius23 - 0.005),inradius23, 32);
	const ringMaterial23 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh23 = new THREE.Mesh(ringGeometry23, ringMaterial23);

	function setCircleRotation23(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.078431372549019662],[0.,0.,0.068627450980392135]);

        ringMesh23.position.setX(incenter[0]);
        ringMesh23.position.setY(incenter[1]);
        ringMesh23.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex102(), getVertex103());
        var relRadius = inradius/inradius23;

        ringMesh23.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A23 = new THREE.Vector3(-1.,0.,0.);
        const B23 = new THREE.Vector3(0.,0.,0.078431372549019662);
        const C23 = new THREE.Vector3(0.,0.,0.068627450980392135);

        const normalVec23 = new THREE.Vector3();
        normalVec23.crossVectors(B23.sub(A23), C23.sub(A23));
        normalVec23.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal23 = new THREE.Vector3(0,0,1);

        const quaternionRotation23 = new THREE.Quaternion();
        quaternionRotation23.setFromUnitVectors(initialNormal23, normalVec23);

        ringMesh23.setRotationFromQuaternion(quaternionRotation23);

        return quaternionRotation23;
    }

    ringRoot.add(ringMesh23);
            
	var inradius24 = calulateInradius(getVertex4(), getVertex15(), getVertex16());
	var incenter24 = calulateIncenter(getVertex4(), getVertex15(), getVertex16());
	var ringGeometry24 = new THREE.RingGeometry((inradius24 - 0.005),inradius24, 32);
	const ringMaterial24 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh24 = new THREE.Mesh(ringGeometry24, ringMaterial24);

	function setCircleRotation24(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.93137254901960786],[0.,0.,0.92156862745098045]);

        ringMesh24.position.setX(incenter[0]);
        ringMesh24.position.setY(incenter[1]);
        ringMesh24.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex15(), getVertex16());
        var relRadius = inradius/inradius24;

        ringMesh24.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A24 = new THREE.Vector3(-1.,0.,1.);
        const B24 = new THREE.Vector3(0.,0.,0.93137254901960786);
        const C24 = new THREE.Vector3(0.,0.,0.92156862745098045);

        const normalVec24 = new THREE.Vector3();
        normalVec24.crossVectors(B24.sub(A24), C24.sub(A24));
        normalVec24.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal24 = new THREE.Vector3(0,0,1);

        const quaternionRotation24 = new THREE.Quaternion();
        quaternionRotation24.setFromUnitVectors(initialNormal24, normalVec24);

        ringMesh24.setRotationFromQuaternion(quaternionRotation24);

        return quaternionRotation24;
    }

    ringRoot.add(ringMesh24);
            
	var inradius25 = calulateInradius(getVertex3(), getVertex101(), getVertex102());
	var incenter25 = calulateIncenter(getVertex3(), getVertex101(), getVertex102());
	var ringGeometry25 = new THREE.RingGeometry((inradius25 - 0.005),inradius25, 32);
	const ringMaterial25 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh25 = new THREE.Mesh(ringGeometry25, ringMaterial25);

	function setCircleRotation25(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.088235294117647078],[0.,0.,0.078431372549019662]);

        ringMesh25.position.setX(incenter[0]);
        ringMesh25.position.setY(incenter[1]);
        ringMesh25.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex101(), getVertex102());
        var relRadius = inradius/inradius25;

        ringMesh25.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A25 = new THREE.Vector3(-1.,0.,0.);
        const B25 = new THREE.Vector3(0.,0.,0.088235294117647078);
        const C25 = new THREE.Vector3(0.,0.,0.078431372549019662);

        const normalVec25 = new THREE.Vector3();
        normalVec25.crossVectors(B25.sub(A25), C25.sub(A25));
        normalVec25.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal25 = new THREE.Vector3(0,0,1);

        const quaternionRotation25 = new THREE.Quaternion();
        quaternionRotation25.setFromUnitVectors(initialNormal25, normalVec25);

        ringMesh25.setRotationFromQuaternion(quaternionRotation25);

        return quaternionRotation25;
    }

    ringRoot.add(ringMesh25);
            
	var inradius26 = calulateInradius(getVertex4(), getVertex16(), getVertex17());
	var incenter26 = calulateIncenter(getVertex4(), getVertex16(), getVertex17());
	var ringGeometry26 = new THREE.RingGeometry((inradius26 - 0.005),inradius26, 32);
	const ringMaterial26 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh26 = new THREE.Mesh(ringGeometry26, ringMaterial26);

	function setCircleRotation26(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.92156862745098045],[0.,0.,0.91176470588235292]);

        ringMesh26.position.setX(incenter[0]);
        ringMesh26.position.setY(incenter[1]);
        ringMesh26.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex16(), getVertex17());
        var relRadius = inradius/inradius26;

        ringMesh26.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A26 = new THREE.Vector3(-1.,0.,1.);
        const B26 = new THREE.Vector3(0.,0.,0.92156862745098045);
        const C26 = new THREE.Vector3(0.,0.,0.91176470588235292);

        const normalVec26 = new THREE.Vector3();
        normalVec26.crossVectors(B26.sub(A26), C26.sub(A26));
        normalVec26.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal26 = new THREE.Vector3(0,0,1);

        const quaternionRotation26 = new THREE.Quaternion();
        quaternionRotation26.setFromUnitVectors(initialNormal26, normalVec26);

        ringMesh26.setRotationFromQuaternion(quaternionRotation26);

        return quaternionRotation26;
    }

    ringRoot.add(ringMesh26);
            
	var inradius27 = calulateInradius(getVertex3(), getVertex100(), getVertex101());
	var incenter27 = calulateIncenter(getVertex3(), getVertex100(), getVertex101());
	var ringGeometry27 = new THREE.RingGeometry((inradius27 - 0.005),inradius27, 32);
	const ringMaterial27 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh27 = new THREE.Mesh(ringGeometry27, ringMaterial27);

	function setCircleRotation27(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.098039215686274495],[0.,0.,0.088235294117647078]);

        ringMesh27.position.setX(incenter[0]);
        ringMesh27.position.setY(incenter[1]);
        ringMesh27.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex100(), getVertex101());
        var relRadius = inradius/inradius27;

        ringMesh27.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A27 = new THREE.Vector3(-1.,0.,0.);
        const B27 = new THREE.Vector3(0.,0.,0.098039215686274495);
        const C27 = new THREE.Vector3(0.,0.,0.088235294117647078);

        const normalVec27 = new THREE.Vector3();
        normalVec27.crossVectors(B27.sub(A27), C27.sub(A27));
        normalVec27.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal27 = new THREE.Vector3(0,0,1);

        const quaternionRotation27 = new THREE.Quaternion();
        quaternionRotation27.setFromUnitVectors(initialNormal27, normalVec27);

        ringMesh27.setRotationFromQuaternion(quaternionRotation27);

        return quaternionRotation27;
    }

    ringRoot.add(ringMesh27);
            
	var inradius28 = calulateInradius(getVertex4(), getVertex17(), getVertex18());
	var incenter28 = calulateIncenter(getVertex4(), getVertex17(), getVertex18());
	var ringGeometry28 = new THREE.RingGeometry((inradius28 - 0.005),inradius28, 32);
	const ringMaterial28 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh28 = new THREE.Mesh(ringGeometry28, ringMaterial28);

	function setCircleRotation28(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.91176470588235292],[0.,0.,0.90196078431372551]);

        ringMesh28.position.setX(incenter[0]);
        ringMesh28.position.setY(incenter[1]);
        ringMesh28.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex17(), getVertex18());
        var relRadius = inradius/inradius28;

        ringMesh28.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A28 = new THREE.Vector3(-1.,0.,1.);
        const B28 = new THREE.Vector3(0.,0.,0.91176470588235292);
        const C28 = new THREE.Vector3(0.,0.,0.90196078431372551);

        const normalVec28 = new THREE.Vector3();
        normalVec28.crossVectors(B28.sub(A28), C28.sub(A28));
        normalVec28.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal28 = new THREE.Vector3(0,0,1);

        const quaternionRotation28 = new THREE.Quaternion();
        quaternionRotation28.setFromUnitVectors(initialNormal28, normalVec28);

        ringMesh28.setRotationFromQuaternion(quaternionRotation28);

        return quaternionRotation28;
    }

    ringRoot.add(ringMesh28);
            
	var inradius29 = calulateInradius(getVertex3(), getVertex99(), getVertex100());
	var incenter29 = calulateIncenter(getVertex3(), getVertex99(), getVertex100());
	var ringGeometry29 = new THREE.RingGeometry((inradius29 - 0.005),inradius29, 32);
	const ringMaterial29 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh29 = new THREE.Mesh(ringGeometry29, ringMaterial29);

	function setCircleRotation29(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.10784313725490202],[0.,0.,0.098039215686274495]);

        ringMesh29.position.setX(incenter[0]);
        ringMesh29.position.setY(incenter[1]);
        ringMesh29.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex99(), getVertex100());
        var relRadius = inradius/inradius29;

        ringMesh29.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A29 = new THREE.Vector3(-1.,0.,0.);
        const B29 = new THREE.Vector3(0.,0.,0.10784313725490202);
        const C29 = new THREE.Vector3(0.,0.,0.098039215686274495);

        const normalVec29 = new THREE.Vector3();
        normalVec29.crossVectors(B29.sub(A29), C29.sub(A29));
        normalVec29.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal29 = new THREE.Vector3(0,0,1);

        const quaternionRotation29 = new THREE.Quaternion();
        quaternionRotation29.setFromUnitVectors(initialNormal29, normalVec29);

        ringMesh29.setRotationFromQuaternion(quaternionRotation29);

        return quaternionRotation29;
    }

    ringRoot.add(ringMesh29);
            
	var inradius30 = calulateInradius(getVertex4(), getVertex18(), getVertex19());
	var incenter30 = calulateIncenter(getVertex4(), getVertex18(), getVertex19());
	var ringGeometry30 = new THREE.RingGeometry((inradius30 - 0.005),inradius30, 32);
	const ringMaterial30 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh30 = new THREE.Mesh(ringGeometry30, ringMaterial30);

	function setCircleRotation30(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.90196078431372551],[0.,0.,0.89215686274509798]);

        ringMesh30.position.setX(incenter[0]);
        ringMesh30.position.setY(incenter[1]);
        ringMesh30.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex18(), getVertex19());
        var relRadius = inradius/inradius30;

        ringMesh30.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A30 = new THREE.Vector3(-1.,0.,1.);
        const B30 = new THREE.Vector3(0.,0.,0.90196078431372551);
        const C30 = new THREE.Vector3(0.,0.,0.89215686274509798);

        const normalVec30 = new THREE.Vector3();
        normalVec30.crossVectors(B30.sub(A30), C30.sub(A30));
        normalVec30.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal30 = new THREE.Vector3(0,0,1);

        const quaternionRotation30 = new THREE.Quaternion();
        quaternionRotation30.setFromUnitVectors(initialNormal30, normalVec30);

        ringMesh30.setRotationFromQuaternion(quaternionRotation30);

        return quaternionRotation30;
    }

    ringRoot.add(ringMesh30);
            
	var inradius31 = calulateInradius(getVertex3(), getVertex98(), getVertex99());
	var incenter31 = calulateIncenter(getVertex3(), getVertex98(), getVertex99());
	var ringGeometry31 = new THREE.RingGeometry((inradius31 - 0.005),inradius31, 32);
	const ringMaterial31 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh31 = new THREE.Mesh(ringGeometry31, ringMaterial31);

	function setCircleRotation31(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.11764705882352944],[0.,0.,0.10784313725490202]);

        ringMesh31.position.setX(incenter[0]);
        ringMesh31.position.setY(incenter[1]);
        ringMesh31.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex98(), getVertex99());
        var relRadius = inradius/inradius31;

        ringMesh31.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A31 = new THREE.Vector3(-1.,0.,0.);
        const B31 = new THREE.Vector3(0.,0.,0.11764705882352944);
        const C31 = new THREE.Vector3(0.,0.,0.10784313725490202);

        const normalVec31 = new THREE.Vector3();
        normalVec31.crossVectors(B31.sub(A31), C31.sub(A31));
        normalVec31.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal31 = new THREE.Vector3(0,0,1);

        const quaternionRotation31 = new THREE.Quaternion();
        quaternionRotation31.setFromUnitVectors(initialNormal31, normalVec31);

        ringMesh31.setRotationFromQuaternion(quaternionRotation31);

        return quaternionRotation31;
    }

    ringRoot.add(ringMesh31);
            
	var inradius32 = calulateInradius(getVertex4(), getVertex19(), getVertex20());
	var incenter32 = calulateIncenter(getVertex4(), getVertex19(), getVertex20());
	var ringGeometry32 = new THREE.RingGeometry((inradius32 - 0.005),inradius32, 32);
	const ringMaterial32 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh32 = new THREE.Mesh(ringGeometry32, ringMaterial32);

	function setCircleRotation32(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.89215686274509798],[0.,0.,0.88235294117647056]);

        ringMesh32.position.setX(incenter[0]);
        ringMesh32.position.setY(incenter[1]);
        ringMesh32.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex19(), getVertex20());
        var relRadius = inradius/inradius32;

        ringMesh32.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A32 = new THREE.Vector3(-1.,0.,1.);
        const B32 = new THREE.Vector3(0.,0.,0.89215686274509798);
        const C32 = new THREE.Vector3(0.,0.,0.88235294117647056);

        const normalVec32 = new THREE.Vector3();
        normalVec32.crossVectors(B32.sub(A32), C32.sub(A32));
        normalVec32.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal32 = new THREE.Vector3(0,0,1);

        const quaternionRotation32 = new THREE.Quaternion();
        quaternionRotation32.setFromUnitVectors(initialNormal32, normalVec32);

        ringMesh32.setRotationFromQuaternion(quaternionRotation32);

        return quaternionRotation32;
    }

    ringRoot.add(ringMesh32);
            
	var inradius33 = calulateInradius(getVertex3(), getVertex97(), getVertex98());
	var incenter33 = calulateIncenter(getVertex3(), getVertex97(), getVertex98());
	var ringGeometry33 = new THREE.RingGeometry((inradius33 - 0.005),inradius33, 32);
	const ringMaterial33 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh33 = new THREE.Mesh(ringGeometry33, ringMaterial33);

	function setCircleRotation33(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.12745098039215685],[0.,0.,0.11764705882352944]);

        ringMesh33.position.setX(incenter[0]);
        ringMesh33.position.setY(incenter[1]);
        ringMesh33.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex97(), getVertex98());
        var relRadius = inradius/inradius33;

        ringMesh33.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A33 = new THREE.Vector3(-1.,0.,0.);
        const B33 = new THREE.Vector3(0.,0.,0.12745098039215685);
        const C33 = new THREE.Vector3(0.,0.,0.11764705882352944);

        const normalVec33 = new THREE.Vector3();
        normalVec33.crossVectors(B33.sub(A33), C33.sub(A33));
        normalVec33.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal33 = new THREE.Vector3(0,0,1);

        const quaternionRotation33 = new THREE.Quaternion();
        quaternionRotation33.setFromUnitVectors(initialNormal33, normalVec33);

        ringMesh33.setRotationFromQuaternion(quaternionRotation33);

        return quaternionRotation33;
    }

    ringRoot.add(ringMesh33);
            
	var inradius34 = calulateInradius(getVertex4(), getVertex20(), getVertex21());
	var incenter34 = calulateIncenter(getVertex4(), getVertex20(), getVertex21());
	var ringGeometry34 = new THREE.RingGeometry((inradius34 - 0.005),inradius34, 32);
	const ringMaterial34 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh34 = new THREE.Mesh(ringGeometry34, ringMaterial34);

	function setCircleRotation34(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.88235294117647056],[0.,0.,0.87254901960784315]);

        ringMesh34.position.setX(incenter[0]);
        ringMesh34.position.setY(incenter[1]);
        ringMesh34.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex20(), getVertex21());
        var relRadius = inradius/inradius34;

        ringMesh34.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A34 = new THREE.Vector3(-1.,0.,1.);
        const B34 = new THREE.Vector3(0.,0.,0.88235294117647056);
        const C34 = new THREE.Vector3(0.,0.,0.87254901960784315);

        const normalVec34 = new THREE.Vector3();
        normalVec34.crossVectors(B34.sub(A34), C34.sub(A34));
        normalVec34.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal34 = new THREE.Vector3(0,0,1);

        const quaternionRotation34 = new THREE.Quaternion();
        quaternionRotation34.setFromUnitVectors(initialNormal34, normalVec34);

        ringMesh34.setRotationFromQuaternion(quaternionRotation34);

        return quaternionRotation34;
    }

    ringRoot.add(ringMesh34);
            
	var inradius35 = calulateInradius(getVertex3(), getVertex96(), getVertex97());
	var incenter35 = calulateIncenter(getVertex3(), getVertex96(), getVertex97());
	var ringGeometry35 = new THREE.RingGeometry((inradius35 - 0.005),inradius35, 32);
	const ringMaterial35 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh35 = new THREE.Mesh(ringGeometry35, ringMaterial35);

	function setCircleRotation35(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.13725490196078427],[0.,0.,0.12745098039215685]);

        ringMesh35.position.setX(incenter[0]);
        ringMesh35.position.setY(incenter[1]);
        ringMesh35.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex96(), getVertex97());
        var relRadius = inradius/inradius35;

        ringMesh35.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A35 = new THREE.Vector3(-1.,0.,0.);
        const B35 = new THREE.Vector3(0.,0.,0.13725490196078427);
        const C35 = new THREE.Vector3(0.,0.,0.12745098039215685);

        const normalVec35 = new THREE.Vector3();
        normalVec35.crossVectors(B35.sub(A35), C35.sub(A35));
        normalVec35.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal35 = new THREE.Vector3(0,0,1);

        const quaternionRotation35 = new THREE.Quaternion();
        quaternionRotation35.setFromUnitVectors(initialNormal35, normalVec35);

        ringMesh35.setRotationFromQuaternion(quaternionRotation35);

        return quaternionRotation35;
    }

    ringRoot.add(ringMesh35);
            
	var inradius36 = calulateInradius(getVertex4(), getVertex21(), getVertex22());
	var incenter36 = calulateIncenter(getVertex4(), getVertex21(), getVertex22());
	var ringGeometry36 = new THREE.RingGeometry((inradius36 - 0.005),inradius36, 32);
	const ringMaterial36 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh36 = new THREE.Mesh(ringGeometry36, ringMaterial36);

	function setCircleRotation36(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.87254901960784315],[0.,0.,0.86274509803921573]);

        ringMesh36.position.setX(incenter[0]);
        ringMesh36.position.setY(incenter[1]);
        ringMesh36.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex21(), getVertex22());
        var relRadius = inradius/inradius36;

        ringMesh36.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A36 = new THREE.Vector3(-1.,0.,1.);
        const B36 = new THREE.Vector3(0.,0.,0.87254901960784315);
        const C36 = new THREE.Vector3(0.,0.,0.86274509803921573);

        const normalVec36 = new THREE.Vector3();
        normalVec36.crossVectors(B36.sub(A36), C36.sub(A36));
        normalVec36.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal36 = new THREE.Vector3(0,0,1);

        const quaternionRotation36 = new THREE.Quaternion();
        quaternionRotation36.setFromUnitVectors(initialNormal36, normalVec36);

        ringMesh36.setRotationFromQuaternion(quaternionRotation36);

        return quaternionRotation36;
    }

    ringRoot.add(ringMesh36);
            
	var inradius37 = calulateInradius(getVertex3(), getVertex95(), getVertex96());
	var incenter37 = calulateIncenter(getVertex3(), getVertex95(), getVertex96());
	var ringGeometry37 = new THREE.RingGeometry((inradius37 - 0.005),inradius37, 32);
	const ringMaterial37 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh37 = new THREE.Mesh(ringGeometry37, ringMaterial37);

	function setCircleRotation37(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.1470588235294118],[0.,0.,0.13725490196078427]);

        ringMesh37.position.setX(incenter[0]);
        ringMesh37.position.setY(incenter[1]);
        ringMesh37.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex95(), getVertex96());
        var relRadius = inradius/inradius37;

        ringMesh37.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A37 = new THREE.Vector3(-1.,0.,0.);
        const B37 = new THREE.Vector3(0.,0.,0.1470588235294118);
        const C37 = new THREE.Vector3(0.,0.,0.13725490196078427);

        const normalVec37 = new THREE.Vector3();
        normalVec37.crossVectors(B37.sub(A37), C37.sub(A37));
        normalVec37.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal37 = new THREE.Vector3(0,0,1);

        const quaternionRotation37 = new THREE.Quaternion();
        quaternionRotation37.setFromUnitVectors(initialNormal37, normalVec37);

        ringMesh37.setRotationFromQuaternion(quaternionRotation37);

        return quaternionRotation37;
    }

    ringRoot.add(ringMesh37);
            
	var inradius38 = calulateInradius(getVertex4(), getVertex22(), getVertex23());
	var incenter38 = calulateIncenter(getVertex4(), getVertex22(), getVertex23());
	var ringGeometry38 = new THREE.RingGeometry((inradius38 - 0.005),inradius38, 32);
	const ringMaterial38 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh38 = new THREE.Mesh(ringGeometry38, ringMaterial38);

	function setCircleRotation38(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.86274509803921573],[0.,0.,0.8529411764705882]);

        ringMesh38.position.setX(incenter[0]);
        ringMesh38.position.setY(incenter[1]);
        ringMesh38.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex22(), getVertex23());
        var relRadius = inradius/inradius38;

        ringMesh38.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A38 = new THREE.Vector3(-1.,0.,1.);
        const B38 = new THREE.Vector3(0.,0.,0.86274509803921573);
        const C38 = new THREE.Vector3(0.,0.,0.8529411764705882);

        const normalVec38 = new THREE.Vector3();
        normalVec38.crossVectors(B38.sub(A38), C38.sub(A38));
        normalVec38.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal38 = new THREE.Vector3(0,0,1);

        const quaternionRotation38 = new THREE.Quaternion();
        quaternionRotation38.setFromUnitVectors(initialNormal38, normalVec38);

        ringMesh38.setRotationFromQuaternion(quaternionRotation38);

        return quaternionRotation38;
    }

    ringRoot.add(ringMesh38);
            
	var inradius39 = calulateInradius(getVertex3(), getVertex94(), getVertex95());
	var incenter39 = calulateIncenter(getVertex3(), getVertex94(), getVertex95());
	var ringGeometry39 = new THREE.RingGeometry((inradius39 - 0.005),inradius39, 32);
	const ringMaterial39 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh39 = new THREE.Mesh(ringGeometry39, ringMaterial39);

	function setCircleRotation39(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.15686274509803921],[0.,0.,0.1470588235294118]);

        ringMesh39.position.setX(incenter[0]);
        ringMesh39.position.setY(incenter[1]);
        ringMesh39.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex94(), getVertex95());
        var relRadius = inradius/inradius39;

        ringMesh39.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A39 = new THREE.Vector3(-1.,0.,0.);
        const B39 = new THREE.Vector3(0.,0.,0.15686274509803921);
        const C39 = new THREE.Vector3(0.,0.,0.1470588235294118);

        const normalVec39 = new THREE.Vector3();
        normalVec39.crossVectors(B39.sub(A39), C39.sub(A39));
        normalVec39.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal39 = new THREE.Vector3(0,0,1);

        const quaternionRotation39 = new THREE.Quaternion();
        quaternionRotation39.setFromUnitVectors(initialNormal39, normalVec39);

        ringMesh39.setRotationFromQuaternion(quaternionRotation39);

        return quaternionRotation39;
    }

    ringRoot.add(ringMesh39);
            
	var inradius40 = calulateInradius(getVertex4(), getVertex23(), getVertex24());
	var incenter40 = calulateIncenter(getVertex4(), getVertex23(), getVertex24());
	var ringGeometry40 = new THREE.RingGeometry((inradius40 - 0.005),inradius40, 32);
	const ringMaterial40 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh40 = new THREE.Mesh(ringGeometry40, ringMaterial40);

	function setCircleRotation40(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.8529411764705882],[0.,0.,0.84313725490196079]);

        ringMesh40.position.setX(incenter[0]);
        ringMesh40.position.setY(incenter[1]);
        ringMesh40.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex23(), getVertex24());
        var relRadius = inradius/inradius40;

        ringMesh40.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A40 = new THREE.Vector3(-1.,0.,1.);
        const B40 = new THREE.Vector3(0.,0.,0.8529411764705882);
        const C40 = new THREE.Vector3(0.,0.,0.84313725490196079);

        const normalVec40 = new THREE.Vector3();
        normalVec40.crossVectors(B40.sub(A40), C40.sub(A40));
        normalVec40.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal40 = new THREE.Vector3(0,0,1);

        const quaternionRotation40 = new THREE.Quaternion();
        quaternionRotation40.setFromUnitVectors(initialNormal40, normalVec40);

        ringMesh40.setRotationFromQuaternion(quaternionRotation40);

        return quaternionRotation40;
    }

    ringRoot.add(ringMesh40);
            
	var inradius41 = calulateInradius(getVertex3(), getVertex93(), getVertex94());
	var incenter41 = calulateIncenter(getVertex3(), getVertex93(), getVertex94());
	var ringGeometry41 = new THREE.RingGeometry((inradius41 - 0.005),inradius41, 32);
	const ringMaterial41 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh41 = new THREE.Mesh(ringGeometry41, ringMaterial41);

	function setCircleRotation41(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.16666666666666663],[0.,0.,0.15686274509803921]);

        ringMesh41.position.setX(incenter[0]);
        ringMesh41.position.setY(incenter[1]);
        ringMesh41.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex93(), getVertex94());
        var relRadius = inradius/inradius41;

        ringMesh41.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A41 = new THREE.Vector3(-1.,0.,0.);
        const B41 = new THREE.Vector3(0.,0.,0.16666666666666663);
        const C41 = new THREE.Vector3(0.,0.,0.15686274509803921);

        const normalVec41 = new THREE.Vector3();
        normalVec41.crossVectors(B41.sub(A41), C41.sub(A41));
        normalVec41.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal41 = new THREE.Vector3(0,0,1);

        const quaternionRotation41 = new THREE.Quaternion();
        quaternionRotation41.setFromUnitVectors(initialNormal41, normalVec41);

        ringMesh41.setRotationFromQuaternion(quaternionRotation41);

        return quaternionRotation41;
    }

    ringRoot.add(ringMesh41);
            
	var inradius42 = calulateInradius(getVertex4(), getVertex24(), getVertex25());
	var incenter42 = calulateIncenter(getVertex4(), getVertex24(), getVertex25());
	var ringGeometry42 = new THREE.RingGeometry((inradius42 - 0.005),inradius42, 32);
	const ringMaterial42 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh42 = new THREE.Mesh(ringGeometry42, ringMaterial42);

	function setCircleRotation42(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.84313725490196079],[0.,0.,0.83333333333333337]);

        ringMesh42.position.setX(incenter[0]);
        ringMesh42.position.setY(incenter[1]);
        ringMesh42.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex24(), getVertex25());
        var relRadius = inradius/inradius42;

        ringMesh42.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A42 = new THREE.Vector3(-1.,0.,1.);
        const B42 = new THREE.Vector3(0.,0.,0.84313725490196079);
        const C42 = new THREE.Vector3(0.,0.,0.83333333333333337);

        const normalVec42 = new THREE.Vector3();
        normalVec42.crossVectors(B42.sub(A42), C42.sub(A42));
        normalVec42.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal42 = new THREE.Vector3(0,0,1);

        const quaternionRotation42 = new THREE.Quaternion();
        quaternionRotation42.setFromUnitVectors(initialNormal42, normalVec42);

        ringMesh42.setRotationFromQuaternion(quaternionRotation42);

        return quaternionRotation42;
    }

    ringRoot.add(ringMesh42);
            
	var inradius43 = calulateInradius(getVertex3(), getVertex92(), getVertex93());
	var incenter43 = calulateIncenter(getVertex3(), getVertex92(), getVertex93());
	var ringGeometry43 = new THREE.RingGeometry((inradius43 - 0.005),inradius43, 32);
	const ringMaterial43 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh43 = new THREE.Mesh(ringGeometry43, ringMaterial43);

	function setCircleRotation43(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.17647058823529416],[0.,0.,0.16666666666666663]);

        ringMesh43.position.setX(incenter[0]);
        ringMesh43.position.setY(incenter[1]);
        ringMesh43.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex92(), getVertex93());
        var relRadius = inradius/inradius43;

        ringMesh43.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A43 = new THREE.Vector3(-1.,0.,0.);
        const B43 = new THREE.Vector3(0.,0.,0.17647058823529416);
        const C43 = new THREE.Vector3(0.,0.,0.16666666666666663);

        const normalVec43 = new THREE.Vector3();
        normalVec43.crossVectors(B43.sub(A43), C43.sub(A43));
        normalVec43.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal43 = new THREE.Vector3(0,0,1);

        const quaternionRotation43 = new THREE.Quaternion();
        quaternionRotation43.setFromUnitVectors(initialNormal43, normalVec43);

        ringMesh43.setRotationFromQuaternion(quaternionRotation43);

        return quaternionRotation43;
    }

    ringRoot.add(ringMesh43);
            
	var inradius44 = calulateInradius(getVertex4(), getVertex25(), getVertex26());
	var incenter44 = calulateIncenter(getVertex4(), getVertex25(), getVertex26());
	var ringGeometry44 = new THREE.RingGeometry((inradius44 - 0.005),inradius44, 32);
	const ringMaterial44 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh44 = new THREE.Mesh(ringGeometry44, ringMaterial44);

	function setCircleRotation44(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.83333333333333337],[0.,0.,0.82352941176470584]);

        ringMesh44.position.setX(incenter[0]);
        ringMesh44.position.setY(incenter[1]);
        ringMesh44.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex25(), getVertex26());
        var relRadius = inradius/inradius44;

        ringMesh44.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A44 = new THREE.Vector3(-1.,0.,1.);
        const B44 = new THREE.Vector3(0.,0.,0.83333333333333337);
        const C44 = new THREE.Vector3(0.,0.,0.82352941176470584);

        const normalVec44 = new THREE.Vector3();
        normalVec44.crossVectors(B44.sub(A44), C44.sub(A44));
        normalVec44.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal44 = new THREE.Vector3(0,0,1);

        const quaternionRotation44 = new THREE.Quaternion();
        quaternionRotation44.setFromUnitVectors(initialNormal44, normalVec44);

        ringMesh44.setRotationFromQuaternion(quaternionRotation44);

        return quaternionRotation44;
    }

    ringRoot.add(ringMesh44);
            
	var inradius45 = calulateInradius(getVertex3(), getVertex91(), getVertex92());
	var incenter45 = calulateIncenter(getVertex3(), getVertex91(), getVertex92());
	var ringGeometry45 = new THREE.RingGeometry((inradius45 - 0.005),inradius45, 32);
	const ringMaterial45 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh45 = new THREE.Mesh(ringGeometry45, ringMaterial45);

	function setCircleRotation45(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.18627450980392157],[0.,0.,0.17647058823529416]);

        ringMesh45.position.setX(incenter[0]);
        ringMesh45.position.setY(incenter[1]);
        ringMesh45.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex91(), getVertex92());
        var relRadius = inradius/inradius45;

        ringMesh45.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A45 = new THREE.Vector3(-1.,0.,0.);
        const B45 = new THREE.Vector3(0.,0.,0.18627450980392157);
        const C45 = new THREE.Vector3(0.,0.,0.17647058823529416);

        const normalVec45 = new THREE.Vector3();
        normalVec45.crossVectors(B45.sub(A45), C45.sub(A45));
        normalVec45.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal45 = new THREE.Vector3(0,0,1);

        const quaternionRotation45 = new THREE.Quaternion();
        quaternionRotation45.setFromUnitVectors(initialNormal45, normalVec45);

        ringMesh45.setRotationFromQuaternion(quaternionRotation45);

        return quaternionRotation45;
    }

    ringRoot.add(ringMesh45);
            
	var inradius46 = calulateInradius(getVertex4(), getVertex26(), getVertex27());
	var incenter46 = calulateIncenter(getVertex4(), getVertex26(), getVertex27());
	var ringGeometry46 = new THREE.RingGeometry((inradius46 - 0.005),inradius46, 32);
	const ringMaterial46 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh46 = new THREE.Mesh(ringGeometry46, ringMaterial46);

	function setCircleRotation46(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.82352941176470584],[0.,0.,0.81372549019607843]);

        ringMesh46.position.setX(incenter[0]);
        ringMesh46.position.setY(incenter[1]);
        ringMesh46.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex26(), getVertex27());
        var relRadius = inradius/inradius46;

        ringMesh46.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A46 = new THREE.Vector3(-1.,0.,1.);
        const B46 = new THREE.Vector3(0.,0.,0.82352941176470584);
        const C46 = new THREE.Vector3(0.,0.,0.81372549019607843);

        const normalVec46 = new THREE.Vector3();
        normalVec46.crossVectors(B46.sub(A46), C46.sub(A46));
        normalVec46.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal46 = new THREE.Vector3(0,0,1);

        const quaternionRotation46 = new THREE.Quaternion();
        quaternionRotation46.setFromUnitVectors(initialNormal46, normalVec46);

        ringMesh46.setRotationFromQuaternion(quaternionRotation46);

        return quaternionRotation46;
    }

    ringRoot.add(ringMesh46);
            
	var inradius47 = calulateInradius(getVertex3(), getVertex90(), getVertex91());
	var incenter47 = calulateIncenter(getVertex3(), getVertex90(), getVertex91());
	var ringGeometry47 = new THREE.RingGeometry((inradius47 - 0.005),inradius47, 32);
	const ringMaterial47 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh47 = new THREE.Mesh(ringGeometry47, ringMaterial47);

	function setCircleRotation47(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.19607843137254899],[0.,0.,0.18627450980392157]);

        ringMesh47.position.setX(incenter[0]);
        ringMesh47.position.setY(incenter[1]);
        ringMesh47.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex90(), getVertex91());
        var relRadius = inradius/inradius47;

        ringMesh47.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A47 = new THREE.Vector3(-1.,0.,0.);
        const B47 = new THREE.Vector3(0.,0.,0.19607843137254899);
        const C47 = new THREE.Vector3(0.,0.,0.18627450980392157);

        const normalVec47 = new THREE.Vector3();
        normalVec47.crossVectors(B47.sub(A47), C47.sub(A47));
        normalVec47.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal47 = new THREE.Vector3(0,0,1);

        const quaternionRotation47 = new THREE.Quaternion();
        quaternionRotation47.setFromUnitVectors(initialNormal47, normalVec47);

        ringMesh47.setRotationFromQuaternion(quaternionRotation47);

        return quaternionRotation47;
    }

    ringRoot.add(ringMesh47);
            
	var inradius48 = calulateInradius(getVertex4(), getVertex27(), getVertex28());
	var incenter48 = calulateIncenter(getVertex4(), getVertex27(), getVertex28());
	var ringGeometry48 = new THREE.RingGeometry((inradius48 - 0.005),inradius48, 32);
	const ringMaterial48 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh48 = new THREE.Mesh(ringGeometry48, ringMaterial48);

	function setCircleRotation48(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.81372549019607843],[0.,0.,0.80392156862745101]);

        ringMesh48.position.setX(incenter[0]);
        ringMesh48.position.setY(incenter[1]);
        ringMesh48.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex27(), getVertex28());
        var relRadius = inradius/inradius48;

        ringMesh48.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A48 = new THREE.Vector3(-1.,0.,1.);
        const B48 = new THREE.Vector3(0.,0.,0.81372549019607843);
        const C48 = new THREE.Vector3(0.,0.,0.80392156862745101);

        const normalVec48 = new THREE.Vector3();
        normalVec48.crossVectors(B48.sub(A48), C48.sub(A48));
        normalVec48.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal48 = new THREE.Vector3(0,0,1);

        const quaternionRotation48 = new THREE.Quaternion();
        quaternionRotation48.setFromUnitVectors(initialNormal48, normalVec48);

        ringMesh48.setRotationFromQuaternion(quaternionRotation48);

        return quaternionRotation48;
    }

    ringRoot.add(ringMesh48);
            
	var inradius49 = calulateInradius(getVertex3(), getVertex89(), getVertex90());
	var incenter49 = calulateIncenter(getVertex3(), getVertex89(), getVertex90());
	var ringGeometry49 = new THREE.RingGeometry((inradius49 - 0.005),inradius49, 32);
	const ringMaterial49 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh49 = new THREE.Mesh(ringGeometry49, ringMaterial49);

	function setCircleRotation49(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.20588235294117652],[0.,0.,0.19607843137254899]);

        ringMesh49.position.setX(incenter[0]);
        ringMesh49.position.setY(incenter[1]);
        ringMesh49.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex89(), getVertex90());
        var relRadius = inradius/inradius49;

        ringMesh49.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A49 = new THREE.Vector3(-1.,0.,0.);
        const B49 = new THREE.Vector3(0.,0.,0.20588235294117652);
        const C49 = new THREE.Vector3(0.,0.,0.19607843137254899);

        const normalVec49 = new THREE.Vector3();
        normalVec49.crossVectors(B49.sub(A49), C49.sub(A49));
        normalVec49.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal49 = new THREE.Vector3(0,0,1);

        const quaternionRotation49 = new THREE.Quaternion();
        quaternionRotation49.setFromUnitVectors(initialNormal49, normalVec49);

        ringMesh49.setRotationFromQuaternion(quaternionRotation49);

        return quaternionRotation49;
    }

    ringRoot.add(ringMesh49);
            
	var inradius50 = calulateInradius(getVertex4(), getVertex28(), getVertex29());
	var incenter50 = calulateIncenter(getVertex4(), getVertex28(), getVertex29());
	var ringGeometry50 = new THREE.RingGeometry((inradius50 - 0.005),inradius50, 32);
	const ringMaterial50 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh50 = new THREE.Mesh(ringGeometry50, ringMaterial50);

	function setCircleRotation50(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.80392156862745101],[0.,0.,0.79411764705882359]);

        ringMesh50.position.setX(incenter[0]);
        ringMesh50.position.setY(incenter[1]);
        ringMesh50.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex28(), getVertex29());
        var relRadius = inradius/inradius50;

        ringMesh50.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A50 = new THREE.Vector3(-1.,0.,1.);
        const B50 = new THREE.Vector3(0.,0.,0.80392156862745101);
        const C50 = new THREE.Vector3(0.,0.,0.79411764705882359);

        const normalVec50 = new THREE.Vector3();
        normalVec50.crossVectors(B50.sub(A50), C50.sub(A50));
        normalVec50.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal50 = new THREE.Vector3(0,0,1);

        const quaternionRotation50 = new THREE.Quaternion();
        quaternionRotation50.setFromUnitVectors(initialNormal50, normalVec50);

        ringMesh50.setRotationFromQuaternion(quaternionRotation50);

        return quaternionRotation50;
    }

    ringRoot.add(ringMesh50);
            
	var inradius51 = calulateInradius(getVertex3(), getVertex88(), getVertex89());
	var incenter51 = calulateIncenter(getVertex3(), getVertex88(), getVertex89());
	var ringGeometry51 = new THREE.RingGeometry((inradius51 - 0.005),inradius51, 32);
	const ringMaterial51 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh51 = new THREE.Mesh(ringGeometry51, ringMaterial51);

	function setCircleRotation51(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.21568627450980393],[0.,0.,0.20588235294117652]);

        ringMesh51.position.setX(incenter[0]);
        ringMesh51.position.setY(incenter[1]);
        ringMesh51.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex88(), getVertex89());
        var relRadius = inradius/inradius51;

        ringMesh51.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A51 = new THREE.Vector3(-1.,0.,0.);
        const B51 = new THREE.Vector3(0.,0.,0.21568627450980393);
        const C51 = new THREE.Vector3(0.,0.,0.20588235294117652);

        const normalVec51 = new THREE.Vector3();
        normalVec51.crossVectors(B51.sub(A51), C51.sub(A51));
        normalVec51.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal51 = new THREE.Vector3(0,0,1);

        const quaternionRotation51 = new THREE.Quaternion();
        quaternionRotation51.setFromUnitVectors(initialNormal51, normalVec51);

        ringMesh51.setRotationFromQuaternion(quaternionRotation51);

        return quaternionRotation51;
    }

    ringRoot.add(ringMesh51);
            
	var inradius52 = calulateInradius(getVertex4(), getVertex29(), getVertex30());
	var incenter52 = calulateIncenter(getVertex4(), getVertex29(), getVertex30());
	var ringGeometry52 = new THREE.RingGeometry((inradius52 - 0.005),inradius52, 32);
	const ringMaterial52 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh52 = new THREE.Mesh(ringGeometry52, ringMaterial52);

	function setCircleRotation52(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.79411764705882359],[0.,0.,0.78431372549019607]);

        ringMesh52.position.setX(incenter[0]);
        ringMesh52.position.setY(incenter[1]);
        ringMesh52.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex29(), getVertex30());
        var relRadius = inradius/inradius52;

        ringMesh52.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A52 = new THREE.Vector3(-1.,0.,1.);
        const B52 = new THREE.Vector3(0.,0.,0.79411764705882359);
        const C52 = new THREE.Vector3(0.,0.,0.78431372549019607);

        const normalVec52 = new THREE.Vector3();
        normalVec52.crossVectors(B52.sub(A52), C52.sub(A52));
        normalVec52.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal52 = new THREE.Vector3(0,0,1);

        const quaternionRotation52 = new THREE.Quaternion();
        quaternionRotation52.setFromUnitVectors(initialNormal52, normalVec52);

        ringMesh52.setRotationFromQuaternion(quaternionRotation52);

        return quaternionRotation52;
    }

    ringRoot.add(ringMesh52);
            
	var inradius53 = calulateInradius(getVertex3(), getVertex87(), getVertex88());
	var incenter53 = calulateIncenter(getVertex3(), getVertex87(), getVertex88());
	var ringGeometry53 = new THREE.RingGeometry((inradius53 - 0.005),inradius53, 32);
	const ringMaterial53 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh53 = new THREE.Mesh(ringGeometry53, ringMaterial53);

	function setCircleRotation53(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.22549019607843135],[0.,0.,0.21568627450980393]);

        ringMesh53.position.setX(incenter[0]);
        ringMesh53.position.setY(incenter[1]);
        ringMesh53.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex87(), getVertex88());
        var relRadius = inradius/inradius53;

        ringMesh53.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A53 = new THREE.Vector3(-1.,0.,0.);
        const B53 = new THREE.Vector3(0.,0.,0.22549019607843135);
        const C53 = new THREE.Vector3(0.,0.,0.21568627450980393);

        const normalVec53 = new THREE.Vector3();
        normalVec53.crossVectors(B53.sub(A53), C53.sub(A53));
        normalVec53.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal53 = new THREE.Vector3(0,0,1);

        const quaternionRotation53 = new THREE.Quaternion();
        quaternionRotation53.setFromUnitVectors(initialNormal53, normalVec53);

        ringMesh53.setRotationFromQuaternion(quaternionRotation53);

        return quaternionRotation53;
    }

    ringRoot.add(ringMesh53);
            
	var inradius54 = calulateInradius(getVertex4(), getVertex30(), getVertex31());
	var incenter54 = calulateIncenter(getVertex4(), getVertex30(), getVertex31());
	var ringGeometry54 = new THREE.RingGeometry((inradius54 - 0.005),inradius54, 32);
	const ringMaterial54 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh54 = new THREE.Mesh(ringGeometry54, ringMaterial54);

	function setCircleRotation54(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.78431372549019607],[0.,0.,0.77450980392156865]);

        ringMesh54.position.setX(incenter[0]);
        ringMesh54.position.setY(incenter[1]);
        ringMesh54.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex30(), getVertex31());
        var relRadius = inradius/inradius54;

        ringMesh54.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A54 = new THREE.Vector3(-1.,0.,1.);
        const B54 = new THREE.Vector3(0.,0.,0.78431372549019607);
        const C54 = new THREE.Vector3(0.,0.,0.77450980392156865);

        const normalVec54 = new THREE.Vector3();
        normalVec54.crossVectors(B54.sub(A54), C54.sub(A54));
        normalVec54.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal54 = new THREE.Vector3(0,0,1);

        const quaternionRotation54 = new THREE.Quaternion();
        quaternionRotation54.setFromUnitVectors(initialNormal54, normalVec54);

        ringMesh54.setRotationFromQuaternion(quaternionRotation54);

        return quaternionRotation54;
    }

    ringRoot.add(ringMesh54);
            
	var inradius55 = calulateInradius(getVertex3(), getVertex86(), getVertex87());
	var incenter55 = calulateIncenter(getVertex3(), getVertex86(), getVertex87());
	var ringGeometry55 = new THREE.RingGeometry((inradius55 - 0.005),inradius55, 32);
	const ringMaterial55 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh55 = new THREE.Mesh(ringGeometry55, ringMaterial55);

	function setCircleRotation55(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.23529411764705888],[0.,0.,0.22549019607843135]);

        ringMesh55.position.setX(incenter[0]);
        ringMesh55.position.setY(incenter[1]);
        ringMesh55.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex86(), getVertex87());
        var relRadius = inradius/inradius55;

        ringMesh55.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A55 = new THREE.Vector3(-1.,0.,0.);
        const B55 = new THREE.Vector3(0.,0.,0.23529411764705888);
        const C55 = new THREE.Vector3(0.,0.,0.22549019607843135);

        const normalVec55 = new THREE.Vector3();
        normalVec55.crossVectors(B55.sub(A55), C55.sub(A55));
        normalVec55.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal55 = new THREE.Vector3(0,0,1);

        const quaternionRotation55 = new THREE.Quaternion();
        quaternionRotation55.setFromUnitVectors(initialNormal55, normalVec55);

        ringMesh55.setRotationFromQuaternion(quaternionRotation55);

        return quaternionRotation55;
    }

    ringRoot.add(ringMesh55);
            
	var inradius56 = calulateInradius(getVertex4(), getVertex31(), getVertex32());
	var incenter56 = calulateIncenter(getVertex4(), getVertex31(), getVertex32());
	var ringGeometry56 = new THREE.RingGeometry((inradius56 - 0.005),inradius56, 32);
	const ringMaterial56 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh56 = new THREE.Mesh(ringGeometry56, ringMaterial56);

	function setCircleRotation56(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.77450980392156865],[0.,0.,0.76470588235294112]);

        ringMesh56.position.setX(incenter[0]);
        ringMesh56.position.setY(incenter[1]);
        ringMesh56.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex31(), getVertex32());
        var relRadius = inradius/inradius56;

        ringMesh56.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A56 = new THREE.Vector3(-1.,0.,1.);
        const B56 = new THREE.Vector3(0.,0.,0.77450980392156865);
        const C56 = new THREE.Vector3(0.,0.,0.76470588235294112);

        const normalVec56 = new THREE.Vector3();
        normalVec56.crossVectors(B56.sub(A56), C56.sub(A56));
        normalVec56.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal56 = new THREE.Vector3(0,0,1);

        const quaternionRotation56 = new THREE.Quaternion();
        quaternionRotation56.setFromUnitVectors(initialNormal56, normalVec56);

        ringMesh56.setRotationFromQuaternion(quaternionRotation56);

        return quaternionRotation56;
    }

    ringRoot.add(ringMesh56);
            
	var inradius57 = calulateInradius(getVertex3(), getVertex85(), getVertex86());
	var incenter57 = calulateIncenter(getVertex3(), getVertex85(), getVertex86());
	var ringGeometry57 = new THREE.RingGeometry((inradius57 - 0.005),inradius57, 32);
	const ringMaterial57 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh57 = new THREE.Mesh(ringGeometry57, ringMaterial57);

	function setCircleRotation57(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.24509803921568629],[0.,0.,0.23529411764705888]);

        ringMesh57.position.setX(incenter[0]);
        ringMesh57.position.setY(incenter[1]);
        ringMesh57.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex85(), getVertex86());
        var relRadius = inradius/inradius57;

        ringMesh57.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A57 = new THREE.Vector3(-1.,0.,0.);
        const B57 = new THREE.Vector3(0.,0.,0.24509803921568629);
        const C57 = new THREE.Vector3(0.,0.,0.23529411764705888);

        const normalVec57 = new THREE.Vector3();
        normalVec57.crossVectors(B57.sub(A57), C57.sub(A57));
        normalVec57.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal57 = new THREE.Vector3(0,0,1);

        const quaternionRotation57 = new THREE.Quaternion();
        quaternionRotation57.setFromUnitVectors(initialNormal57, normalVec57);

        ringMesh57.setRotationFromQuaternion(quaternionRotation57);

        return quaternionRotation57;
    }

    ringRoot.add(ringMesh57);
            
	var inradius58 = calulateInradius(getVertex4(), getVertex32(), getVertex33());
	var incenter58 = calulateIncenter(getVertex4(), getVertex32(), getVertex33());
	var ringGeometry58 = new THREE.RingGeometry((inradius58 - 0.005),inradius58, 32);
	const ringMaterial58 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh58 = new THREE.Mesh(ringGeometry58, ringMaterial58);

	function setCircleRotation58(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.76470588235294112],[0.,0.,0.75490196078431371]);

        ringMesh58.position.setX(incenter[0]);
        ringMesh58.position.setY(incenter[1]);
        ringMesh58.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex32(), getVertex33());
        var relRadius = inradius/inradius58;

        ringMesh58.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A58 = new THREE.Vector3(-1.,0.,1.);
        const B58 = new THREE.Vector3(0.,0.,0.76470588235294112);
        const C58 = new THREE.Vector3(0.,0.,0.75490196078431371);

        const normalVec58 = new THREE.Vector3();
        normalVec58.crossVectors(B58.sub(A58), C58.sub(A58));
        normalVec58.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal58 = new THREE.Vector3(0,0,1);

        const quaternionRotation58 = new THREE.Quaternion();
        quaternionRotation58.setFromUnitVectors(initialNormal58, normalVec58);

        ringMesh58.setRotationFromQuaternion(quaternionRotation58);

        return quaternionRotation58;
    }

    ringRoot.add(ringMesh58);
            
	var inradius59 = calulateInradius(getVertex3(), getVertex84(), getVertex85());
	var incenter59 = calulateIncenter(getVertex3(), getVertex84(), getVertex85());
	var ringGeometry59 = new THREE.RingGeometry((inradius59 - 0.005),inradius59, 32);
	const ringMaterial59 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh59 = new THREE.Mesh(ringGeometry59, ringMaterial59);

	function setCircleRotation59(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.25490196078431371],[0.,0.,0.24509803921568629]);

        ringMesh59.position.setX(incenter[0]);
        ringMesh59.position.setY(incenter[1]);
        ringMesh59.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex84(), getVertex85());
        var relRadius = inradius/inradius59;

        ringMesh59.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A59 = new THREE.Vector3(-1.,0.,0.);
        const B59 = new THREE.Vector3(0.,0.,0.25490196078431371);
        const C59 = new THREE.Vector3(0.,0.,0.24509803921568629);

        const normalVec59 = new THREE.Vector3();
        normalVec59.crossVectors(B59.sub(A59), C59.sub(A59));
        normalVec59.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal59 = new THREE.Vector3(0,0,1);

        const quaternionRotation59 = new THREE.Quaternion();
        quaternionRotation59.setFromUnitVectors(initialNormal59, normalVec59);

        ringMesh59.setRotationFromQuaternion(quaternionRotation59);

        return quaternionRotation59;
    }

    ringRoot.add(ringMesh59);
            
	var inradius60 = calulateInradius(getVertex4(), getVertex33(), getVertex34());
	var incenter60 = calulateIncenter(getVertex4(), getVertex33(), getVertex34());
	var ringGeometry60 = new THREE.RingGeometry((inradius60 - 0.005),inradius60, 32);
	const ringMaterial60 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh60 = new THREE.Mesh(ringGeometry60, ringMaterial60);

	function setCircleRotation60(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.75490196078431371],[0.,0.,0.74509803921568629]);

        ringMesh60.position.setX(incenter[0]);
        ringMesh60.position.setY(incenter[1]);
        ringMesh60.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex33(), getVertex34());
        var relRadius = inradius/inradius60;

        ringMesh60.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A60 = new THREE.Vector3(-1.,0.,1.);
        const B60 = new THREE.Vector3(0.,0.,0.75490196078431371);
        const C60 = new THREE.Vector3(0.,0.,0.74509803921568629);

        const normalVec60 = new THREE.Vector3();
        normalVec60.crossVectors(B60.sub(A60), C60.sub(A60));
        normalVec60.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal60 = new THREE.Vector3(0,0,1);

        const quaternionRotation60 = new THREE.Quaternion();
        quaternionRotation60.setFromUnitVectors(initialNormal60, normalVec60);

        ringMesh60.setRotationFromQuaternion(quaternionRotation60);

        return quaternionRotation60;
    }

    ringRoot.add(ringMesh60);
            
	var inradius61 = calulateInradius(getVertex3(), getVertex83(), getVertex84());
	var incenter61 = calulateIncenter(getVertex3(), getVertex83(), getVertex84());
	var ringGeometry61 = new THREE.RingGeometry((inradius61 - 0.005),inradius61, 32);
	const ringMaterial61 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh61 = new THREE.Mesh(ringGeometry61, ringMaterial61);

	function setCircleRotation61(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.26470588235294124],[0.,0.,0.25490196078431371]);

        ringMesh61.position.setX(incenter[0]);
        ringMesh61.position.setY(incenter[1]);
        ringMesh61.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex83(), getVertex84());
        var relRadius = inradius/inradius61;

        ringMesh61.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A61 = new THREE.Vector3(-1.,0.,0.);
        const B61 = new THREE.Vector3(0.,0.,0.26470588235294124);
        const C61 = new THREE.Vector3(0.,0.,0.25490196078431371);

        const normalVec61 = new THREE.Vector3();
        normalVec61.crossVectors(B61.sub(A61), C61.sub(A61));
        normalVec61.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal61 = new THREE.Vector3(0,0,1);

        const quaternionRotation61 = new THREE.Quaternion();
        quaternionRotation61.setFromUnitVectors(initialNormal61, normalVec61);

        ringMesh61.setRotationFromQuaternion(quaternionRotation61);

        return quaternionRotation61;
    }

    ringRoot.add(ringMesh61);
            
	var inradius62 = calulateInradius(getVertex4(), getVertex34(), getVertex35());
	var incenter62 = calulateIncenter(getVertex4(), getVertex34(), getVertex35());
	var ringGeometry62 = new THREE.RingGeometry((inradius62 - 0.005),inradius62, 32);
	const ringMaterial62 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh62 = new THREE.Mesh(ringGeometry62, ringMaterial62);

	function setCircleRotation62(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.74509803921568629],[0.,0.,0.73529411764705888]);

        ringMesh62.position.setX(incenter[0]);
        ringMesh62.position.setY(incenter[1]);
        ringMesh62.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex34(), getVertex35());
        var relRadius = inradius/inradius62;

        ringMesh62.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A62 = new THREE.Vector3(-1.,0.,1.);
        const B62 = new THREE.Vector3(0.,0.,0.74509803921568629);
        const C62 = new THREE.Vector3(0.,0.,0.73529411764705888);

        const normalVec62 = new THREE.Vector3();
        normalVec62.crossVectors(B62.sub(A62), C62.sub(A62));
        normalVec62.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal62 = new THREE.Vector3(0,0,1);

        const quaternionRotation62 = new THREE.Quaternion();
        quaternionRotation62.setFromUnitVectors(initialNormal62, normalVec62);

        ringMesh62.setRotationFromQuaternion(quaternionRotation62);

        return quaternionRotation62;
    }

    ringRoot.add(ringMesh62);
            
	var inradius63 = calulateInradius(getVertex3(), getVertex82(), getVertex83());
	var incenter63 = calulateIncenter(getVertex3(), getVertex82(), getVertex83());
	var ringGeometry63 = new THREE.RingGeometry((inradius63 - 0.005),inradius63, 32);
	const ringMaterial63 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh63 = new THREE.Mesh(ringGeometry63, ringMaterial63);

	function setCircleRotation63(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.27450980392156865],[0.,0.,0.26470588235294124]);

        ringMesh63.position.setX(incenter[0]);
        ringMesh63.position.setY(incenter[1]);
        ringMesh63.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex82(), getVertex83());
        var relRadius = inradius/inradius63;

        ringMesh63.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A63 = new THREE.Vector3(-1.,0.,0.);
        const B63 = new THREE.Vector3(0.,0.,0.27450980392156865);
        const C63 = new THREE.Vector3(0.,0.,0.26470588235294124);

        const normalVec63 = new THREE.Vector3();
        normalVec63.crossVectors(B63.sub(A63), C63.sub(A63));
        normalVec63.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal63 = new THREE.Vector3(0,0,1);

        const quaternionRotation63 = new THREE.Quaternion();
        quaternionRotation63.setFromUnitVectors(initialNormal63, normalVec63);

        ringMesh63.setRotationFromQuaternion(quaternionRotation63);

        return quaternionRotation63;
    }

    ringRoot.add(ringMesh63);
            
	var inradius64 = calulateInradius(getVertex4(), getVertex35(), getVertex36());
	var incenter64 = calulateIncenter(getVertex4(), getVertex35(), getVertex36());
	var ringGeometry64 = new THREE.RingGeometry((inradius64 - 0.005),inradius64, 32);
	const ringMaterial64 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh64 = new THREE.Mesh(ringGeometry64, ringMaterial64);

	function setCircleRotation64(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.73529411764705888],[0.,0.,0.72549019607843135]);

        ringMesh64.position.setX(incenter[0]);
        ringMesh64.position.setY(incenter[1]);
        ringMesh64.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex35(), getVertex36());
        var relRadius = inradius/inradius64;

        ringMesh64.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A64 = new THREE.Vector3(-1.,0.,1.);
        const B64 = new THREE.Vector3(0.,0.,0.73529411764705888);
        const C64 = new THREE.Vector3(0.,0.,0.72549019607843135);

        const normalVec64 = new THREE.Vector3();
        normalVec64.crossVectors(B64.sub(A64), C64.sub(A64));
        normalVec64.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal64 = new THREE.Vector3(0,0,1);

        const quaternionRotation64 = new THREE.Quaternion();
        quaternionRotation64.setFromUnitVectors(initialNormal64, normalVec64);

        ringMesh64.setRotationFromQuaternion(quaternionRotation64);

        return quaternionRotation64;
    }

    ringRoot.add(ringMesh64);
            
	var inradius65 = calulateInradius(getVertex3(), getVertex81(), getVertex82());
	var incenter65 = calulateIncenter(getVertex3(), getVertex81(), getVertex82());
	var ringGeometry65 = new THREE.RingGeometry((inradius65 - 0.005),inradius65, 32);
	const ringMaterial65 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh65 = new THREE.Mesh(ringGeometry65, ringMaterial65);

	function setCircleRotation65(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.28431372549019607],[0.,0.,0.27450980392156865]);

        ringMesh65.position.setX(incenter[0]);
        ringMesh65.position.setY(incenter[1]);
        ringMesh65.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex81(), getVertex82());
        var relRadius = inradius/inradius65;

        ringMesh65.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A65 = new THREE.Vector3(-1.,0.,0.);
        const B65 = new THREE.Vector3(0.,0.,0.28431372549019607);
        const C65 = new THREE.Vector3(0.,0.,0.27450980392156865);

        const normalVec65 = new THREE.Vector3();
        normalVec65.crossVectors(B65.sub(A65), C65.sub(A65));
        normalVec65.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal65 = new THREE.Vector3(0,0,1);

        const quaternionRotation65 = new THREE.Quaternion();
        quaternionRotation65.setFromUnitVectors(initialNormal65, normalVec65);

        ringMesh65.setRotationFromQuaternion(quaternionRotation65);

        return quaternionRotation65;
    }

    ringRoot.add(ringMesh65);
            
	var inradius66 = calulateInradius(getVertex4(), getVertex36(), getVertex37());
	var incenter66 = calulateIncenter(getVertex4(), getVertex36(), getVertex37());
	var ringGeometry66 = new THREE.RingGeometry((inradius66 - 0.005),inradius66, 32);
	const ringMaterial66 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh66 = new THREE.Mesh(ringGeometry66, ringMaterial66);

	function setCircleRotation66(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.72549019607843135],[0.,0.,0.71568627450980393]);

        ringMesh66.position.setX(incenter[0]);
        ringMesh66.position.setY(incenter[1]);
        ringMesh66.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex36(), getVertex37());
        var relRadius = inradius/inradius66;

        ringMesh66.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A66 = new THREE.Vector3(-1.,0.,1.);
        const B66 = new THREE.Vector3(0.,0.,0.72549019607843135);
        const C66 = new THREE.Vector3(0.,0.,0.71568627450980393);

        const normalVec66 = new THREE.Vector3();
        normalVec66.crossVectors(B66.sub(A66), C66.sub(A66));
        normalVec66.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal66 = new THREE.Vector3(0,0,1);

        const quaternionRotation66 = new THREE.Quaternion();
        quaternionRotation66.setFromUnitVectors(initialNormal66, normalVec66);

        ringMesh66.setRotationFromQuaternion(quaternionRotation66);

        return quaternionRotation66;
    }

    ringRoot.add(ringMesh66);
            
	var inradius67 = calulateInradius(getVertex3(), getVertex80(), getVertex81());
	var incenter67 = calulateIncenter(getVertex3(), getVertex80(), getVertex81());
	var ringGeometry67 = new THREE.RingGeometry((inradius67 - 0.005),inradius67, 32);
	const ringMaterial67 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh67 = new THREE.Mesh(ringGeometry67, ringMaterial67);

	function setCircleRotation67(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.29411764705882359],[0.,0.,0.28431372549019607]);

        ringMesh67.position.setX(incenter[0]);
        ringMesh67.position.setY(incenter[1]);
        ringMesh67.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex80(), getVertex81());
        var relRadius = inradius/inradius67;

        ringMesh67.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A67 = new THREE.Vector3(-1.,0.,0.);
        const B67 = new THREE.Vector3(0.,0.,0.29411764705882359);
        const C67 = new THREE.Vector3(0.,0.,0.28431372549019607);

        const normalVec67 = new THREE.Vector3();
        normalVec67.crossVectors(B67.sub(A67), C67.sub(A67));
        normalVec67.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal67 = new THREE.Vector3(0,0,1);

        const quaternionRotation67 = new THREE.Quaternion();
        quaternionRotation67.setFromUnitVectors(initialNormal67, normalVec67);

        ringMesh67.setRotationFromQuaternion(quaternionRotation67);

        return quaternionRotation67;
    }

    ringRoot.add(ringMesh67);
            
	var inradius68 = calulateInradius(getVertex4(), getVertex37(), getVertex38());
	var incenter68 = calulateIncenter(getVertex4(), getVertex37(), getVertex38());
	var ringGeometry68 = new THREE.RingGeometry((inradius68 - 0.005),inradius68, 32);
	const ringMaterial68 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh68 = new THREE.Mesh(ringGeometry68, ringMaterial68);

	function setCircleRotation68(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.71568627450980393],[0.,0.,0.70588235294117641]);

        ringMesh68.position.setX(incenter[0]);
        ringMesh68.position.setY(incenter[1]);
        ringMesh68.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex37(), getVertex38());
        var relRadius = inradius/inradius68;

        ringMesh68.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A68 = new THREE.Vector3(-1.,0.,1.);
        const B68 = new THREE.Vector3(0.,0.,0.71568627450980393);
        const C68 = new THREE.Vector3(0.,0.,0.70588235294117641);

        const normalVec68 = new THREE.Vector3();
        normalVec68.crossVectors(B68.sub(A68), C68.sub(A68));
        normalVec68.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal68 = new THREE.Vector3(0,0,1);

        const quaternionRotation68 = new THREE.Quaternion();
        quaternionRotation68.setFromUnitVectors(initialNormal68, normalVec68);

        ringMesh68.setRotationFromQuaternion(quaternionRotation68);

        return quaternionRotation68;
    }

    ringRoot.add(ringMesh68);
            
	var inradius69 = calulateInradius(getVertex3(), getVertex79(), getVertex80());
	var incenter69 = calulateIncenter(getVertex3(), getVertex79(), getVertex80());
	var ringGeometry69 = new THREE.RingGeometry((inradius69 - 0.005),inradius69, 32);
	const ringMaterial69 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh69 = new THREE.Mesh(ringGeometry69, ringMaterial69);

	function setCircleRotation69(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.30392156862745101],[0.,0.,0.29411764705882359]);

        ringMesh69.position.setX(incenter[0]);
        ringMesh69.position.setY(incenter[1]);
        ringMesh69.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex79(), getVertex80());
        var relRadius = inradius/inradius69;

        ringMesh69.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A69 = new THREE.Vector3(-1.,0.,0.);
        const B69 = new THREE.Vector3(0.,0.,0.30392156862745101);
        const C69 = new THREE.Vector3(0.,0.,0.29411764705882359);

        const normalVec69 = new THREE.Vector3();
        normalVec69.crossVectors(B69.sub(A69), C69.sub(A69));
        normalVec69.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal69 = new THREE.Vector3(0,0,1);

        const quaternionRotation69 = new THREE.Quaternion();
        quaternionRotation69.setFromUnitVectors(initialNormal69, normalVec69);

        ringMesh69.setRotationFromQuaternion(quaternionRotation69);

        return quaternionRotation69;
    }

    ringRoot.add(ringMesh69);
            
	var inradius70 = calulateInradius(getVertex4(), getVertex38(), getVertex39());
	var incenter70 = calulateIncenter(getVertex4(), getVertex38(), getVertex39());
	var ringGeometry70 = new THREE.RingGeometry((inradius70 - 0.005),inradius70, 32);
	const ringMaterial70 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh70 = new THREE.Mesh(ringGeometry70, ringMaterial70);

	function setCircleRotation70(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.70588235294117641],[0.,0.,0.69607843137254899]);

        ringMesh70.position.setX(incenter[0]);
        ringMesh70.position.setY(incenter[1]);
        ringMesh70.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex38(), getVertex39());
        var relRadius = inradius/inradius70;

        ringMesh70.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A70 = new THREE.Vector3(-1.,0.,1.);
        const B70 = new THREE.Vector3(0.,0.,0.70588235294117641);
        const C70 = new THREE.Vector3(0.,0.,0.69607843137254899);

        const normalVec70 = new THREE.Vector3();
        normalVec70.crossVectors(B70.sub(A70), C70.sub(A70));
        normalVec70.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal70 = new THREE.Vector3(0,0,1);

        const quaternionRotation70 = new THREE.Quaternion();
        quaternionRotation70.setFromUnitVectors(initialNormal70, normalVec70);

        ringMesh70.setRotationFromQuaternion(quaternionRotation70);

        return quaternionRotation70;
    }

    ringRoot.add(ringMesh70);
            
	var inradius71 = calulateInradius(getVertex3(), getVertex78(), getVertex79());
	var incenter71 = calulateIncenter(getVertex3(), getVertex78(), getVertex79());
	var ringGeometry71 = new THREE.RingGeometry((inradius71 - 0.005),inradius71, 32);
	const ringMaterial71 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh71 = new THREE.Mesh(ringGeometry71, ringMaterial71);

	function setCircleRotation71(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.31372549019607843],[0.,0.,0.30392156862745101]);

        ringMesh71.position.setX(incenter[0]);
        ringMesh71.position.setY(incenter[1]);
        ringMesh71.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex78(), getVertex79());
        var relRadius = inradius/inradius71;

        ringMesh71.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A71 = new THREE.Vector3(-1.,0.,0.);
        const B71 = new THREE.Vector3(0.,0.,0.31372549019607843);
        const C71 = new THREE.Vector3(0.,0.,0.30392156862745101);

        const normalVec71 = new THREE.Vector3();
        normalVec71.crossVectors(B71.sub(A71), C71.sub(A71));
        normalVec71.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal71 = new THREE.Vector3(0,0,1);

        const quaternionRotation71 = new THREE.Quaternion();
        quaternionRotation71.setFromUnitVectors(initialNormal71, normalVec71);

        ringMesh71.setRotationFromQuaternion(quaternionRotation71);

        return quaternionRotation71;
    }

    ringRoot.add(ringMesh71);
            
	var inradius72 = calulateInradius(getVertex4(), getVertex39(), getVertex40());
	var incenter72 = calulateIncenter(getVertex4(), getVertex39(), getVertex40());
	var ringGeometry72 = new THREE.RingGeometry((inradius72 - 0.005),inradius72, 32);
	const ringMaterial72 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh72 = new THREE.Mesh(ringGeometry72, ringMaterial72);

	function setCircleRotation72(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.69607843137254899],[0.,0.,0.68627450980392157]);

        ringMesh72.position.setX(incenter[0]);
        ringMesh72.position.setY(incenter[1]);
        ringMesh72.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex39(), getVertex40());
        var relRadius = inradius/inradius72;

        ringMesh72.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A72 = new THREE.Vector3(-1.,0.,1.);
        const B72 = new THREE.Vector3(0.,0.,0.69607843137254899);
        const C72 = new THREE.Vector3(0.,0.,0.68627450980392157);

        const normalVec72 = new THREE.Vector3();
        normalVec72.crossVectors(B72.sub(A72), C72.sub(A72));
        normalVec72.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal72 = new THREE.Vector3(0,0,1);

        const quaternionRotation72 = new THREE.Quaternion();
        quaternionRotation72.setFromUnitVectors(initialNormal72, normalVec72);

        ringMesh72.setRotationFromQuaternion(quaternionRotation72);

        return quaternionRotation72;
    }

    ringRoot.add(ringMesh72);
            
	var inradius73 = calulateInradius(getVertex3(), getVertex77(), getVertex78());
	var incenter73 = calulateIncenter(getVertex3(), getVertex77(), getVertex78());
	var ringGeometry73 = new THREE.RingGeometry((inradius73 - 0.005),inradius73, 32);
	const ringMaterial73 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh73 = new THREE.Mesh(ringGeometry73, ringMaterial73);

	function setCircleRotation73(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.32352941176470584],[0.,0.,0.31372549019607843]);

        ringMesh73.position.setX(incenter[0]);
        ringMesh73.position.setY(incenter[1]);
        ringMesh73.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex77(), getVertex78());
        var relRadius = inradius/inradius73;

        ringMesh73.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A73 = new THREE.Vector3(-1.,0.,0.);
        const B73 = new THREE.Vector3(0.,0.,0.32352941176470584);
        const C73 = new THREE.Vector3(0.,0.,0.31372549019607843);

        const normalVec73 = new THREE.Vector3();
        normalVec73.crossVectors(B73.sub(A73), C73.sub(A73));
        normalVec73.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal73 = new THREE.Vector3(0,0,1);

        const quaternionRotation73 = new THREE.Quaternion();
        quaternionRotation73.setFromUnitVectors(initialNormal73, normalVec73);

        ringMesh73.setRotationFromQuaternion(quaternionRotation73);

        return quaternionRotation73;
    }

    ringRoot.add(ringMesh73);
            
	var inradius74 = calulateInradius(getVertex4(), getVertex40(), getVertex41());
	var incenter74 = calulateIncenter(getVertex4(), getVertex40(), getVertex41());
	var ringGeometry74 = new THREE.RingGeometry((inradius74 - 0.005),inradius74, 32);
	const ringMaterial74 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh74 = new THREE.Mesh(ringGeometry74, ringMaterial74);

	function setCircleRotation74(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.68627450980392157],[0.,0.,0.67647058823529416]);

        ringMesh74.position.setX(incenter[0]);
        ringMesh74.position.setY(incenter[1]);
        ringMesh74.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex40(), getVertex41());
        var relRadius = inradius/inradius74;

        ringMesh74.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A74 = new THREE.Vector3(-1.,0.,1.);
        const B74 = new THREE.Vector3(0.,0.,0.68627450980392157);
        const C74 = new THREE.Vector3(0.,0.,0.67647058823529416);

        const normalVec74 = new THREE.Vector3();
        normalVec74.crossVectors(B74.sub(A74), C74.sub(A74));
        normalVec74.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal74 = new THREE.Vector3(0,0,1);

        const quaternionRotation74 = new THREE.Quaternion();
        quaternionRotation74.setFromUnitVectors(initialNormal74, normalVec74);

        ringMesh74.setRotationFromQuaternion(quaternionRotation74);

        return quaternionRotation74;
    }

    ringRoot.add(ringMesh74);
            
	var inradius75 = calulateInradius(getVertex3(), getVertex76(), getVertex77());
	var incenter75 = calulateIncenter(getVertex3(), getVertex76(), getVertex77());
	var ringGeometry75 = new THREE.RingGeometry((inradius75 - 0.005),inradius75, 32);
	const ringMaterial75 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh75 = new THREE.Mesh(ringGeometry75, ringMaterial75);

	function setCircleRotation75(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.33333333333333337],[0.,0.,0.32352941176470584]);

        ringMesh75.position.setX(incenter[0]);
        ringMesh75.position.setY(incenter[1]);
        ringMesh75.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex76(), getVertex77());
        var relRadius = inradius/inradius75;

        ringMesh75.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A75 = new THREE.Vector3(-1.,0.,0.);
        const B75 = new THREE.Vector3(0.,0.,0.33333333333333337);
        const C75 = new THREE.Vector3(0.,0.,0.32352941176470584);

        const normalVec75 = new THREE.Vector3();
        normalVec75.crossVectors(B75.sub(A75), C75.sub(A75));
        normalVec75.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal75 = new THREE.Vector3(0,0,1);

        const quaternionRotation75 = new THREE.Quaternion();
        quaternionRotation75.setFromUnitVectors(initialNormal75, normalVec75);

        ringMesh75.setRotationFromQuaternion(quaternionRotation75);

        return quaternionRotation75;
    }

    ringRoot.add(ringMesh75);
            
	var inradius76 = calulateInradius(getVertex4(), getVertex41(), getVertex42());
	var incenter76 = calulateIncenter(getVertex4(), getVertex41(), getVertex42());
	var ringGeometry76 = new THREE.RingGeometry((inradius76 - 0.005),inradius76, 32);
	const ringMaterial76 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh76 = new THREE.Mesh(ringGeometry76, ringMaterial76);

	function setCircleRotation76(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.67647058823529416],[0.,0.,0.66666666666666674]);

        ringMesh76.position.setX(incenter[0]);
        ringMesh76.position.setY(incenter[1]);
        ringMesh76.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex41(), getVertex42());
        var relRadius = inradius/inradius76;

        ringMesh76.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A76 = new THREE.Vector3(-1.,0.,1.);
        const B76 = new THREE.Vector3(0.,0.,0.67647058823529416);
        const C76 = new THREE.Vector3(0.,0.,0.66666666666666674);

        const normalVec76 = new THREE.Vector3();
        normalVec76.crossVectors(B76.sub(A76), C76.sub(A76));
        normalVec76.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal76 = new THREE.Vector3(0,0,1);

        const quaternionRotation76 = new THREE.Quaternion();
        quaternionRotation76.setFromUnitVectors(initialNormal76, normalVec76);

        ringMesh76.setRotationFromQuaternion(quaternionRotation76);

        return quaternionRotation76;
    }

    ringRoot.add(ringMesh76);
            
	var inradius77 = calulateInradius(getVertex3(), getVertex75(), getVertex76());
	var incenter77 = calulateIncenter(getVertex3(), getVertex75(), getVertex76());
	var ringGeometry77 = new THREE.RingGeometry((inradius77 - 0.005),inradius77, 32);
	const ringMaterial77 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh77 = new THREE.Mesh(ringGeometry77, ringMaterial77);

	function setCircleRotation77(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.34313725490196079],[0.,0.,0.33333333333333337]);

        ringMesh77.position.setX(incenter[0]);
        ringMesh77.position.setY(incenter[1]);
        ringMesh77.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex75(), getVertex76());
        var relRadius = inradius/inradius77;

        ringMesh77.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A77 = new THREE.Vector3(-1.,0.,0.);
        const B77 = new THREE.Vector3(0.,0.,0.34313725490196079);
        const C77 = new THREE.Vector3(0.,0.,0.33333333333333337);

        const normalVec77 = new THREE.Vector3();
        normalVec77.crossVectors(B77.sub(A77), C77.sub(A77));
        normalVec77.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal77 = new THREE.Vector3(0,0,1);

        const quaternionRotation77 = new THREE.Quaternion();
        quaternionRotation77.setFromUnitVectors(initialNormal77, normalVec77);

        ringMesh77.setRotationFromQuaternion(quaternionRotation77);

        return quaternionRotation77;
    }

    ringRoot.add(ringMesh77);
            
	var inradius78 = calulateInradius(getVertex4(), getVertex42(), getVertex43());
	var incenter78 = calulateIncenter(getVertex4(), getVertex42(), getVertex43());
	var ringGeometry78 = new THREE.RingGeometry((inradius78 - 0.005),inradius78, 32);
	const ringMaterial78 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh78 = new THREE.Mesh(ringGeometry78, ringMaterial78);

	function setCircleRotation78(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.66666666666666674],[0.,0.,0.65686274509803921]);

        ringMesh78.position.setX(incenter[0]);
        ringMesh78.position.setY(incenter[1]);
        ringMesh78.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex42(), getVertex43());
        var relRadius = inradius/inradius78;

        ringMesh78.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A78 = new THREE.Vector3(-1.,0.,1.);
        const B78 = new THREE.Vector3(0.,0.,0.66666666666666674);
        const C78 = new THREE.Vector3(0.,0.,0.65686274509803921);

        const normalVec78 = new THREE.Vector3();
        normalVec78.crossVectors(B78.sub(A78), C78.sub(A78));
        normalVec78.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal78 = new THREE.Vector3(0,0,1);

        const quaternionRotation78 = new THREE.Quaternion();
        quaternionRotation78.setFromUnitVectors(initialNormal78, normalVec78);

        ringMesh78.setRotationFromQuaternion(quaternionRotation78);

        return quaternionRotation78;
    }

    ringRoot.add(ringMesh78);
            
	var inradius79 = calulateInradius(getVertex3(), getVertex74(), getVertex75());
	var incenter79 = calulateIncenter(getVertex3(), getVertex74(), getVertex75());
	var ringGeometry79 = new THREE.RingGeometry((inradius79 - 0.005),inradius79, 32);
	const ringMaterial79 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh79 = new THREE.Mesh(ringGeometry79, ringMaterial79);

	function setCircleRotation79(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.3529411764705882],[0.,0.,0.34313725490196079]);

        ringMesh79.position.setX(incenter[0]);
        ringMesh79.position.setY(incenter[1]);
        ringMesh79.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex74(), getVertex75());
        var relRadius = inradius/inradius79;

        ringMesh79.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A79 = new THREE.Vector3(-1.,0.,0.);
        const B79 = new THREE.Vector3(0.,0.,0.3529411764705882);
        const C79 = new THREE.Vector3(0.,0.,0.34313725490196079);

        const normalVec79 = new THREE.Vector3();
        normalVec79.crossVectors(B79.sub(A79), C79.sub(A79));
        normalVec79.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal79 = new THREE.Vector3(0,0,1);

        const quaternionRotation79 = new THREE.Quaternion();
        quaternionRotation79.setFromUnitVectors(initialNormal79, normalVec79);

        ringMesh79.setRotationFromQuaternion(quaternionRotation79);

        return quaternionRotation79;
    }

    ringRoot.add(ringMesh79);
            
	var inradius80 = calulateInradius(getVertex4(), getVertex43(), getVertex44());
	var incenter80 = calulateIncenter(getVertex4(), getVertex43(), getVertex44());
	var ringGeometry80 = new THREE.RingGeometry((inradius80 - 0.005),inradius80, 32);
	const ringMaterial80 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh80 = new THREE.Mesh(ringGeometry80, ringMaterial80);

	function setCircleRotation80(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.65686274509803921],[0.,0.,0.6470588235294118]);

        ringMesh80.position.setX(incenter[0]);
        ringMesh80.position.setY(incenter[1]);
        ringMesh80.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex43(), getVertex44());
        var relRadius = inradius/inradius80;

        ringMesh80.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A80 = new THREE.Vector3(-1.,0.,1.);
        const B80 = new THREE.Vector3(0.,0.,0.65686274509803921);
        const C80 = new THREE.Vector3(0.,0.,0.6470588235294118);

        const normalVec80 = new THREE.Vector3();
        normalVec80.crossVectors(B80.sub(A80), C80.sub(A80));
        normalVec80.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal80 = new THREE.Vector3(0,0,1);

        const quaternionRotation80 = new THREE.Quaternion();
        quaternionRotation80.setFromUnitVectors(initialNormal80, normalVec80);

        ringMesh80.setRotationFromQuaternion(quaternionRotation80);

        return quaternionRotation80;
    }

    ringRoot.add(ringMesh80);
            
	var inradius81 = calulateInradius(getVertex3(), getVertex73(), getVertex74());
	var incenter81 = calulateIncenter(getVertex3(), getVertex73(), getVertex74());
	var ringGeometry81 = new THREE.RingGeometry((inradius81 - 0.005),inradius81, 32);
	const ringMaterial81 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh81 = new THREE.Mesh(ringGeometry81, ringMaterial81);

	function setCircleRotation81(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.36274509803921573],[0.,0.,0.3529411764705882]);

        ringMesh81.position.setX(incenter[0]);
        ringMesh81.position.setY(incenter[1]);
        ringMesh81.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex73(), getVertex74());
        var relRadius = inradius/inradius81;

        ringMesh81.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A81 = new THREE.Vector3(-1.,0.,0.);
        const B81 = new THREE.Vector3(0.,0.,0.36274509803921573);
        const C81 = new THREE.Vector3(0.,0.,0.3529411764705882);

        const normalVec81 = new THREE.Vector3();
        normalVec81.crossVectors(B81.sub(A81), C81.sub(A81));
        normalVec81.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal81 = new THREE.Vector3(0,0,1);

        const quaternionRotation81 = new THREE.Quaternion();
        quaternionRotation81.setFromUnitVectors(initialNormal81, normalVec81);

        ringMesh81.setRotationFromQuaternion(quaternionRotation81);

        return quaternionRotation81;
    }

    ringRoot.add(ringMesh81);
            
	var inradius82 = calulateInradius(getVertex4(), getVertex44(), getVertex45());
	var incenter82 = calulateIncenter(getVertex4(), getVertex44(), getVertex45());
	var ringGeometry82 = new THREE.RingGeometry((inradius82 - 0.005),inradius82, 32);
	const ringMaterial82 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh82 = new THREE.Mesh(ringGeometry82, ringMaterial82);

	function setCircleRotation82(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.6470588235294118],[0.,0.,0.63725490196078427]);

        ringMesh82.position.setX(incenter[0]);
        ringMesh82.position.setY(incenter[1]);
        ringMesh82.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex44(), getVertex45());
        var relRadius = inradius/inradius82;

        ringMesh82.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A82 = new THREE.Vector3(-1.,0.,1.);
        const B82 = new THREE.Vector3(0.,0.,0.6470588235294118);
        const C82 = new THREE.Vector3(0.,0.,0.63725490196078427);

        const normalVec82 = new THREE.Vector3();
        normalVec82.crossVectors(B82.sub(A82), C82.sub(A82));
        normalVec82.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal82 = new THREE.Vector3(0,0,1);

        const quaternionRotation82 = new THREE.Quaternion();
        quaternionRotation82.setFromUnitVectors(initialNormal82, normalVec82);

        ringMesh82.setRotationFromQuaternion(quaternionRotation82);

        return quaternionRotation82;
    }

    ringRoot.add(ringMesh82);
            
	var inradius83 = calulateInradius(getVertex3(), getVertex72(), getVertex73());
	var incenter83 = calulateIncenter(getVertex3(), getVertex72(), getVertex73());
	var ringGeometry83 = new THREE.RingGeometry((inradius83 - 0.005),inradius83, 32);
	const ringMaterial83 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh83 = new THREE.Mesh(ringGeometry83, ringMaterial83);

	function setCircleRotation83(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.37254901960784315],[0.,0.,0.36274509803921573]);

        ringMesh83.position.setX(incenter[0]);
        ringMesh83.position.setY(incenter[1]);
        ringMesh83.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex72(), getVertex73());
        var relRadius = inradius/inradius83;

        ringMesh83.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A83 = new THREE.Vector3(-1.,0.,0.);
        const B83 = new THREE.Vector3(0.,0.,0.37254901960784315);
        const C83 = new THREE.Vector3(0.,0.,0.36274509803921573);

        const normalVec83 = new THREE.Vector3();
        normalVec83.crossVectors(B83.sub(A83), C83.sub(A83));
        normalVec83.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal83 = new THREE.Vector3(0,0,1);

        const quaternionRotation83 = new THREE.Quaternion();
        quaternionRotation83.setFromUnitVectors(initialNormal83, normalVec83);

        ringMesh83.setRotationFromQuaternion(quaternionRotation83);

        return quaternionRotation83;
    }

    ringRoot.add(ringMesh83);
            
	var inradius84 = calulateInradius(getVertex4(), getVertex45(), getVertex46());
	var incenter84 = calulateIncenter(getVertex4(), getVertex45(), getVertex46());
	var ringGeometry84 = new THREE.RingGeometry((inradius84 - 0.005),inradius84, 32);
	const ringMaterial84 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh84 = new THREE.Mesh(ringGeometry84, ringMaterial84);

	function setCircleRotation84(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.63725490196078427],[0.,0.,0.62745098039215685]);

        ringMesh84.position.setX(incenter[0]);
        ringMesh84.position.setY(incenter[1]);
        ringMesh84.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex45(), getVertex46());
        var relRadius = inradius/inradius84;

        ringMesh84.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A84 = new THREE.Vector3(-1.,0.,1.);
        const B84 = new THREE.Vector3(0.,0.,0.63725490196078427);
        const C84 = new THREE.Vector3(0.,0.,0.62745098039215685);

        const normalVec84 = new THREE.Vector3();
        normalVec84.crossVectors(B84.sub(A84), C84.sub(A84));
        normalVec84.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal84 = new THREE.Vector3(0,0,1);

        const quaternionRotation84 = new THREE.Quaternion();
        quaternionRotation84.setFromUnitVectors(initialNormal84, normalVec84);

        ringMesh84.setRotationFromQuaternion(quaternionRotation84);

        return quaternionRotation84;
    }

    ringRoot.add(ringMesh84);
            
	var inradius85 = calulateInradius(getVertex3(), getVertex71(), getVertex72());
	var incenter85 = calulateIncenter(getVertex3(), getVertex71(), getVertex72());
	var ringGeometry85 = new THREE.RingGeometry((inradius85 - 0.005),inradius85, 32);
	const ringMaterial85 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh85 = new THREE.Mesh(ringGeometry85, ringMaterial85);

	function setCircleRotation85(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.38235294117647056],[0.,0.,0.37254901960784315]);

        ringMesh85.position.setX(incenter[0]);
        ringMesh85.position.setY(incenter[1]);
        ringMesh85.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex71(), getVertex72());
        var relRadius = inradius/inradius85;

        ringMesh85.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A85 = new THREE.Vector3(-1.,0.,0.);
        const B85 = new THREE.Vector3(0.,0.,0.38235294117647056);
        const C85 = new THREE.Vector3(0.,0.,0.37254901960784315);

        const normalVec85 = new THREE.Vector3();
        normalVec85.crossVectors(B85.sub(A85), C85.sub(A85));
        normalVec85.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal85 = new THREE.Vector3(0,0,1);

        const quaternionRotation85 = new THREE.Quaternion();
        quaternionRotation85.setFromUnitVectors(initialNormal85, normalVec85);

        ringMesh85.setRotationFromQuaternion(quaternionRotation85);

        return quaternionRotation85;
    }

    ringRoot.add(ringMesh85);
            
	var inradius86 = calulateInradius(getVertex4(), getVertex46(), getVertex47());
	var incenter86 = calulateIncenter(getVertex4(), getVertex46(), getVertex47());
	var ringGeometry86 = new THREE.RingGeometry((inradius86 - 0.005),inradius86, 32);
	const ringMaterial86 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh86 = new THREE.Mesh(ringGeometry86, ringMaterial86);

	function setCircleRotation86(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.62745098039215685],[0.,0.,0.61764705882352944]);

        ringMesh86.position.setX(incenter[0]);
        ringMesh86.position.setY(incenter[1]);
        ringMesh86.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex46(), getVertex47());
        var relRadius = inradius/inradius86;

        ringMesh86.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A86 = new THREE.Vector3(-1.,0.,1.);
        const B86 = new THREE.Vector3(0.,0.,0.62745098039215685);
        const C86 = new THREE.Vector3(0.,0.,0.61764705882352944);

        const normalVec86 = new THREE.Vector3();
        normalVec86.crossVectors(B86.sub(A86), C86.sub(A86));
        normalVec86.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal86 = new THREE.Vector3(0,0,1);

        const quaternionRotation86 = new THREE.Quaternion();
        quaternionRotation86.setFromUnitVectors(initialNormal86, normalVec86);

        ringMesh86.setRotationFromQuaternion(quaternionRotation86);

        return quaternionRotation86;
    }

    ringRoot.add(ringMesh86);
            
	var inradius87 = calulateInradius(getVertex3(), getVertex70(), getVertex71());
	var incenter87 = calulateIncenter(getVertex3(), getVertex70(), getVertex71());
	var ringGeometry87 = new THREE.RingGeometry((inradius87 - 0.005),inradius87, 32);
	const ringMaterial87 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh87 = new THREE.Mesh(ringGeometry87, ringMaterial87);

	function setCircleRotation87(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.39215686274509809],[0.,0.,0.38235294117647056]);

        ringMesh87.position.setX(incenter[0]);
        ringMesh87.position.setY(incenter[1]);
        ringMesh87.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex70(), getVertex71());
        var relRadius = inradius/inradius87;

        ringMesh87.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A87 = new THREE.Vector3(-1.,0.,0.);
        const B87 = new THREE.Vector3(0.,0.,0.39215686274509809);
        const C87 = new THREE.Vector3(0.,0.,0.38235294117647056);

        const normalVec87 = new THREE.Vector3();
        normalVec87.crossVectors(B87.sub(A87), C87.sub(A87));
        normalVec87.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal87 = new THREE.Vector3(0,0,1);

        const quaternionRotation87 = new THREE.Quaternion();
        quaternionRotation87.setFromUnitVectors(initialNormal87, normalVec87);

        ringMesh87.setRotationFromQuaternion(quaternionRotation87);

        return quaternionRotation87;
    }

    ringRoot.add(ringMesh87);
            
	var inradius88 = calulateInradius(getVertex4(), getVertex47(), getVertex48());
	var incenter88 = calulateIncenter(getVertex4(), getVertex47(), getVertex48());
	var ringGeometry88 = new THREE.RingGeometry((inradius88 - 0.005),inradius88, 32);
	const ringMaterial88 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh88 = new THREE.Mesh(ringGeometry88, ringMaterial88);

	function setCircleRotation88(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.61764705882352944],[0.,0.,0.60784313725490202]);

        ringMesh88.position.setX(incenter[0]);
        ringMesh88.position.setY(incenter[1]);
        ringMesh88.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex47(), getVertex48());
        var relRadius = inradius/inradius88;

        ringMesh88.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A88 = new THREE.Vector3(-1.,0.,1.);
        const B88 = new THREE.Vector3(0.,0.,0.61764705882352944);
        const C88 = new THREE.Vector3(0.,0.,0.60784313725490202);

        const normalVec88 = new THREE.Vector3();
        normalVec88.crossVectors(B88.sub(A88), C88.sub(A88));
        normalVec88.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal88 = new THREE.Vector3(0,0,1);

        const quaternionRotation88 = new THREE.Quaternion();
        quaternionRotation88.setFromUnitVectors(initialNormal88, normalVec88);

        ringMesh88.setRotationFromQuaternion(quaternionRotation88);

        return quaternionRotation88;
    }

    ringRoot.add(ringMesh88);
            
	var inradius89 = calulateInradius(getVertex3(), getVertex69(), getVertex70());
	var incenter89 = calulateIncenter(getVertex3(), getVertex69(), getVertex70());
	var ringGeometry89 = new THREE.RingGeometry((inradius89 - 0.005),inradius89, 32);
	const ringMaterial89 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh89 = new THREE.Mesh(ringGeometry89, ringMaterial89);

	function setCircleRotation89(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.40196078431372551],[0.,0.,0.39215686274509809]);

        ringMesh89.position.setX(incenter[0]);
        ringMesh89.position.setY(incenter[1]);
        ringMesh89.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex69(), getVertex70());
        var relRadius = inradius/inradius89;

        ringMesh89.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A89 = new THREE.Vector3(-1.,0.,0.);
        const B89 = new THREE.Vector3(0.,0.,0.40196078431372551);
        const C89 = new THREE.Vector3(0.,0.,0.39215686274509809);

        const normalVec89 = new THREE.Vector3();
        normalVec89.crossVectors(B89.sub(A89), C89.sub(A89));
        normalVec89.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal89 = new THREE.Vector3(0,0,1);

        const quaternionRotation89 = new THREE.Quaternion();
        quaternionRotation89.setFromUnitVectors(initialNormal89, normalVec89);

        ringMesh89.setRotationFromQuaternion(quaternionRotation89);

        return quaternionRotation89;
    }

    ringRoot.add(ringMesh89);
            
	var inradius90 = calulateInradius(getVertex4(), getVertex48(), getVertex49());
	var incenter90 = calulateIncenter(getVertex4(), getVertex48(), getVertex49());
	var ringGeometry90 = new THREE.RingGeometry((inradius90 - 0.005),inradius90, 32);
	const ringMaterial90 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh90 = new THREE.Mesh(ringGeometry90, ringMaterial90);

	function setCircleRotation90(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.60784313725490202],[0.,0.,0.59803921568627449]);

        ringMesh90.position.setX(incenter[0]);
        ringMesh90.position.setY(incenter[1]);
        ringMesh90.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex48(), getVertex49());
        var relRadius = inradius/inradius90;

        ringMesh90.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A90 = new THREE.Vector3(-1.,0.,1.);
        const B90 = new THREE.Vector3(0.,0.,0.60784313725490202);
        const C90 = new THREE.Vector3(0.,0.,0.59803921568627449);

        const normalVec90 = new THREE.Vector3();
        normalVec90.crossVectors(B90.sub(A90), C90.sub(A90));
        normalVec90.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal90 = new THREE.Vector3(0,0,1);

        const quaternionRotation90 = new THREE.Quaternion();
        quaternionRotation90.setFromUnitVectors(initialNormal90, normalVec90);

        ringMesh90.setRotationFromQuaternion(quaternionRotation90);

        return quaternionRotation90;
    }

    ringRoot.add(ringMesh90);
            
	var inradius91 = calulateInradius(getVertex3(), getVertex68(), getVertex69());
	var incenter91 = calulateIncenter(getVertex3(), getVertex68(), getVertex69());
	var ringGeometry91 = new THREE.RingGeometry((inradius91 - 0.005),inradius91, 32);
	const ringMaterial91 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh91 = new THREE.Mesh(ringGeometry91, ringMaterial91);

	function setCircleRotation91(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.41176470588235292],[0.,0.,0.40196078431372551]);

        ringMesh91.position.setX(incenter[0]);
        ringMesh91.position.setY(incenter[1]);
        ringMesh91.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex68(), getVertex69());
        var relRadius = inradius/inradius91;

        ringMesh91.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A91 = new THREE.Vector3(-1.,0.,0.);
        const B91 = new THREE.Vector3(0.,0.,0.41176470588235292);
        const C91 = new THREE.Vector3(0.,0.,0.40196078431372551);

        const normalVec91 = new THREE.Vector3();
        normalVec91.crossVectors(B91.sub(A91), C91.sub(A91));
        normalVec91.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal91 = new THREE.Vector3(0,0,1);

        const quaternionRotation91 = new THREE.Quaternion();
        quaternionRotation91.setFromUnitVectors(initialNormal91, normalVec91);

        ringMesh91.setRotationFromQuaternion(quaternionRotation91);

        return quaternionRotation91;
    }

    ringRoot.add(ringMesh91);
            
	var inradius92 = calulateInradius(getVertex4(), getVertex49(), getVertex50());
	var incenter92 = calulateIncenter(getVertex4(), getVertex49(), getVertex50());
	var ringGeometry92 = new THREE.RingGeometry((inradius92 - 0.005),inradius92, 32);
	const ringMaterial92 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh92 = new THREE.Mesh(ringGeometry92, ringMaterial92);

	function setCircleRotation92(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.59803921568627449],[0.,0.,0.58823529411764708]);

        ringMesh92.position.setX(incenter[0]);
        ringMesh92.position.setY(incenter[1]);
        ringMesh92.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex49(), getVertex50());
        var relRadius = inradius/inradius92;

        ringMesh92.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A92 = new THREE.Vector3(-1.,0.,1.);
        const B92 = new THREE.Vector3(0.,0.,0.59803921568627449);
        const C92 = new THREE.Vector3(0.,0.,0.58823529411764708);

        const normalVec92 = new THREE.Vector3();
        normalVec92.crossVectors(B92.sub(A92), C92.sub(A92));
        normalVec92.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal92 = new THREE.Vector3(0,0,1);

        const quaternionRotation92 = new THREE.Quaternion();
        quaternionRotation92.setFromUnitVectors(initialNormal92, normalVec92);

        ringMesh92.setRotationFromQuaternion(quaternionRotation92);

        return quaternionRotation92;
    }

    ringRoot.add(ringMesh92);
            
	var inradius93 = calulateInradius(getVertex3(), getVertex67(), getVertex68());
	var incenter93 = calulateIncenter(getVertex3(), getVertex67(), getVertex68());
	var ringGeometry93 = new THREE.RingGeometry((inradius93 - 0.005),inradius93, 32);
	const ringMaterial93 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh93 = new THREE.Mesh(ringGeometry93, ringMaterial93);

	function setCircleRotation93(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.42156862745098045],[0.,0.,0.41176470588235292]);

        ringMesh93.position.setX(incenter[0]);
        ringMesh93.position.setY(incenter[1]);
        ringMesh93.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex67(), getVertex68());
        var relRadius = inradius/inradius93;

        ringMesh93.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A93 = new THREE.Vector3(-1.,0.,0.);
        const B93 = new THREE.Vector3(0.,0.,0.42156862745098045);
        const C93 = new THREE.Vector3(0.,0.,0.41176470588235292);

        const normalVec93 = new THREE.Vector3();
        normalVec93.crossVectors(B93.sub(A93), C93.sub(A93));
        normalVec93.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal93 = new THREE.Vector3(0,0,1);

        const quaternionRotation93 = new THREE.Quaternion();
        quaternionRotation93.setFromUnitVectors(initialNormal93, normalVec93);

        ringMesh93.setRotationFromQuaternion(quaternionRotation93);

        return quaternionRotation93;
    }

    ringRoot.add(ringMesh93);
            
	var inradius94 = calulateInradius(getVertex4(), getVertex50(), getVertex51());
	var incenter94 = calulateIncenter(getVertex4(), getVertex50(), getVertex51());
	var ringGeometry94 = new THREE.RingGeometry((inradius94 - 0.005),inradius94, 32);
	const ringMaterial94 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh94 = new THREE.Mesh(ringGeometry94, ringMaterial94);

	function setCircleRotation94(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.58823529411764708],[0.,0.,0.57843137254901955]);

        ringMesh94.position.setX(incenter[0]);
        ringMesh94.position.setY(incenter[1]);
        ringMesh94.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex50(), getVertex51());
        var relRadius = inradius/inradius94;

        ringMesh94.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A94 = new THREE.Vector3(-1.,0.,1.);
        const B94 = new THREE.Vector3(0.,0.,0.58823529411764708);
        const C94 = new THREE.Vector3(0.,0.,0.57843137254901955);

        const normalVec94 = new THREE.Vector3();
        normalVec94.crossVectors(B94.sub(A94), C94.sub(A94));
        normalVec94.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal94 = new THREE.Vector3(0,0,1);

        const quaternionRotation94 = new THREE.Quaternion();
        quaternionRotation94.setFromUnitVectors(initialNormal94, normalVec94);

        ringMesh94.setRotationFromQuaternion(quaternionRotation94);

        return quaternionRotation94;
    }

    ringRoot.add(ringMesh94);
            
	var inradius95 = calulateInradius(getVertex3(), getVertex66(), getVertex67());
	var incenter95 = calulateIncenter(getVertex3(), getVertex66(), getVertex67());
	var ringGeometry95 = new THREE.RingGeometry((inradius95 - 0.005),inradius95, 32);
	const ringMaterial95 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh95 = new THREE.Mesh(ringGeometry95, ringMaterial95);

	function setCircleRotation95(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.43137254901960786],[0.,0.,0.42156862745098045]);

        ringMesh95.position.setX(incenter[0]);
        ringMesh95.position.setY(incenter[1]);
        ringMesh95.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex66(), getVertex67());
        var relRadius = inradius/inradius95;

        ringMesh95.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A95 = new THREE.Vector3(-1.,0.,0.);
        const B95 = new THREE.Vector3(0.,0.,0.43137254901960786);
        const C95 = new THREE.Vector3(0.,0.,0.42156862745098045);

        const normalVec95 = new THREE.Vector3();
        normalVec95.crossVectors(B95.sub(A95), C95.sub(A95));
        normalVec95.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal95 = new THREE.Vector3(0,0,1);

        const quaternionRotation95 = new THREE.Quaternion();
        quaternionRotation95.setFromUnitVectors(initialNormal95, normalVec95);

        ringMesh95.setRotationFromQuaternion(quaternionRotation95);

        return quaternionRotation95;
    }

    ringRoot.add(ringMesh95);
            
	var inradius96 = calulateInradius(getVertex4(), getVertex51(), getVertex52());
	var incenter96 = calulateIncenter(getVertex4(), getVertex51(), getVertex52());
	var ringGeometry96 = new THREE.RingGeometry((inradius96 - 0.005),inradius96, 32);
	const ringMaterial96 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh96 = new THREE.Mesh(ringGeometry96, ringMaterial96);

	function setCircleRotation96(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.57843137254901955],[0.,0.,0.56862745098039214]);

        ringMesh96.position.setX(incenter[0]);
        ringMesh96.position.setY(incenter[1]);
        ringMesh96.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex51(), getVertex52());
        var relRadius = inradius/inradius96;

        ringMesh96.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A96 = new THREE.Vector3(-1.,0.,1.);
        const B96 = new THREE.Vector3(0.,0.,0.57843137254901955);
        const C96 = new THREE.Vector3(0.,0.,0.56862745098039214);

        const normalVec96 = new THREE.Vector3();
        normalVec96.crossVectors(B96.sub(A96), C96.sub(A96));
        normalVec96.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal96 = new THREE.Vector3(0,0,1);

        const quaternionRotation96 = new THREE.Quaternion();
        quaternionRotation96.setFromUnitVectors(initialNormal96, normalVec96);

        ringMesh96.setRotationFromQuaternion(quaternionRotation96);

        return quaternionRotation96;
    }

    ringRoot.add(ringMesh96);
            
	var inradius97 = calulateInradius(getVertex3(), getVertex65(), getVertex66());
	var incenter97 = calulateIncenter(getVertex3(), getVertex65(), getVertex66());
	var ringGeometry97 = new THREE.RingGeometry((inradius97 - 0.005),inradius97, 32);
	const ringMaterial97 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh97 = new THREE.Mesh(ringGeometry97, ringMaterial97);

	function setCircleRotation97(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.44117647058823528],[0.,0.,0.43137254901960786]);

        ringMesh97.position.setX(incenter[0]);
        ringMesh97.position.setY(incenter[1]);
        ringMesh97.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex65(), getVertex66());
        var relRadius = inradius/inradius97;

        ringMesh97.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A97 = new THREE.Vector3(-1.,0.,0.);
        const B97 = new THREE.Vector3(0.,0.,0.44117647058823528);
        const C97 = new THREE.Vector3(0.,0.,0.43137254901960786);

        const normalVec97 = new THREE.Vector3();
        normalVec97.crossVectors(B97.sub(A97), C97.sub(A97));
        normalVec97.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal97 = new THREE.Vector3(0,0,1);

        const quaternionRotation97 = new THREE.Quaternion();
        quaternionRotation97.setFromUnitVectors(initialNormal97, normalVec97);

        ringMesh97.setRotationFromQuaternion(quaternionRotation97);

        return quaternionRotation97;
    }

    ringRoot.add(ringMesh97);
            
	var inradius98 = calulateInradius(getVertex4(), getVertex52(), getVertex53());
	var incenter98 = calulateIncenter(getVertex4(), getVertex52(), getVertex53());
	var ringGeometry98 = new THREE.RingGeometry((inradius98 - 0.005),inradius98, 32);
	const ringMaterial98 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh98 = new THREE.Mesh(ringGeometry98, ringMaterial98);

	function setCircleRotation98(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.56862745098039214],[0.,0.,0.55882352941176472]);

        ringMesh98.position.setX(incenter[0]);
        ringMesh98.position.setY(incenter[1]);
        ringMesh98.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex52(), getVertex53());
        var relRadius = inradius/inradius98;

        ringMesh98.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A98 = new THREE.Vector3(-1.,0.,1.);
        const B98 = new THREE.Vector3(0.,0.,0.56862745098039214);
        const C98 = new THREE.Vector3(0.,0.,0.55882352941176472);

        const normalVec98 = new THREE.Vector3();
        normalVec98.crossVectors(B98.sub(A98), C98.sub(A98));
        normalVec98.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal98 = new THREE.Vector3(0,0,1);

        const quaternionRotation98 = new THREE.Quaternion();
        quaternionRotation98.setFromUnitVectors(initialNormal98, normalVec98);

        ringMesh98.setRotationFromQuaternion(quaternionRotation98);

        return quaternionRotation98;
    }

    ringRoot.add(ringMesh98);
            
	var inradius99 = calulateInradius(getVertex3(), getVertex64(), getVertex65());
	var incenter99 = calulateIncenter(getVertex3(), getVertex64(), getVertex65());
	var ringGeometry99 = new THREE.RingGeometry((inradius99 - 0.005),inradius99, 32);
	const ringMaterial99 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh99 = new THREE.Mesh(ringGeometry99, ringMaterial99);

	function setCircleRotation99(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.4509803921568627],[0.,0.,0.44117647058823528]);

        ringMesh99.position.setX(incenter[0]);
        ringMesh99.position.setY(incenter[1]);
        ringMesh99.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex64(), getVertex65());
        var relRadius = inradius/inradius99;

        ringMesh99.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A99 = new THREE.Vector3(-1.,0.,0.);
        const B99 = new THREE.Vector3(0.,0.,0.4509803921568627);
        const C99 = new THREE.Vector3(0.,0.,0.44117647058823528);

        const normalVec99 = new THREE.Vector3();
        normalVec99.crossVectors(B99.sub(A99), C99.sub(A99));
        normalVec99.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal99 = new THREE.Vector3(0,0,1);

        const quaternionRotation99 = new THREE.Quaternion();
        quaternionRotation99.setFromUnitVectors(initialNormal99, normalVec99);

        ringMesh99.setRotationFromQuaternion(quaternionRotation99);

        return quaternionRotation99;
    }

    ringRoot.add(ringMesh99);
            
	var inradius100 = calulateInradius(getVertex4(), getVertex53(), getVertex54());
	var incenter100 = calulateIncenter(getVertex4(), getVertex53(), getVertex54());
	var ringGeometry100 = new THREE.RingGeometry((inradius100 - 0.005),inradius100, 32);
	const ringMaterial100 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh100 = new THREE.Mesh(ringGeometry100, ringMaterial100);

	function setCircleRotation100(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.55882352941176472],[0.,0.,0.5490196078431373]);

        ringMesh100.position.setX(incenter[0]);
        ringMesh100.position.setY(incenter[1]);
        ringMesh100.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex53(), getVertex54());
        var relRadius = inradius/inradius100;

        ringMesh100.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A100 = new THREE.Vector3(-1.,0.,1.);
        const B100 = new THREE.Vector3(0.,0.,0.55882352941176472);
        const C100 = new THREE.Vector3(0.,0.,0.5490196078431373);

        const normalVec100 = new THREE.Vector3();
        normalVec100.crossVectors(B100.sub(A100), C100.sub(A100));
        normalVec100.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal100 = new THREE.Vector3(0,0,1);

        const quaternionRotation100 = new THREE.Quaternion();
        quaternionRotation100.setFromUnitVectors(initialNormal100, normalVec100);

        ringMesh100.setRotationFromQuaternion(quaternionRotation100);

        return quaternionRotation100;
    }

    ringRoot.add(ringMesh100);
            
	var inradius101 = calulateInradius(getVertex3(), getVertex63(), getVertex64());
	var incenter101 = calulateIncenter(getVertex3(), getVertex63(), getVertex64());
	var ringGeometry101 = new THREE.RingGeometry((inradius101 - 0.005),inradius101, 32);
	const ringMaterial101 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh101 = new THREE.Mesh(ringGeometry101, ringMaterial101);

	function setCircleRotation101(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.46078431372549022],[0.,0.,0.4509803921568627]);

        ringMesh101.position.setX(incenter[0]);
        ringMesh101.position.setY(incenter[1]);
        ringMesh101.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex63(), getVertex64());
        var relRadius = inradius/inradius101;

        ringMesh101.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A101 = new THREE.Vector3(-1.,0.,0.);
        const B101 = new THREE.Vector3(0.,0.,0.46078431372549022);
        const C101 = new THREE.Vector3(0.,0.,0.4509803921568627);

        const normalVec101 = new THREE.Vector3();
        normalVec101.crossVectors(B101.sub(A101), C101.sub(A101));
        normalVec101.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal101 = new THREE.Vector3(0,0,1);

        const quaternionRotation101 = new THREE.Quaternion();
        quaternionRotation101.setFromUnitVectors(initialNormal101, normalVec101);

        ringMesh101.setRotationFromQuaternion(quaternionRotation101);

        return quaternionRotation101;
    }

    ringRoot.add(ringMesh101);
            
	var inradius102 = calulateInradius(getVertex4(), getVertex54(), getVertex55());
	var incenter102 = calulateIncenter(getVertex4(), getVertex54(), getVertex55());
	var ringGeometry102 = new THREE.RingGeometry((inradius102 - 0.005),inradius102, 32);
	const ringMaterial102 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh102 = new THREE.Mesh(ringGeometry102, ringMaterial102);

	function setCircleRotation102(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.5490196078431373],[0.,0.,0.53921568627450989]);

        ringMesh102.position.setX(incenter[0]);
        ringMesh102.position.setY(incenter[1]);
        ringMesh102.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex54(), getVertex55());
        var relRadius = inradius/inradius102;

        ringMesh102.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A102 = new THREE.Vector3(-1.,0.,1.);
        const B102 = new THREE.Vector3(0.,0.,0.5490196078431373);
        const C102 = new THREE.Vector3(0.,0.,0.53921568627450989);

        const normalVec102 = new THREE.Vector3();
        normalVec102.crossVectors(B102.sub(A102), C102.sub(A102));
        normalVec102.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal102 = new THREE.Vector3(0,0,1);

        const quaternionRotation102 = new THREE.Quaternion();
        quaternionRotation102.setFromUnitVectors(initialNormal102, normalVec102);

        ringMesh102.setRotationFromQuaternion(quaternionRotation102);

        return quaternionRotation102;
    }

    ringRoot.add(ringMesh102);
            
	var inradius103 = calulateInradius(getVertex3(), getVertex62(), getVertex63());
	var incenter103 = calulateIncenter(getVertex3(), getVertex62(), getVertex63());
	var ringGeometry103 = new THREE.RingGeometry((inradius103 - 0.005),inradius103, 32);
	const ringMaterial103 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh103 = new THREE.Mesh(ringGeometry103, ringMaterial103);

	function setCircleRotation103(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.47058823529411764],[0.,0.,0.46078431372549022]);

        ringMesh103.position.setX(incenter[0]);
        ringMesh103.position.setY(incenter[1]);
        ringMesh103.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex62(), getVertex63());
        var relRadius = inradius/inradius103;

        ringMesh103.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A103 = new THREE.Vector3(-1.,0.,0.);
        const B103 = new THREE.Vector3(0.,0.,0.47058823529411764);
        const C103 = new THREE.Vector3(0.,0.,0.46078431372549022);

        const normalVec103 = new THREE.Vector3();
        normalVec103.crossVectors(B103.sub(A103), C103.sub(A103));
        normalVec103.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal103 = new THREE.Vector3(0,0,1);

        const quaternionRotation103 = new THREE.Quaternion();
        quaternionRotation103.setFromUnitVectors(initialNormal103, normalVec103);

        ringMesh103.setRotationFromQuaternion(quaternionRotation103);

        return quaternionRotation103;
    }

    ringRoot.add(ringMesh103);
            
	var inradius104 = calulateInradius(getVertex4(), getVertex55(), getVertex56());
	var incenter104 = calulateIncenter(getVertex4(), getVertex55(), getVertex56());
	var ringGeometry104 = new THREE.RingGeometry((inradius104 - 0.005),inradius104, 32);
	const ringMaterial104 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh104 = new THREE.Mesh(ringGeometry104, ringMaterial104);

	function setCircleRotation104(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.53921568627450989],[0.,0.,0.52941176470588236]);

        ringMesh104.position.setX(incenter[0]);
        ringMesh104.position.setY(incenter[1]);
        ringMesh104.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex55(), getVertex56());
        var relRadius = inradius/inradius104;

        ringMesh104.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A104 = new THREE.Vector3(-1.,0.,1.);
        const B104 = new THREE.Vector3(0.,0.,0.53921568627450989);
        const C104 = new THREE.Vector3(0.,0.,0.52941176470588236);

        const normalVec104 = new THREE.Vector3();
        normalVec104.crossVectors(B104.sub(A104), C104.sub(A104));
        normalVec104.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal104 = new THREE.Vector3(0,0,1);

        const quaternionRotation104 = new THREE.Quaternion();
        quaternionRotation104.setFromUnitVectors(initialNormal104, normalVec104);

        ringMesh104.setRotationFromQuaternion(quaternionRotation104);

        return quaternionRotation104;
    }

    ringRoot.add(ringMesh104);
            
	var inradius105 = calulateInradius(getVertex3(), getVertex61(), getVertex62());
	var incenter105 = calulateIncenter(getVertex3(), getVertex61(), getVertex62());
	var ringGeometry105 = new THREE.RingGeometry((inradius105 - 0.005),inradius105, 32);
	const ringMaterial105 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh105 = new THREE.Mesh(ringGeometry105, ringMaterial105);

	function setCircleRotation105(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.48039215686274506],[0.,0.,0.47058823529411764]);

        ringMesh105.position.setX(incenter[0]);
        ringMesh105.position.setY(incenter[1]);
        ringMesh105.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex61(), getVertex62());
        var relRadius = inradius/inradius105;

        ringMesh105.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A105 = new THREE.Vector3(-1.,0.,0.);
        const B105 = new THREE.Vector3(0.,0.,0.48039215686274506);
        const C105 = new THREE.Vector3(0.,0.,0.47058823529411764);

        const normalVec105 = new THREE.Vector3();
        normalVec105.crossVectors(B105.sub(A105), C105.sub(A105));
        normalVec105.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal105 = new THREE.Vector3(0,0,1);

        const quaternionRotation105 = new THREE.Quaternion();
        quaternionRotation105.setFromUnitVectors(initialNormal105, normalVec105);

        ringMesh105.setRotationFromQuaternion(quaternionRotation105);

        return quaternionRotation105;
    }

    ringRoot.add(ringMesh105);
            
	var inradius106 = calulateInradius(getVertex4(), getVertex56(), getVertex57());
	var incenter106 = calulateIncenter(getVertex4(), getVertex56(), getVertex57());
	var ringGeometry106 = new THREE.RingGeometry((inradius106 - 0.005),inradius106, 32);
	const ringMaterial106 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh106 = new THREE.Mesh(ringGeometry106, ringMaterial106);

	function setCircleRotation106(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.52941176470588236],[0.,0.,0.51960784313725483]);

        ringMesh106.position.setX(incenter[0]);
        ringMesh106.position.setY(incenter[1]);
        ringMesh106.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex56(), getVertex57());
        var relRadius = inradius/inradius106;

        ringMesh106.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A106 = new THREE.Vector3(-1.,0.,1.);
        const B106 = new THREE.Vector3(0.,0.,0.52941176470588236);
        const C106 = new THREE.Vector3(0.,0.,0.51960784313725483);

        const normalVec106 = new THREE.Vector3();
        normalVec106.crossVectors(B106.sub(A106), C106.sub(A106));
        normalVec106.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal106 = new THREE.Vector3(0,0,1);

        const quaternionRotation106 = new THREE.Quaternion();
        quaternionRotation106.setFromUnitVectors(initialNormal106, normalVec106);

        ringMesh106.setRotationFromQuaternion(quaternionRotation106);

        return quaternionRotation106;
    }

    ringRoot.add(ringMesh106);
            
	var inradius107 = calulateInradius(getVertex3(), getVertex60(), getVertex61());
	var incenter107 = calulateIncenter(getVertex3(), getVertex60(), getVertex61());
	var ringGeometry107 = new THREE.RingGeometry((inradius107 - 0.005),inradius107, 32);
	const ringMaterial107 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh107 = new THREE.Mesh(ringGeometry107, ringMaterial107);

	function setCircleRotation107(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.49019607843137258],[0.,0.,0.48039215686274506]);

        ringMesh107.position.setX(incenter[0]);
        ringMesh107.position.setY(incenter[1]);
        ringMesh107.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex60(), getVertex61());
        var relRadius = inradius/inradius107;

        ringMesh107.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A107 = new THREE.Vector3(-1.,0.,0.);
        const B107 = new THREE.Vector3(0.,0.,0.49019607843137258);
        const C107 = new THREE.Vector3(0.,0.,0.48039215686274506);

        const normalVec107 = new THREE.Vector3();
        normalVec107.crossVectors(B107.sub(A107), C107.sub(A107));
        normalVec107.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal107 = new THREE.Vector3(0,0,1);

        const quaternionRotation107 = new THREE.Quaternion();
        quaternionRotation107.setFromUnitVectors(initialNormal107, normalVec107);

        ringMesh107.setRotationFromQuaternion(quaternionRotation107);

        return quaternionRotation107;
    }

    ringRoot.add(ringMesh107);
            
	var inradius108 = calulateInradius(getVertex4(), getVertex57(), getVertex58());
	var incenter108 = calulateIncenter(getVertex4(), getVertex57(), getVertex58());
	var ringGeometry108 = new THREE.RingGeometry((inradius108 - 0.005),inradius108, 32);
	const ringMaterial108 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh108 = new THREE.Mesh(ringGeometry108, ringMaterial108);

	function setCircleRotation108(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.51960784313725483],[0.,0.,0.50980392156862742]);

        ringMesh108.position.setX(incenter[0]);
        ringMesh108.position.setY(incenter[1]);
        ringMesh108.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex57(), getVertex58());
        var relRadius = inradius/inradius108;

        ringMesh108.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A108 = new THREE.Vector3(-1.,0.,1.);
        const B108 = new THREE.Vector3(0.,0.,0.51960784313725483);
        const C108 = new THREE.Vector3(0.,0.,0.50980392156862742);

        const normalVec108 = new THREE.Vector3();
        normalVec108.crossVectors(B108.sub(A108), C108.sub(A108));
        normalVec108.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal108 = new THREE.Vector3(0,0,1);

        const quaternionRotation108 = new THREE.Quaternion();
        quaternionRotation108.setFromUnitVectors(initialNormal108, normalVec108);

        ringMesh108.setRotationFromQuaternion(quaternionRotation108);

        return quaternionRotation108;
    }

    ringRoot.add(ringMesh108);
            
	var inradius109 = calulateInradius(getVertex3(), getVertex59(), getVertex60());
	var incenter109 = calulateIncenter(getVertex3(), getVertex59(), getVertex60());
	var ringGeometry109 = new THREE.RingGeometry((inradius109 - 0.005),inradius109, 32);
	const ringMaterial109 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh109 = new THREE.Mesh(ringGeometry109, ringMaterial109);

	function setCircleRotation109(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.5],[0.,0.,0.49019607843137258]);

        ringMesh109.position.setX(incenter[0]);
        ringMesh109.position.setY(incenter[1]);
        ringMesh109.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex59(), getVertex60());
        var relRadius = inradius/inradius109;

        ringMesh109.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A109 = new THREE.Vector3(-1.,0.,0.);
        const B109 = new THREE.Vector3(0.,0.,0.5);
        const C109 = new THREE.Vector3(0.,0.,0.49019607843137258);

        const normalVec109 = new THREE.Vector3();
        normalVec109.crossVectors(B109.sub(A109), C109.sub(A109));
        normalVec109.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal109 = new THREE.Vector3(0,0,1);

        const quaternionRotation109 = new THREE.Quaternion();
        quaternionRotation109.setFromUnitVectors(initialNormal109, normalVec109);

        ringMesh109.setRotationFromQuaternion(quaternionRotation109);

        return quaternionRotation109;
    }

    ringRoot.add(ringMesh109);
            
	var inradius110 = calulateInradius(getVertex4(), getVertex58(), getVertex59());
	var incenter110 = calulateIncenter(getVertex4(), getVertex58(), getVertex59());
	var ringGeometry110 = new THREE.RingGeometry((inradius110 - 0.005),inradius110, 32);
	const ringMaterial110 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh110 = new THREE.Mesh(ringGeometry110, ringMaterial110);

	function setCircleRotation110(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.50980392156862742],[0.,0.,0.5]);

        ringMesh110.position.setX(incenter[0]);
        ringMesh110.position.setY(incenter[1]);
        ringMesh110.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex58(), getVertex59());
        var relRadius = inradius/inradius110;

        ringMesh110.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A110 = new THREE.Vector3(-1.,0.,1.);
        const B110 = new THREE.Vector3(0.,0.,0.50980392156862742);
        const C110 = new THREE.Vector3(0.,0.,0.5);

        const normalVec110 = new THREE.Vector3();
        normalVec110.crossVectors(B110.sub(A110), C110.sub(A110));
        normalVec110.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal110 = new THREE.Vector3(0,0,1);

        const quaternionRotation110 = new THREE.Quaternion();
        quaternionRotation110.setFromUnitVectors(initialNormal110, normalVec110);

        ringMesh110.setRotationFromQuaternion(quaternionRotation110);

        return quaternionRotation110;
    }

    ringRoot.add(ringMesh110);
            
	var inradius111 = calulateInradius(getVertex3(), getVertex4(), getVertex59());
	var incenter111 = calulateIncenter(getVertex3(), getVertex4(), getVertex59());
	var ringGeometry111 = new THREE.RingGeometry((inradius111 - 0.005),inradius111, 32);
	const ringMaterial111 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh111 = new THREE.Mesh(ringGeometry111, ringMaterial111);

	function setCircleRotation111(){

        //translate ring to incenter
        var incenter = calulateIncenter([-1.,0.,0.],[ -1.,0.,1.],[0.,0.,0.5]);

        ringMesh111.position.setX(incenter[0]);
        ringMesh111.position.setY(incenter[1]);
        ringMesh111.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex4(), getVertex59());
        var relRadius = inradius/inradius111;

        ringMesh111.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A111 = new THREE.Vector3(-1.,0.,0.);
        const B111 = new THREE.Vector3(-1.,0.,1.);
        const C111 = new THREE.Vector3(0.,0.,0.5);

        const normalVec111 = new THREE.Vector3();
        normalVec111.crossVectors(B111.sub(A111), C111.sub(A111));
        normalVec111.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal111 = new THREE.Vector3(0,0,1);

        const quaternionRotation111 = new THREE.Quaternion();
        quaternionRotation111.setFromUnitVectors(initialNormal111, normalVec111);

        ringMesh111.setRotationFromQuaternion(quaternionRotation111);

        return quaternionRotation111;
    }

    ringRoot.add(ringMesh111);
            
	var inradius112 = calulateInradius(getVertex6(), getVertex7(), getVertex109());
	var incenter112 = calulateIncenter(getVertex6(), getVertex7(), getVertex109());
	var ringGeometry112 = new THREE.RingGeometry((inradius112 - 0.005),inradius112, 32);
	const ringMaterial112 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh112 = new THREE.Mesh(ringGeometry112, ringMaterial112);

	function setCircleRotation112(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,0.,0.],[ 0.,-1.,0.],[0.,0.,0.0098039215686274161]);

        ringMesh112.position.setX(incenter[0]);
        ringMesh112.position.setY(incenter[1]);
        ringMesh112.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex6(), getVertex7(), getVertex109());
        var relRadius = inradius/inradius112;

        ringMesh112.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A112 = new THREE.Vector3(0.,0.,0.);
        const B112 = new THREE.Vector3(0.,-1.,0.);
        const C112 = new THREE.Vector3(0.,0.,0.0098039215686274161);

        const normalVec112 = new THREE.Vector3();
        normalVec112.crossVectors(B112.sub(A112), C112.sub(A112));
        normalVec112.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal112 = new THREE.Vector3(0,0,1);

        const quaternionRotation112 = new THREE.Quaternion();
        quaternionRotation112.setFromUnitVectors(initialNormal112, normalVec112);

        ringMesh112.setRotationFromQuaternion(quaternionRotation112);

        return quaternionRotation112;
    }

    ringRoot.add(ringMesh112);
            
	var inradius113 = calulateInradius(getVertex5(), getVertex8(), getVertex9());
	var incenter113 = calulateIncenter(getVertex5(), getVertex8(), getVertex9());
	var ringGeometry113 = new THREE.RingGeometry((inradius113 - 0.005),inradius113, 32);
	const ringMaterial113 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh113 = new THREE.Mesh(ringGeometry113, ringMaterial113);

	function setCircleRotation113(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,0.,1.],[ 0.,-1.,1.],[0.,0.,0.99019607843137258]);

        ringMesh113.position.setX(incenter[0]);
        ringMesh113.position.setY(incenter[1]);
        ringMesh113.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex5(), getVertex8(), getVertex9());
        var relRadius = inradius/inradius113;

        ringMesh113.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A113 = new THREE.Vector3(0.,0.,1.);
        const B113 = new THREE.Vector3(0.,-1.,1.);
        const C113 = new THREE.Vector3(0.,0.,0.99019607843137258);

        const normalVec113 = new THREE.Vector3();
        normalVec113.crossVectors(B113.sub(A113), C113.sub(A113));
        normalVec113.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal113 = new THREE.Vector3(0,0,1);

        const quaternionRotation113 = new THREE.Quaternion();
        quaternionRotation113.setFromUnitVectors(initialNormal113, normalVec113);

        ringMesh113.setRotationFromQuaternion(quaternionRotation113);

        return quaternionRotation113;
    }

    ringRoot.add(ringMesh113);
            
	var inradius114 = calulateInradius(getVertex7(), getVertex108(), getVertex109());
	var incenter114 = calulateIncenter(getVertex7(), getVertex108(), getVertex109());
	var ringGeometry114 = new THREE.RingGeometry((inradius114 - 0.005),inradius114, 32);
	const ringMaterial114 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh114 = new THREE.Mesh(ringGeometry114, ringMaterial114);

	function setCircleRotation114(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.019607843137254943],[0.,0.,0.0098039215686274161]);

        ringMesh114.position.setX(incenter[0]);
        ringMesh114.position.setY(incenter[1]);
        ringMesh114.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex108(), getVertex109());
        var relRadius = inradius/inradius114;

        ringMesh114.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A114 = new THREE.Vector3(0.,-1.,0.);
        const B114 = new THREE.Vector3(0.,0.,0.019607843137254943);
        const C114 = new THREE.Vector3(0.,0.,0.0098039215686274161);

        const normalVec114 = new THREE.Vector3();
        normalVec114.crossVectors(B114.sub(A114), C114.sub(A114));
        normalVec114.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal114 = new THREE.Vector3(0,0,1);

        const quaternionRotation114 = new THREE.Quaternion();
        quaternionRotation114.setFromUnitVectors(initialNormal114, normalVec114);

        ringMesh114.setRotationFromQuaternion(quaternionRotation114);

        return quaternionRotation114;
    }

    ringRoot.add(ringMesh114);
            
	var inradius115 = calulateInradius(getVertex8(), getVertex9(), getVertex10());
	var incenter115 = calulateIncenter(getVertex8(), getVertex9(), getVertex10());
	var ringGeometry115 = new THREE.RingGeometry((inradius115 - 0.005),inradius115, 32);
	const ringMaterial115 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh115 = new THREE.Mesh(ringGeometry115, ringMaterial115);

	function setCircleRotation115(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.99019607843137258],[0.,0.,0.98039215686274506]);

        ringMesh115.position.setX(incenter[0]);
        ringMesh115.position.setY(incenter[1]);
        ringMesh115.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex9(), getVertex10());
        var relRadius = inradius/inradius115;

        ringMesh115.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A115 = new THREE.Vector3(0.,-1.,1.);
        const B115 = new THREE.Vector3(0.,0.,0.99019607843137258);
        const C115 = new THREE.Vector3(0.,0.,0.98039215686274506);

        const normalVec115 = new THREE.Vector3();
        normalVec115.crossVectors(B115.sub(A115), C115.sub(A115));
        normalVec115.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal115 = new THREE.Vector3(0,0,1);

        const quaternionRotation115 = new THREE.Quaternion();
        quaternionRotation115.setFromUnitVectors(initialNormal115, normalVec115);

        ringMesh115.setRotationFromQuaternion(quaternionRotation115);

        return quaternionRotation115;
    }

    ringRoot.add(ringMesh115);
            
	var inradius116 = calulateInradius(getVertex7(), getVertex107(), getVertex108());
	var incenter116 = calulateIncenter(getVertex7(), getVertex107(), getVertex108());
	var ringGeometry116 = new THREE.RingGeometry((inradius116 - 0.005),inradius116, 32);
	const ringMaterial116 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh116 = new THREE.Mesh(ringGeometry116, ringMaterial116);

	function setCircleRotation116(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.029411764705882359],[0.,0.,0.019607843137254943]);

        ringMesh116.position.setX(incenter[0]);
        ringMesh116.position.setY(incenter[1]);
        ringMesh116.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex107(), getVertex108());
        var relRadius = inradius/inradius116;

        ringMesh116.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A116 = new THREE.Vector3(0.,-1.,0.);
        const B116 = new THREE.Vector3(0.,0.,0.029411764705882359);
        const C116 = new THREE.Vector3(0.,0.,0.019607843137254943);

        const normalVec116 = new THREE.Vector3();
        normalVec116.crossVectors(B116.sub(A116), C116.sub(A116));
        normalVec116.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal116 = new THREE.Vector3(0,0,1);

        const quaternionRotation116 = new THREE.Quaternion();
        quaternionRotation116.setFromUnitVectors(initialNormal116, normalVec116);

        ringMesh116.setRotationFromQuaternion(quaternionRotation116);

        return quaternionRotation116;
    }

    ringRoot.add(ringMesh116);
            
	var inradius117 = calulateInradius(getVertex8(), getVertex10(), getVertex11());
	var incenter117 = calulateIncenter(getVertex8(), getVertex10(), getVertex11());
	var ringGeometry117 = new THREE.RingGeometry((inradius117 - 0.005),inradius117, 32);
	const ringMaterial117 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh117 = new THREE.Mesh(ringGeometry117, ringMaterial117);

	function setCircleRotation117(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.98039215686274506],[0.,0.,0.97058823529411764]);

        ringMesh117.position.setX(incenter[0]);
        ringMesh117.position.setY(incenter[1]);
        ringMesh117.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex10(), getVertex11());
        var relRadius = inradius/inradius117;

        ringMesh117.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A117 = new THREE.Vector3(0.,-1.,1.);
        const B117 = new THREE.Vector3(0.,0.,0.98039215686274506);
        const C117 = new THREE.Vector3(0.,0.,0.97058823529411764);

        const normalVec117 = new THREE.Vector3();
        normalVec117.crossVectors(B117.sub(A117), C117.sub(A117));
        normalVec117.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal117 = new THREE.Vector3(0,0,1);

        const quaternionRotation117 = new THREE.Quaternion();
        quaternionRotation117.setFromUnitVectors(initialNormal117, normalVec117);

        ringMesh117.setRotationFromQuaternion(quaternionRotation117);

        return quaternionRotation117;
    }

    ringRoot.add(ringMesh117);
            
	var inradius118 = calulateInradius(getVertex7(), getVertex106(), getVertex107());
	var incenter118 = calulateIncenter(getVertex7(), getVertex106(), getVertex107());
	var ringGeometry118 = new THREE.RingGeometry((inradius118 - 0.005),inradius118, 32);
	const ringMaterial118 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh118 = new THREE.Mesh(ringGeometry118, ringMaterial118);

	function setCircleRotation118(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.039215686274509776],[0.,0.,0.029411764705882359]);

        ringMesh118.position.setX(incenter[0]);
        ringMesh118.position.setY(incenter[1]);
        ringMesh118.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex106(), getVertex107());
        var relRadius = inradius/inradius118;

        ringMesh118.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A118 = new THREE.Vector3(0.,-1.,0.);
        const B118 = new THREE.Vector3(0.,0.,0.039215686274509776);
        const C118 = new THREE.Vector3(0.,0.,0.029411764705882359);

        const normalVec118 = new THREE.Vector3();
        normalVec118.crossVectors(B118.sub(A118), C118.sub(A118));
        normalVec118.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal118 = new THREE.Vector3(0,0,1);

        const quaternionRotation118 = new THREE.Quaternion();
        quaternionRotation118.setFromUnitVectors(initialNormal118, normalVec118);

        ringMesh118.setRotationFromQuaternion(quaternionRotation118);

        return quaternionRotation118;
    }

    ringRoot.add(ringMesh118);
            
	var inradius119 = calulateInradius(getVertex8(), getVertex11(), getVertex12());
	var incenter119 = calulateIncenter(getVertex8(), getVertex11(), getVertex12());
	var ringGeometry119 = new THREE.RingGeometry((inradius119 - 0.005),inradius119, 32);
	const ringMaterial119 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh119 = new THREE.Mesh(ringGeometry119, ringMaterial119);

	function setCircleRotation119(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.97058823529411764],[0.,0.,0.96078431372549022]);

        ringMesh119.position.setX(incenter[0]);
        ringMesh119.position.setY(incenter[1]);
        ringMesh119.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex11(), getVertex12());
        var relRadius = inradius/inradius119;

        ringMesh119.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A119 = new THREE.Vector3(0.,-1.,1.);
        const B119 = new THREE.Vector3(0.,0.,0.97058823529411764);
        const C119 = new THREE.Vector3(0.,0.,0.96078431372549022);

        const normalVec119 = new THREE.Vector3();
        normalVec119.crossVectors(B119.sub(A119), C119.sub(A119));
        normalVec119.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal119 = new THREE.Vector3(0,0,1);

        const quaternionRotation119 = new THREE.Quaternion();
        quaternionRotation119.setFromUnitVectors(initialNormal119, normalVec119);

        ringMesh119.setRotationFromQuaternion(quaternionRotation119);

        return quaternionRotation119;
    }

    ringRoot.add(ringMesh119);
            
	var inradius120 = calulateInradius(getVertex7(), getVertex105(), getVertex106());
	var incenter120 = calulateIncenter(getVertex7(), getVertex105(), getVertex106());
	var ringGeometry120 = new THREE.RingGeometry((inradius120 - 0.005),inradius120, 32);
	const ringMaterial120 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh120 = new THREE.Mesh(ringGeometry120, ringMaterial120);

	function setCircleRotation120(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.049019607843137303],[0.,0.,0.039215686274509776]);

        ringMesh120.position.setX(incenter[0]);
        ringMesh120.position.setY(incenter[1]);
        ringMesh120.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex105(), getVertex106());
        var relRadius = inradius/inradius120;

        ringMesh120.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A120 = new THREE.Vector3(0.,-1.,0.);
        const B120 = new THREE.Vector3(0.,0.,0.049019607843137303);
        const C120 = new THREE.Vector3(0.,0.,0.039215686274509776);

        const normalVec120 = new THREE.Vector3();
        normalVec120.crossVectors(B120.sub(A120), C120.sub(A120));
        normalVec120.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal120 = new THREE.Vector3(0,0,1);

        const quaternionRotation120 = new THREE.Quaternion();
        quaternionRotation120.setFromUnitVectors(initialNormal120, normalVec120);

        ringMesh120.setRotationFromQuaternion(quaternionRotation120);

        return quaternionRotation120;
    }

    ringRoot.add(ringMesh120);
            
	var inradius121 = calulateInradius(getVertex8(), getVertex12(), getVertex13());
	var incenter121 = calulateIncenter(getVertex8(), getVertex12(), getVertex13());
	var ringGeometry121 = new THREE.RingGeometry((inradius121 - 0.005),inradius121, 32);
	const ringMaterial121 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh121 = new THREE.Mesh(ringGeometry121, ringMaterial121);

	function setCircleRotation121(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.96078431372549022],[0.,0.,0.9509803921568627]);

        ringMesh121.position.setX(incenter[0]);
        ringMesh121.position.setY(incenter[1]);
        ringMesh121.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex12(), getVertex13());
        var relRadius = inradius/inradius121;

        ringMesh121.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A121 = new THREE.Vector3(0.,-1.,1.);
        const B121 = new THREE.Vector3(0.,0.,0.96078431372549022);
        const C121 = new THREE.Vector3(0.,0.,0.9509803921568627);

        const normalVec121 = new THREE.Vector3();
        normalVec121.crossVectors(B121.sub(A121), C121.sub(A121));
        normalVec121.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal121 = new THREE.Vector3(0,0,1);

        const quaternionRotation121 = new THREE.Quaternion();
        quaternionRotation121.setFromUnitVectors(initialNormal121, normalVec121);

        ringMesh121.setRotationFromQuaternion(quaternionRotation121);

        return quaternionRotation121;
    }

    ringRoot.add(ringMesh121);
            
	var inradius122 = calulateInradius(getVertex7(), getVertex104(), getVertex105());
	var incenter122 = calulateIncenter(getVertex7(), getVertex104(), getVertex105());
	var ringGeometry122 = new THREE.RingGeometry((inradius122 - 0.005),inradius122, 32);
	const ringMaterial122 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh122 = new THREE.Mesh(ringGeometry122, ringMaterial122);

	function setCircleRotation122(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.058823529411764719],[0.,0.,0.049019607843137303]);

        ringMesh122.position.setX(incenter[0]);
        ringMesh122.position.setY(incenter[1]);
        ringMesh122.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex104(), getVertex105());
        var relRadius = inradius/inradius122;

        ringMesh122.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A122 = new THREE.Vector3(0.,-1.,0.);
        const B122 = new THREE.Vector3(0.,0.,0.058823529411764719);
        const C122 = new THREE.Vector3(0.,0.,0.049019607843137303);

        const normalVec122 = new THREE.Vector3();
        normalVec122.crossVectors(B122.sub(A122), C122.sub(A122));
        normalVec122.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal122 = new THREE.Vector3(0,0,1);

        const quaternionRotation122 = new THREE.Quaternion();
        quaternionRotation122.setFromUnitVectors(initialNormal122, normalVec122);

        ringMesh122.setRotationFromQuaternion(quaternionRotation122);

        return quaternionRotation122;
    }

    ringRoot.add(ringMesh122);
            
	var inradius123 = calulateInradius(getVertex8(), getVertex13(), getVertex14());
	var incenter123 = calulateIncenter(getVertex8(), getVertex13(), getVertex14());
	var ringGeometry123 = new THREE.RingGeometry((inradius123 - 0.005),inradius123, 32);
	const ringMaterial123 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh123 = new THREE.Mesh(ringGeometry123, ringMaterial123);

	function setCircleRotation123(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.9509803921568627],[0.,0.,0.94117647058823528]);

        ringMesh123.position.setX(incenter[0]);
        ringMesh123.position.setY(incenter[1]);
        ringMesh123.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex13(), getVertex14());
        var relRadius = inradius/inradius123;

        ringMesh123.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A123 = new THREE.Vector3(0.,-1.,1.);
        const B123 = new THREE.Vector3(0.,0.,0.9509803921568627);
        const C123 = new THREE.Vector3(0.,0.,0.94117647058823528);

        const normalVec123 = new THREE.Vector3();
        normalVec123.crossVectors(B123.sub(A123), C123.sub(A123));
        normalVec123.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal123 = new THREE.Vector3(0,0,1);

        const quaternionRotation123 = new THREE.Quaternion();
        quaternionRotation123.setFromUnitVectors(initialNormal123, normalVec123);

        ringMesh123.setRotationFromQuaternion(quaternionRotation123);

        return quaternionRotation123;
    }

    ringRoot.add(ringMesh123);
            
	var inradius124 = calulateInradius(getVertex7(), getVertex103(), getVertex104());
	var incenter124 = calulateIncenter(getVertex7(), getVertex103(), getVertex104());
	var ringGeometry124 = new THREE.RingGeometry((inradius124 - 0.005),inradius124, 32);
	const ringMaterial124 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh124 = new THREE.Mesh(ringGeometry124, ringMaterial124);

	function setCircleRotation124(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.068627450980392135],[0.,0.,0.058823529411764719]);

        ringMesh124.position.setX(incenter[0]);
        ringMesh124.position.setY(incenter[1]);
        ringMesh124.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex103(), getVertex104());
        var relRadius = inradius/inradius124;

        ringMesh124.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A124 = new THREE.Vector3(0.,-1.,0.);
        const B124 = new THREE.Vector3(0.,0.,0.068627450980392135);
        const C124 = new THREE.Vector3(0.,0.,0.058823529411764719);

        const normalVec124 = new THREE.Vector3();
        normalVec124.crossVectors(B124.sub(A124), C124.sub(A124));
        normalVec124.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal124 = new THREE.Vector3(0,0,1);

        const quaternionRotation124 = new THREE.Quaternion();
        quaternionRotation124.setFromUnitVectors(initialNormal124, normalVec124);

        ringMesh124.setRotationFromQuaternion(quaternionRotation124);

        return quaternionRotation124;
    }

    ringRoot.add(ringMesh124);
            
	var inradius125 = calulateInradius(getVertex8(), getVertex14(), getVertex15());
	var incenter125 = calulateIncenter(getVertex8(), getVertex14(), getVertex15());
	var ringGeometry125 = new THREE.RingGeometry((inradius125 - 0.005),inradius125, 32);
	const ringMaterial125 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh125 = new THREE.Mesh(ringGeometry125, ringMaterial125);

	function setCircleRotation125(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.94117647058823528],[0.,0.,0.93137254901960786]);

        ringMesh125.position.setX(incenter[0]);
        ringMesh125.position.setY(incenter[1]);
        ringMesh125.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex14(), getVertex15());
        var relRadius = inradius/inradius125;

        ringMesh125.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A125 = new THREE.Vector3(0.,-1.,1.);
        const B125 = new THREE.Vector3(0.,0.,0.94117647058823528);
        const C125 = new THREE.Vector3(0.,0.,0.93137254901960786);

        const normalVec125 = new THREE.Vector3();
        normalVec125.crossVectors(B125.sub(A125), C125.sub(A125));
        normalVec125.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal125 = new THREE.Vector3(0,0,1);

        const quaternionRotation125 = new THREE.Quaternion();
        quaternionRotation125.setFromUnitVectors(initialNormal125, normalVec125);

        ringMesh125.setRotationFromQuaternion(quaternionRotation125);

        return quaternionRotation125;
    }

    ringRoot.add(ringMesh125);
            
	var inradius126 = calulateInradius(getVertex7(), getVertex102(), getVertex103());
	var incenter126 = calulateIncenter(getVertex7(), getVertex102(), getVertex103());
	var ringGeometry126 = new THREE.RingGeometry((inradius126 - 0.005),inradius126, 32);
	const ringMaterial126 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh126 = new THREE.Mesh(ringGeometry126, ringMaterial126);

	function setCircleRotation126(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.078431372549019662],[0.,0.,0.068627450980392135]);

        ringMesh126.position.setX(incenter[0]);
        ringMesh126.position.setY(incenter[1]);
        ringMesh126.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex102(), getVertex103());
        var relRadius = inradius/inradius126;

        ringMesh126.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A126 = new THREE.Vector3(0.,-1.,0.);
        const B126 = new THREE.Vector3(0.,0.,0.078431372549019662);
        const C126 = new THREE.Vector3(0.,0.,0.068627450980392135);

        const normalVec126 = new THREE.Vector3();
        normalVec126.crossVectors(B126.sub(A126), C126.sub(A126));
        normalVec126.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal126 = new THREE.Vector3(0,0,1);

        const quaternionRotation126 = new THREE.Quaternion();
        quaternionRotation126.setFromUnitVectors(initialNormal126, normalVec126);

        ringMesh126.setRotationFromQuaternion(quaternionRotation126);

        return quaternionRotation126;
    }

    ringRoot.add(ringMesh126);
            
	var inradius127 = calulateInradius(getVertex8(), getVertex15(), getVertex16());
	var incenter127 = calulateIncenter(getVertex8(), getVertex15(), getVertex16());
	var ringGeometry127 = new THREE.RingGeometry((inradius127 - 0.005),inradius127, 32);
	const ringMaterial127 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh127 = new THREE.Mesh(ringGeometry127, ringMaterial127);

	function setCircleRotation127(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.93137254901960786],[0.,0.,0.92156862745098045]);

        ringMesh127.position.setX(incenter[0]);
        ringMesh127.position.setY(incenter[1]);
        ringMesh127.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex15(), getVertex16());
        var relRadius = inradius/inradius127;

        ringMesh127.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A127 = new THREE.Vector3(0.,-1.,1.);
        const B127 = new THREE.Vector3(0.,0.,0.93137254901960786);
        const C127 = new THREE.Vector3(0.,0.,0.92156862745098045);

        const normalVec127 = new THREE.Vector3();
        normalVec127.crossVectors(B127.sub(A127), C127.sub(A127));
        normalVec127.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal127 = new THREE.Vector3(0,0,1);

        const quaternionRotation127 = new THREE.Quaternion();
        quaternionRotation127.setFromUnitVectors(initialNormal127, normalVec127);

        ringMesh127.setRotationFromQuaternion(quaternionRotation127);

        return quaternionRotation127;
    }

    ringRoot.add(ringMesh127);
            
	var inradius128 = calulateInradius(getVertex7(), getVertex101(), getVertex102());
	var incenter128 = calulateIncenter(getVertex7(), getVertex101(), getVertex102());
	var ringGeometry128 = new THREE.RingGeometry((inradius128 - 0.005),inradius128, 32);
	const ringMaterial128 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh128 = new THREE.Mesh(ringGeometry128, ringMaterial128);

	function setCircleRotation128(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.088235294117647078],[0.,0.,0.078431372549019662]);

        ringMesh128.position.setX(incenter[0]);
        ringMesh128.position.setY(incenter[1]);
        ringMesh128.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex101(), getVertex102());
        var relRadius = inradius/inradius128;

        ringMesh128.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A128 = new THREE.Vector3(0.,-1.,0.);
        const B128 = new THREE.Vector3(0.,0.,0.088235294117647078);
        const C128 = new THREE.Vector3(0.,0.,0.078431372549019662);

        const normalVec128 = new THREE.Vector3();
        normalVec128.crossVectors(B128.sub(A128), C128.sub(A128));
        normalVec128.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal128 = new THREE.Vector3(0,0,1);

        const quaternionRotation128 = new THREE.Quaternion();
        quaternionRotation128.setFromUnitVectors(initialNormal128, normalVec128);

        ringMesh128.setRotationFromQuaternion(quaternionRotation128);

        return quaternionRotation128;
    }

    ringRoot.add(ringMesh128);
            
	var inradius129 = calulateInradius(getVertex8(), getVertex16(), getVertex17());
	var incenter129 = calulateIncenter(getVertex8(), getVertex16(), getVertex17());
	var ringGeometry129 = new THREE.RingGeometry((inradius129 - 0.005),inradius129, 32);
	const ringMaterial129 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh129 = new THREE.Mesh(ringGeometry129, ringMaterial129);

	function setCircleRotation129(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.92156862745098045],[0.,0.,0.91176470588235292]);

        ringMesh129.position.setX(incenter[0]);
        ringMesh129.position.setY(incenter[1]);
        ringMesh129.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex16(), getVertex17());
        var relRadius = inradius/inradius129;

        ringMesh129.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A129 = new THREE.Vector3(0.,-1.,1.);
        const B129 = new THREE.Vector3(0.,0.,0.92156862745098045);
        const C129 = new THREE.Vector3(0.,0.,0.91176470588235292);

        const normalVec129 = new THREE.Vector3();
        normalVec129.crossVectors(B129.sub(A129), C129.sub(A129));
        normalVec129.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal129 = new THREE.Vector3(0,0,1);

        const quaternionRotation129 = new THREE.Quaternion();
        quaternionRotation129.setFromUnitVectors(initialNormal129, normalVec129);

        ringMesh129.setRotationFromQuaternion(quaternionRotation129);

        return quaternionRotation129;
    }

    ringRoot.add(ringMesh129);
            
	var inradius130 = calulateInradius(getVertex7(), getVertex100(), getVertex101());
	var incenter130 = calulateIncenter(getVertex7(), getVertex100(), getVertex101());
	var ringGeometry130 = new THREE.RingGeometry((inradius130 - 0.005),inradius130, 32);
	const ringMaterial130 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh130 = new THREE.Mesh(ringGeometry130, ringMaterial130);

	function setCircleRotation130(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.098039215686274495],[0.,0.,0.088235294117647078]);

        ringMesh130.position.setX(incenter[0]);
        ringMesh130.position.setY(incenter[1]);
        ringMesh130.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex100(), getVertex101());
        var relRadius = inradius/inradius130;

        ringMesh130.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A130 = new THREE.Vector3(0.,-1.,0.);
        const B130 = new THREE.Vector3(0.,0.,0.098039215686274495);
        const C130 = new THREE.Vector3(0.,0.,0.088235294117647078);

        const normalVec130 = new THREE.Vector3();
        normalVec130.crossVectors(B130.sub(A130), C130.sub(A130));
        normalVec130.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal130 = new THREE.Vector3(0,0,1);

        const quaternionRotation130 = new THREE.Quaternion();
        quaternionRotation130.setFromUnitVectors(initialNormal130, normalVec130);

        ringMesh130.setRotationFromQuaternion(quaternionRotation130);

        return quaternionRotation130;
    }

    ringRoot.add(ringMesh130);
            
	var inradius131 = calulateInradius(getVertex8(), getVertex17(), getVertex18());
	var incenter131 = calulateIncenter(getVertex8(), getVertex17(), getVertex18());
	var ringGeometry131 = new THREE.RingGeometry((inradius131 - 0.005),inradius131, 32);
	const ringMaterial131 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh131 = new THREE.Mesh(ringGeometry131, ringMaterial131);

	function setCircleRotation131(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.91176470588235292],[0.,0.,0.90196078431372551]);

        ringMesh131.position.setX(incenter[0]);
        ringMesh131.position.setY(incenter[1]);
        ringMesh131.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex17(), getVertex18());
        var relRadius = inradius/inradius131;

        ringMesh131.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A131 = new THREE.Vector3(0.,-1.,1.);
        const B131 = new THREE.Vector3(0.,0.,0.91176470588235292);
        const C131 = new THREE.Vector3(0.,0.,0.90196078431372551);

        const normalVec131 = new THREE.Vector3();
        normalVec131.crossVectors(B131.sub(A131), C131.sub(A131));
        normalVec131.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal131 = new THREE.Vector3(0,0,1);

        const quaternionRotation131 = new THREE.Quaternion();
        quaternionRotation131.setFromUnitVectors(initialNormal131, normalVec131);

        ringMesh131.setRotationFromQuaternion(quaternionRotation131);

        return quaternionRotation131;
    }

    ringRoot.add(ringMesh131);
            
	var inradius132 = calulateInradius(getVertex7(), getVertex99(), getVertex100());
	var incenter132 = calulateIncenter(getVertex7(), getVertex99(), getVertex100());
	var ringGeometry132 = new THREE.RingGeometry((inradius132 - 0.005),inradius132, 32);
	const ringMaterial132 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh132 = new THREE.Mesh(ringGeometry132, ringMaterial132);

	function setCircleRotation132(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.10784313725490202],[0.,0.,0.098039215686274495]);

        ringMesh132.position.setX(incenter[0]);
        ringMesh132.position.setY(incenter[1]);
        ringMesh132.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex99(), getVertex100());
        var relRadius = inradius/inradius132;

        ringMesh132.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A132 = new THREE.Vector3(0.,-1.,0.);
        const B132 = new THREE.Vector3(0.,0.,0.10784313725490202);
        const C132 = new THREE.Vector3(0.,0.,0.098039215686274495);

        const normalVec132 = new THREE.Vector3();
        normalVec132.crossVectors(B132.sub(A132), C132.sub(A132));
        normalVec132.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal132 = new THREE.Vector3(0,0,1);

        const quaternionRotation132 = new THREE.Quaternion();
        quaternionRotation132.setFromUnitVectors(initialNormal132, normalVec132);

        ringMesh132.setRotationFromQuaternion(quaternionRotation132);

        return quaternionRotation132;
    }

    ringRoot.add(ringMesh132);
            
	var inradius133 = calulateInradius(getVertex8(), getVertex18(), getVertex19());
	var incenter133 = calulateIncenter(getVertex8(), getVertex18(), getVertex19());
	var ringGeometry133 = new THREE.RingGeometry((inradius133 - 0.005),inradius133, 32);
	const ringMaterial133 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh133 = new THREE.Mesh(ringGeometry133, ringMaterial133);

	function setCircleRotation133(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.90196078431372551],[0.,0.,0.89215686274509798]);

        ringMesh133.position.setX(incenter[0]);
        ringMesh133.position.setY(incenter[1]);
        ringMesh133.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex18(), getVertex19());
        var relRadius = inradius/inradius133;

        ringMesh133.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A133 = new THREE.Vector3(0.,-1.,1.);
        const B133 = new THREE.Vector3(0.,0.,0.90196078431372551);
        const C133 = new THREE.Vector3(0.,0.,0.89215686274509798);

        const normalVec133 = new THREE.Vector3();
        normalVec133.crossVectors(B133.sub(A133), C133.sub(A133));
        normalVec133.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal133 = new THREE.Vector3(0,0,1);

        const quaternionRotation133 = new THREE.Quaternion();
        quaternionRotation133.setFromUnitVectors(initialNormal133, normalVec133);

        ringMesh133.setRotationFromQuaternion(quaternionRotation133);

        return quaternionRotation133;
    }

    ringRoot.add(ringMesh133);
            
	var inradius134 = calulateInradius(getVertex7(), getVertex98(), getVertex99());
	var incenter134 = calulateIncenter(getVertex7(), getVertex98(), getVertex99());
	var ringGeometry134 = new THREE.RingGeometry((inradius134 - 0.005),inradius134, 32);
	const ringMaterial134 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh134 = new THREE.Mesh(ringGeometry134, ringMaterial134);

	function setCircleRotation134(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.11764705882352944],[0.,0.,0.10784313725490202]);

        ringMesh134.position.setX(incenter[0]);
        ringMesh134.position.setY(incenter[1]);
        ringMesh134.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex98(), getVertex99());
        var relRadius = inradius/inradius134;

        ringMesh134.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A134 = new THREE.Vector3(0.,-1.,0.);
        const B134 = new THREE.Vector3(0.,0.,0.11764705882352944);
        const C134 = new THREE.Vector3(0.,0.,0.10784313725490202);

        const normalVec134 = new THREE.Vector3();
        normalVec134.crossVectors(B134.sub(A134), C134.sub(A134));
        normalVec134.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal134 = new THREE.Vector3(0,0,1);

        const quaternionRotation134 = new THREE.Quaternion();
        quaternionRotation134.setFromUnitVectors(initialNormal134, normalVec134);

        ringMesh134.setRotationFromQuaternion(quaternionRotation134);

        return quaternionRotation134;
    }

    ringRoot.add(ringMesh134);
            
	var inradius135 = calulateInradius(getVertex8(), getVertex19(), getVertex20());
	var incenter135 = calulateIncenter(getVertex8(), getVertex19(), getVertex20());
	var ringGeometry135 = new THREE.RingGeometry((inradius135 - 0.005),inradius135, 32);
	const ringMaterial135 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh135 = new THREE.Mesh(ringGeometry135, ringMaterial135);

	function setCircleRotation135(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.89215686274509798],[0.,0.,0.88235294117647056]);

        ringMesh135.position.setX(incenter[0]);
        ringMesh135.position.setY(incenter[1]);
        ringMesh135.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex19(), getVertex20());
        var relRadius = inradius/inradius135;

        ringMesh135.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A135 = new THREE.Vector3(0.,-1.,1.);
        const B135 = new THREE.Vector3(0.,0.,0.89215686274509798);
        const C135 = new THREE.Vector3(0.,0.,0.88235294117647056);

        const normalVec135 = new THREE.Vector3();
        normalVec135.crossVectors(B135.sub(A135), C135.sub(A135));
        normalVec135.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal135 = new THREE.Vector3(0,0,1);

        const quaternionRotation135 = new THREE.Quaternion();
        quaternionRotation135.setFromUnitVectors(initialNormal135, normalVec135);

        ringMesh135.setRotationFromQuaternion(quaternionRotation135);

        return quaternionRotation135;
    }

    ringRoot.add(ringMesh135);
            
	var inradius136 = calulateInradius(getVertex7(), getVertex97(), getVertex98());
	var incenter136 = calulateIncenter(getVertex7(), getVertex97(), getVertex98());
	var ringGeometry136 = new THREE.RingGeometry((inradius136 - 0.005),inradius136, 32);
	const ringMaterial136 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh136 = new THREE.Mesh(ringGeometry136, ringMaterial136);

	function setCircleRotation136(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.12745098039215685],[0.,0.,0.11764705882352944]);

        ringMesh136.position.setX(incenter[0]);
        ringMesh136.position.setY(incenter[1]);
        ringMesh136.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex97(), getVertex98());
        var relRadius = inradius/inradius136;

        ringMesh136.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A136 = new THREE.Vector3(0.,-1.,0.);
        const B136 = new THREE.Vector3(0.,0.,0.12745098039215685);
        const C136 = new THREE.Vector3(0.,0.,0.11764705882352944);

        const normalVec136 = new THREE.Vector3();
        normalVec136.crossVectors(B136.sub(A136), C136.sub(A136));
        normalVec136.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal136 = new THREE.Vector3(0,0,1);

        const quaternionRotation136 = new THREE.Quaternion();
        quaternionRotation136.setFromUnitVectors(initialNormal136, normalVec136);

        ringMesh136.setRotationFromQuaternion(quaternionRotation136);

        return quaternionRotation136;
    }

    ringRoot.add(ringMesh136);
            
	var inradius137 = calulateInradius(getVertex8(), getVertex20(), getVertex21());
	var incenter137 = calulateIncenter(getVertex8(), getVertex20(), getVertex21());
	var ringGeometry137 = new THREE.RingGeometry((inradius137 - 0.005),inradius137, 32);
	const ringMaterial137 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh137 = new THREE.Mesh(ringGeometry137, ringMaterial137);

	function setCircleRotation137(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.88235294117647056],[0.,0.,0.87254901960784315]);

        ringMesh137.position.setX(incenter[0]);
        ringMesh137.position.setY(incenter[1]);
        ringMesh137.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex20(), getVertex21());
        var relRadius = inradius/inradius137;

        ringMesh137.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A137 = new THREE.Vector3(0.,-1.,1.);
        const B137 = new THREE.Vector3(0.,0.,0.88235294117647056);
        const C137 = new THREE.Vector3(0.,0.,0.87254901960784315);

        const normalVec137 = new THREE.Vector3();
        normalVec137.crossVectors(B137.sub(A137), C137.sub(A137));
        normalVec137.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal137 = new THREE.Vector3(0,0,1);

        const quaternionRotation137 = new THREE.Quaternion();
        quaternionRotation137.setFromUnitVectors(initialNormal137, normalVec137);

        ringMesh137.setRotationFromQuaternion(quaternionRotation137);

        return quaternionRotation137;
    }

    ringRoot.add(ringMesh137);
            
	var inradius138 = calulateInradius(getVertex7(), getVertex96(), getVertex97());
	var incenter138 = calulateIncenter(getVertex7(), getVertex96(), getVertex97());
	var ringGeometry138 = new THREE.RingGeometry((inradius138 - 0.005),inradius138, 32);
	const ringMaterial138 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh138 = new THREE.Mesh(ringGeometry138, ringMaterial138);

	function setCircleRotation138(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.13725490196078427],[0.,0.,0.12745098039215685]);

        ringMesh138.position.setX(incenter[0]);
        ringMesh138.position.setY(incenter[1]);
        ringMesh138.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex96(), getVertex97());
        var relRadius = inradius/inradius138;

        ringMesh138.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A138 = new THREE.Vector3(0.,-1.,0.);
        const B138 = new THREE.Vector3(0.,0.,0.13725490196078427);
        const C138 = new THREE.Vector3(0.,0.,0.12745098039215685);

        const normalVec138 = new THREE.Vector3();
        normalVec138.crossVectors(B138.sub(A138), C138.sub(A138));
        normalVec138.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal138 = new THREE.Vector3(0,0,1);

        const quaternionRotation138 = new THREE.Quaternion();
        quaternionRotation138.setFromUnitVectors(initialNormal138, normalVec138);

        ringMesh138.setRotationFromQuaternion(quaternionRotation138);

        return quaternionRotation138;
    }

    ringRoot.add(ringMesh138);
            
	var inradius139 = calulateInradius(getVertex8(), getVertex21(), getVertex22());
	var incenter139 = calulateIncenter(getVertex8(), getVertex21(), getVertex22());
	var ringGeometry139 = new THREE.RingGeometry((inradius139 - 0.005),inradius139, 32);
	const ringMaterial139 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh139 = new THREE.Mesh(ringGeometry139, ringMaterial139);

	function setCircleRotation139(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.87254901960784315],[0.,0.,0.86274509803921573]);

        ringMesh139.position.setX(incenter[0]);
        ringMesh139.position.setY(incenter[1]);
        ringMesh139.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex21(), getVertex22());
        var relRadius = inradius/inradius139;

        ringMesh139.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A139 = new THREE.Vector3(0.,-1.,1.);
        const B139 = new THREE.Vector3(0.,0.,0.87254901960784315);
        const C139 = new THREE.Vector3(0.,0.,0.86274509803921573);

        const normalVec139 = new THREE.Vector3();
        normalVec139.crossVectors(B139.sub(A139), C139.sub(A139));
        normalVec139.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal139 = new THREE.Vector3(0,0,1);

        const quaternionRotation139 = new THREE.Quaternion();
        quaternionRotation139.setFromUnitVectors(initialNormal139, normalVec139);

        ringMesh139.setRotationFromQuaternion(quaternionRotation139);

        return quaternionRotation139;
    }

    ringRoot.add(ringMesh139);
            
	var inradius140 = calulateInradius(getVertex7(), getVertex95(), getVertex96());
	var incenter140 = calulateIncenter(getVertex7(), getVertex95(), getVertex96());
	var ringGeometry140 = new THREE.RingGeometry((inradius140 - 0.005),inradius140, 32);
	const ringMaterial140 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh140 = new THREE.Mesh(ringGeometry140, ringMaterial140);

	function setCircleRotation140(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.1470588235294118],[0.,0.,0.13725490196078427]);

        ringMesh140.position.setX(incenter[0]);
        ringMesh140.position.setY(incenter[1]);
        ringMesh140.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex95(), getVertex96());
        var relRadius = inradius/inradius140;

        ringMesh140.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A140 = new THREE.Vector3(0.,-1.,0.);
        const B140 = new THREE.Vector3(0.,0.,0.1470588235294118);
        const C140 = new THREE.Vector3(0.,0.,0.13725490196078427);

        const normalVec140 = new THREE.Vector3();
        normalVec140.crossVectors(B140.sub(A140), C140.sub(A140));
        normalVec140.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal140 = new THREE.Vector3(0,0,1);

        const quaternionRotation140 = new THREE.Quaternion();
        quaternionRotation140.setFromUnitVectors(initialNormal140, normalVec140);

        ringMesh140.setRotationFromQuaternion(quaternionRotation140);

        return quaternionRotation140;
    }

    ringRoot.add(ringMesh140);
            
	var inradius141 = calulateInradius(getVertex8(), getVertex22(), getVertex23());
	var incenter141 = calulateIncenter(getVertex8(), getVertex22(), getVertex23());
	var ringGeometry141 = new THREE.RingGeometry((inradius141 - 0.005),inradius141, 32);
	const ringMaterial141 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh141 = new THREE.Mesh(ringGeometry141, ringMaterial141);

	function setCircleRotation141(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.86274509803921573],[0.,0.,0.8529411764705882]);

        ringMesh141.position.setX(incenter[0]);
        ringMesh141.position.setY(incenter[1]);
        ringMesh141.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex22(), getVertex23());
        var relRadius = inradius/inradius141;

        ringMesh141.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A141 = new THREE.Vector3(0.,-1.,1.);
        const B141 = new THREE.Vector3(0.,0.,0.86274509803921573);
        const C141 = new THREE.Vector3(0.,0.,0.8529411764705882);

        const normalVec141 = new THREE.Vector3();
        normalVec141.crossVectors(B141.sub(A141), C141.sub(A141));
        normalVec141.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal141 = new THREE.Vector3(0,0,1);

        const quaternionRotation141 = new THREE.Quaternion();
        quaternionRotation141.setFromUnitVectors(initialNormal141, normalVec141);

        ringMesh141.setRotationFromQuaternion(quaternionRotation141);

        return quaternionRotation141;
    }

    ringRoot.add(ringMesh141);
            
	var inradius142 = calulateInradius(getVertex7(), getVertex94(), getVertex95());
	var incenter142 = calulateIncenter(getVertex7(), getVertex94(), getVertex95());
	var ringGeometry142 = new THREE.RingGeometry((inradius142 - 0.005),inradius142, 32);
	const ringMaterial142 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh142 = new THREE.Mesh(ringGeometry142, ringMaterial142);

	function setCircleRotation142(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.15686274509803921],[0.,0.,0.1470588235294118]);

        ringMesh142.position.setX(incenter[0]);
        ringMesh142.position.setY(incenter[1]);
        ringMesh142.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex94(), getVertex95());
        var relRadius = inradius/inradius142;

        ringMesh142.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A142 = new THREE.Vector3(0.,-1.,0.);
        const B142 = new THREE.Vector3(0.,0.,0.15686274509803921);
        const C142 = new THREE.Vector3(0.,0.,0.1470588235294118);

        const normalVec142 = new THREE.Vector3();
        normalVec142.crossVectors(B142.sub(A142), C142.sub(A142));
        normalVec142.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal142 = new THREE.Vector3(0,0,1);

        const quaternionRotation142 = new THREE.Quaternion();
        quaternionRotation142.setFromUnitVectors(initialNormal142, normalVec142);

        ringMesh142.setRotationFromQuaternion(quaternionRotation142);

        return quaternionRotation142;
    }

    ringRoot.add(ringMesh142);
            
	var inradius143 = calulateInradius(getVertex8(), getVertex23(), getVertex24());
	var incenter143 = calulateIncenter(getVertex8(), getVertex23(), getVertex24());
	var ringGeometry143 = new THREE.RingGeometry((inradius143 - 0.005),inradius143, 32);
	const ringMaterial143 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh143 = new THREE.Mesh(ringGeometry143, ringMaterial143);

	function setCircleRotation143(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.8529411764705882],[0.,0.,0.84313725490196079]);

        ringMesh143.position.setX(incenter[0]);
        ringMesh143.position.setY(incenter[1]);
        ringMesh143.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex23(), getVertex24());
        var relRadius = inradius/inradius143;

        ringMesh143.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A143 = new THREE.Vector3(0.,-1.,1.);
        const B143 = new THREE.Vector3(0.,0.,0.8529411764705882);
        const C143 = new THREE.Vector3(0.,0.,0.84313725490196079);

        const normalVec143 = new THREE.Vector3();
        normalVec143.crossVectors(B143.sub(A143), C143.sub(A143));
        normalVec143.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal143 = new THREE.Vector3(0,0,1);

        const quaternionRotation143 = new THREE.Quaternion();
        quaternionRotation143.setFromUnitVectors(initialNormal143, normalVec143);

        ringMesh143.setRotationFromQuaternion(quaternionRotation143);

        return quaternionRotation143;
    }

    ringRoot.add(ringMesh143);
            
	var inradius144 = calulateInradius(getVertex7(), getVertex93(), getVertex94());
	var incenter144 = calulateIncenter(getVertex7(), getVertex93(), getVertex94());
	var ringGeometry144 = new THREE.RingGeometry((inradius144 - 0.005),inradius144, 32);
	const ringMaterial144 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh144 = new THREE.Mesh(ringGeometry144, ringMaterial144);

	function setCircleRotation144(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.16666666666666663],[0.,0.,0.15686274509803921]);

        ringMesh144.position.setX(incenter[0]);
        ringMesh144.position.setY(incenter[1]);
        ringMesh144.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex93(), getVertex94());
        var relRadius = inradius/inradius144;

        ringMesh144.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A144 = new THREE.Vector3(0.,-1.,0.);
        const B144 = new THREE.Vector3(0.,0.,0.16666666666666663);
        const C144 = new THREE.Vector3(0.,0.,0.15686274509803921);

        const normalVec144 = new THREE.Vector3();
        normalVec144.crossVectors(B144.sub(A144), C144.sub(A144));
        normalVec144.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal144 = new THREE.Vector3(0,0,1);

        const quaternionRotation144 = new THREE.Quaternion();
        quaternionRotation144.setFromUnitVectors(initialNormal144, normalVec144);

        ringMesh144.setRotationFromQuaternion(quaternionRotation144);

        return quaternionRotation144;
    }

    ringRoot.add(ringMesh144);
            
	var inradius145 = calulateInradius(getVertex8(), getVertex24(), getVertex25());
	var incenter145 = calulateIncenter(getVertex8(), getVertex24(), getVertex25());
	var ringGeometry145 = new THREE.RingGeometry((inradius145 - 0.005),inradius145, 32);
	const ringMaterial145 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh145 = new THREE.Mesh(ringGeometry145, ringMaterial145);

	function setCircleRotation145(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.84313725490196079],[0.,0.,0.83333333333333337]);

        ringMesh145.position.setX(incenter[0]);
        ringMesh145.position.setY(incenter[1]);
        ringMesh145.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex24(), getVertex25());
        var relRadius = inradius/inradius145;

        ringMesh145.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A145 = new THREE.Vector3(0.,-1.,1.);
        const B145 = new THREE.Vector3(0.,0.,0.84313725490196079);
        const C145 = new THREE.Vector3(0.,0.,0.83333333333333337);

        const normalVec145 = new THREE.Vector3();
        normalVec145.crossVectors(B145.sub(A145), C145.sub(A145));
        normalVec145.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal145 = new THREE.Vector3(0,0,1);

        const quaternionRotation145 = new THREE.Quaternion();
        quaternionRotation145.setFromUnitVectors(initialNormal145, normalVec145);

        ringMesh145.setRotationFromQuaternion(quaternionRotation145);

        return quaternionRotation145;
    }

    ringRoot.add(ringMesh145);
            
	var inradius146 = calulateInradius(getVertex7(), getVertex92(), getVertex93());
	var incenter146 = calulateIncenter(getVertex7(), getVertex92(), getVertex93());
	var ringGeometry146 = new THREE.RingGeometry((inradius146 - 0.005),inradius146, 32);
	const ringMaterial146 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh146 = new THREE.Mesh(ringGeometry146, ringMaterial146);

	function setCircleRotation146(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.17647058823529416],[0.,0.,0.16666666666666663]);

        ringMesh146.position.setX(incenter[0]);
        ringMesh146.position.setY(incenter[1]);
        ringMesh146.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex92(), getVertex93());
        var relRadius = inradius/inradius146;

        ringMesh146.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A146 = new THREE.Vector3(0.,-1.,0.);
        const B146 = new THREE.Vector3(0.,0.,0.17647058823529416);
        const C146 = new THREE.Vector3(0.,0.,0.16666666666666663);

        const normalVec146 = new THREE.Vector3();
        normalVec146.crossVectors(B146.sub(A146), C146.sub(A146));
        normalVec146.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal146 = new THREE.Vector3(0,0,1);

        const quaternionRotation146 = new THREE.Quaternion();
        quaternionRotation146.setFromUnitVectors(initialNormal146, normalVec146);

        ringMesh146.setRotationFromQuaternion(quaternionRotation146);

        return quaternionRotation146;
    }

    ringRoot.add(ringMesh146);
            
	var inradius147 = calulateInradius(getVertex8(), getVertex25(), getVertex26());
	var incenter147 = calulateIncenter(getVertex8(), getVertex25(), getVertex26());
	var ringGeometry147 = new THREE.RingGeometry((inradius147 - 0.005),inradius147, 32);
	const ringMaterial147 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh147 = new THREE.Mesh(ringGeometry147, ringMaterial147);

	function setCircleRotation147(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.83333333333333337],[0.,0.,0.82352941176470584]);

        ringMesh147.position.setX(incenter[0]);
        ringMesh147.position.setY(incenter[1]);
        ringMesh147.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex25(), getVertex26());
        var relRadius = inradius/inradius147;

        ringMesh147.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A147 = new THREE.Vector3(0.,-1.,1.);
        const B147 = new THREE.Vector3(0.,0.,0.83333333333333337);
        const C147 = new THREE.Vector3(0.,0.,0.82352941176470584);

        const normalVec147 = new THREE.Vector3();
        normalVec147.crossVectors(B147.sub(A147), C147.sub(A147));
        normalVec147.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal147 = new THREE.Vector3(0,0,1);

        const quaternionRotation147 = new THREE.Quaternion();
        quaternionRotation147.setFromUnitVectors(initialNormal147, normalVec147);

        ringMesh147.setRotationFromQuaternion(quaternionRotation147);

        return quaternionRotation147;
    }

    ringRoot.add(ringMesh147);
            
	var inradius148 = calulateInradius(getVertex7(), getVertex91(), getVertex92());
	var incenter148 = calulateIncenter(getVertex7(), getVertex91(), getVertex92());
	var ringGeometry148 = new THREE.RingGeometry((inradius148 - 0.005),inradius148, 32);
	const ringMaterial148 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh148 = new THREE.Mesh(ringGeometry148, ringMaterial148);

	function setCircleRotation148(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.18627450980392157],[0.,0.,0.17647058823529416]);

        ringMesh148.position.setX(incenter[0]);
        ringMesh148.position.setY(incenter[1]);
        ringMesh148.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex91(), getVertex92());
        var relRadius = inradius/inradius148;

        ringMesh148.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A148 = new THREE.Vector3(0.,-1.,0.);
        const B148 = new THREE.Vector3(0.,0.,0.18627450980392157);
        const C148 = new THREE.Vector3(0.,0.,0.17647058823529416);

        const normalVec148 = new THREE.Vector3();
        normalVec148.crossVectors(B148.sub(A148), C148.sub(A148));
        normalVec148.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal148 = new THREE.Vector3(0,0,1);

        const quaternionRotation148 = new THREE.Quaternion();
        quaternionRotation148.setFromUnitVectors(initialNormal148, normalVec148);

        ringMesh148.setRotationFromQuaternion(quaternionRotation148);

        return quaternionRotation148;
    }

    ringRoot.add(ringMesh148);
            
	var inradius149 = calulateInradius(getVertex8(), getVertex26(), getVertex27());
	var incenter149 = calulateIncenter(getVertex8(), getVertex26(), getVertex27());
	var ringGeometry149 = new THREE.RingGeometry((inradius149 - 0.005),inradius149, 32);
	const ringMaterial149 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh149 = new THREE.Mesh(ringGeometry149, ringMaterial149);

	function setCircleRotation149(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.82352941176470584],[0.,0.,0.81372549019607843]);

        ringMesh149.position.setX(incenter[0]);
        ringMesh149.position.setY(incenter[1]);
        ringMesh149.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex26(), getVertex27());
        var relRadius = inradius/inradius149;

        ringMesh149.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A149 = new THREE.Vector3(0.,-1.,1.);
        const B149 = new THREE.Vector3(0.,0.,0.82352941176470584);
        const C149 = new THREE.Vector3(0.,0.,0.81372549019607843);

        const normalVec149 = new THREE.Vector3();
        normalVec149.crossVectors(B149.sub(A149), C149.sub(A149));
        normalVec149.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal149 = new THREE.Vector3(0,0,1);

        const quaternionRotation149 = new THREE.Quaternion();
        quaternionRotation149.setFromUnitVectors(initialNormal149, normalVec149);

        ringMesh149.setRotationFromQuaternion(quaternionRotation149);

        return quaternionRotation149;
    }

    ringRoot.add(ringMesh149);
            
	var inradius150 = calulateInradius(getVertex7(), getVertex90(), getVertex91());
	var incenter150 = calulateIncenter(getVertex7(), getVertex90(), getVertex91());
	var ringGeometry150 = new THREE.RingGeometry((inradius150 - 0.005),inradius150, 32);
	const ringMaterial150 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh150 = new THREE.Mesh(ringGeometry150, ringMaterial150);

	function setCircleRotation150(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.19607843137254899],[0.,0.,0.18627450980392157]);

        ringMesh150.position.setX(incenter[0]);
        ringMesh150.position.setY(incenter[1]);
        ringMesh150.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex90(), getVertex91());
        var relRadius = inradius/inradius150;

        ringMesh150.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A150 = new THREE.Vector3(0.,-1.,0.);
        const B150 = new THREE.Vector3(0.,0.,0.19607843137254899);
        const C150 = new THREE.Vector3(0.,0.,0.18627450980392157);

        const normalVec150 = new THREE.Vector3();
        normalVec150.crossVectors(B150.sub(A150), C150.sub(A150));
        normalVec150.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal150 = new THREE.Vector3(0,0,1);

        const quaternionRotation150 = new THREE.Quaternion();
        quaternionRotation150.setFromUnitVectors(initialNormal150, normalVec150);

        ringMesh150.setRotationFromQuaternion(quaternionRotation150);

        return quaternionRotation150;
    }

    ringRoot.add(ringMesh150);
            
	var inradius151 = calulateInradius(getVertex8(), getVertex27(), getVertex28());
	var incenter151 = calulateIncenter(getVertex8(), getVertex27(), getVertex28());
	var ringGeometry151 = new THREE.RingGeometry((inradius151 - 0.005),inradius151, 32);
	const ringMaterial151 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh151 = new THREE.Mesh(ringGeometry151, ringMaterial151);

	function setCircleRotation151(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.81372549019607843],[0.,0.,0.80392156862745101]);

        ringMesh151.position.setX(incenter[0]);
        ringMesh151.position.setY(incenter[1]);
        ringMesh151.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex27(), getVertex28());
        var relRadius = inradius/inradius151;

        ringMesh151.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A151 = new THREE.Vector3(0.,-1.,1.);
        const B151 = new THREE.Vector3(0.,0.,0.81372549019607843);
        const C151 = new THREE.Vector3(0.,0.,0.80392156862745101);

        const normalVec151 = new THREE.Vector3();
        normalVec151.crossVectors(B151.sub(A151), C151.sub(A151));
        normalVec151.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal151 = new THREE.Vector3(0,0,1);

        const quaternionRotation151 = new THREE.Quaternion();
        quaternionRotation151.setFromUnitVectors(initialNormal151, normalVec151);

        ringMesh151.setRotationFromQuaternion(quaternionRotation151);

        return quaternionRotation151;
    }

    ringRoot.add(ringMesh151);
            
	var inradius152 = calulateInradius(getVertex7(), getVertex89(), getVertex90());
	var incenter152 = calulateIncenter(getVertex7(), getVertex89(), getVertex90());
	var ringGeometry152 = new THREE.RingGeometry((inradius152 - 0.005),inradius152, 32);
	const ringMaterial152 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh152 = new THREE.Mesh(ringGeometry152, ringMaterial152);

	function setCircleRotation152(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.20588235294117652],[0.,0.,0.19607843137254899]);

        ringMesh152.position.setX(incenter[0]);
        ringMesh152.position.setY(incenter[1]);
        ringMesh152.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex89(), getVertex90());
        var relRadius = inradius/inradius152;

        ringMesh152.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A152 = new THREE.Vector3(0.,-1.,0.);
        const B152 = new THREE.Vector3(0.,0.,0.20588235294117652);
        const C152 = new THREE.Vector3(0.,0.,0.19607843137254899);

        const normalVec152 = new THREE.Vector3();
        normalVec152.crossVectors(B152.sub(A152), C152.sub(A152));
        normalVec152.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal152 = new THREE.Vector3(0,0,1);

        const quaternionRotation152 = new THREE.Quaternion();
        quaternionRotation152.setFromUnitVectors(initialNormal152, normalVec152);

        ringMesh152.setRotationFromQuaternion(quaternionRotation152);

        return quaternionRotation152;
    }

    ringRoot.add(ringMesh152);
            
	var inradius153 = calulateInradius(getVertex8(), getVertex28(), getVertex29());
	var incenter153 = calulateIncenter(getVertex8(), getVertex28(), getVertex29());
	var ringGeometry153 = new THREE.RingGeometry((inradius153 - 0.005),inradius153, 32);
	const ringMaterial153 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh153 = new THREE.Mesh(ringGeometry153, ringMaterial153);

	function setCircleRotation153(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.80392156862745101],[0.,0.,0.79411764705882359]);

        ringMesh153.position.setX(incenter[0]);
        ringMesh153.position.setY(incenter[1]);
        ringMesh153.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex28(), getVertex29());
        var relRadius = inradius/inradius153;

        ringMesh153.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A153 = new THREE.Vector3(0.,-1.,1.);
        const B153 = new THREE.Vector3(0.,0.,0.80392156862745101);
        const C153 = new THREE.Vector3(0.,0.,0.79411764705882359);

        const normalVec153 = new THREE.Vector3();
        normalVec153.crossVectors(B153.sub(A153), C153.sub(A153));
        normalVec153.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal153 = new THREE.Vector3(0,0,1);

        const quaternionRotation153 = new THREE.Quaternion();
        quaternionRotation153.setFromUnitVectors(initialNormal153, normalVec153);

        ringMesh153.setRotationFromQuaternion(quaternionRotation153);

        return quaternionRotation153;
    }

    ringRoot.add(ringMesh153);
            
	var inradius154 = calulateInradius(getVertex7(), getVertex88(), getVertex89());
	var incenter154 = calulateIncenter(getVertex7(), getVertex88(), getVertex89());
	var ringGeometry154 = new THREE.RingGeometry((inradius154 - 0.005),inradius154, 32);
	const ringMaterial154 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh154 = new THREE.Mesh(ringGeometry154, ringMaterial154);

	function setCircleRotation154(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.21568627450980393],[0.,0.,0.20588235294117652]);

        ringMesh154.position.setX(incenter[0]);
        ringMesh154.position.setY(incenter[1]);
        ringMesh154.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex88(), getVertex89());
        var relRadius = inradius/inradius154;

        ringMesh154.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A154 = new THREE.Vector3(0.,-1.,0.);
        const B154 = new THREE.Vector3(0.,0.,0.21568627450980393);
        const C154 = new THREE.Vector3(0.,0.,0.20588235294117652);

        const normalVec154 = new THREE.Vector3();
        normalVec154.crossVectors(B154.sub(A154), C154.sub(A154));
        normalVec154.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal154 = new THREE.Vector3(0,0,1);

        const quaternionRotation154 = new THREE.Quaternion();
        quaternionRotation154.setFromUnitVectors(initialNormal154, normalVec154);

        ringMesh154.setRotationFromQuaternion(quaternionRotation154);

        return quaternionRotation154;
    }

    ringRoot.add(ringMesh154);
            
	var inradius155 = calulateInradius(getVertex8(), getVertex29(), getVertex30());
	var incenter155 = calulateIncenter(getVertex8(), getVertex29(), getVertex30());
	var ringGeometry155 = new THREE.RingGeometry((inradius155 - 0.005),inradius155, 32);
	const ringMaterial155 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh155 = new THREE.Mesh(ringGeometry155, ringMaterial155);

	function setCircleRotation155(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.79411764705882359],[0.,0.,0.78431372549019607]);

        ringMesh155.position.setX(incenter[0]);
        ringMesh155.position.setY(incenter[1]);
        ringMesh155.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex29(), getVertex30());
        var relRadius = inradius/inradius155;

        ringMesh155.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A155 = new THREE.Vector3(0.,-1.,1.);
        const B155 = new THREE.Vector3(0.,0.,0.79411764705882359);
        const C155 = new THREE.Vector3(0.,0.,0.78431372549019607);

        const normalVec155 = new THREE.Vector3();
        normalVec155.crossVectors(B155.sub(A155), C155.sub(A155));
        normalVec155.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal155 = new THREE.Vector3(0,0,1);

        const quaternionRotation155 = new THREE.Quaternion();
        quaternionRotation155.setFromUnitVectors(initialNormal155, normalVec155);

        ringMesh155.setRotationFromQuaternion(quaternionRotation155);

        return quaternionRotation155;
    }

    ringRoot.add(ringMesh155);
            
	var inradius156 = calulateInradius(getVertex7(), getVertex87(), getVertex88());
	var incenter156 = calulateIncenter(getVertex7(), getVertex87(), getVertex88());
	var ringGeometry156 = new THREE.RingGeometry((inradius156 - 0.005),inradius156, 32);
	const ringMaterial156 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh156 = new THREE.Mesh(ringGeometry156, ringMaterial156);

	function setCircleRotation156(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.22549019607843135],[0.,0.,0.21568627450980393]);

        ringMesh156.position.setX(incenter[0]);
        ringMesh156.position.setY(incenter[1]);
        ringMesh156.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex87(), getVertex88());
        var relRadius = inradius/inradius156;

        ringMesh156.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A156 = new THREE.Vector3(0.,-1.,0.);
        const B156 = new THREE.Vector3(0.,0.,0.22549019607843135);
        const C156 = new THREE.Vector3(0.,0.,0.21568627450980393);

        const normalVec156 = new THREE.Vector3();
        normalVec156.crossVectors(B156.sub(A156), C156.sub(A156));
        normalVec156.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal156 = new THREE.Vector3(0,0,1);

        const quaternionRotation156 = new THREE.Quaternion();
        quaternionRotation156.setFromUnitVectors(initialNormal156, normalVec156);

        ringMesh156.setRotationFromQuaternion(quaternionRotation156);

        return quaternionRotation156;
    }

    ringRoot.add(ringMesh156);
            
	var inradius157 = calulateInradius(getVertex8(), getVertex30(), getVertex31());
	var incenter157 = calulateIncenter(getVertex8(), getVertex30(), getVertex31());
	var ringGeometry157 = new THREE.RingGeometry((inradius157 - 0.005),inradius157, 32);
	const ringMaterial157 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh157 = new THREE.Mesh(ringGeometry157, ringMaterial157);

	function setCircleRotation157(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.78431372549019607],[0.,0.,0.77450980392156865]);

        ringMesh157.position.setX(incenter[0]);
        ringMesh157.position.setY(incenter[1]);
        ringMesh157.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex30(), getVertex31());
        var relRadius = inradius/inradius157;

        ringMesh157.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A157 = new THREE.Vector3(0.,-1.,1.);
        const B157 = new THREE.Vector3(0.,0.,0.78431372549019607);
        const C157 = new THREE.Vector3(0.,0.,0.77450980392156865);

        const normalVec157 = new THREE.Vector3();
        normalVec157.crossVectors(B157.sub(A157), C157.sub(A157));
        normalVec157.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal157 = new THREE.Vector3(0,0,1);

        const quaternionRotation157 = new THREE.Quaternion();
        quaternionRotation157.setFromUnitVectors(initialNormal157, normalVec157);

        ringMesh157.setRotationFromQuaternion(quaternionRotation157);

        return quaternionRotation157;
    }

    ringRoot.add(ringMesh157);
            
	var inradius158 = calulateInradius(getVertex7(), getVertex86(), getVertex87());
	var incenter158 = calulateIncenter(getVertex7(), getVertex86(), getVertex87());
	var ringGeometry158 = new THREE.RingGeometry((inradius158 - 0.005),inradius158, 32);
	const ringMaterial158 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh158 = new THREE.Mesh(ringGeometry158, ringMaterial158);

	function setCircleRotation158(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.23529411764705888],[0.,0.,0.22549019607843135]);

        ringMesh158.position.setX(incenter[0]);
        ringMesh158.position.setY(incenter[1]);
        ringMesh158.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex86(), getVertex87());
        var relRadius = inradius/inradius158;

        ringMesh158.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A158 = new THREE.Vector3(0.,-1.,0.);
        const B158 = new THREE.Vector3(0.,0.,0.23529411764705888);
        const C158 = new THREE.Vector3(0.,0.,0.22549019607843135);

        const normalVec158 = new THREE.Vector3();
        normalVec158.crossVectors(B158.sub(A158), C158.sub(A158));
        normalVec158.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal158 = new THREE.Vector3(0,0,1);

        const quaternionRotation158 = new THREE.Quaternion();
        quaternionRotation158.setFromUnitVectors(initialNormal158, normalVec158);

        ringMesh158.setRotationFromQuaternion(quaternionRotation158);

        return quaternionRotation158;
    }

    ringRoot.add(ringMesh158);
            
	var inradius159 = calulateInradius(getVertex8(), getVertex31(), getVertex32());
	var incenter159 = calulateIncenter(getVertex8(), getVertex31(), getVertex32());
	var ringGeometry159 = new THREE.RingGeometry((inradius159 - 0.005),inradius159, 32);
	const ringMaterial159 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh159 = new THREE.Mesh(ringGeometry159, ringMaterial159);

	function setCircleRotation159(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.77450980392156865],[0.,0.,0.76470588235294112]);

        ringMesh159.position.setX(incenter[0]);
        ringMesh159.position.setY(incenter[1]);
        ringMesh159.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex31(), getVertex32());
        var relRadius = inradius/inradius159;

        ringMesh159.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A159 = new THREE.Vector3(0.,-1.,1.);
        const B159 = new THREE.Vector3(0.,0.,0.77450980392156865);
        const C159 = new THREE.Vector3(0.,0.,0.76470588235294112);

        const normalVec159 = new THREE.Vector3();
        normalVec159.crossVectors(B159.sub(A159), C159.sub(A159));
        normalVec159.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal159 = new THREE.Vector3(0,0,1);

        const quaternionRotation159 = new THREE.Quaternion();
        quaternionRotation159.setFromUnitVectors(initialNormal159, normalVec159);

        ringMesh159.setRotationFromQuaternion(quaternionRotation159);

        return quaternionRotation159;
    }

    ringRoot.add(ringMesh159);
            
	var inradius160 = calulateInradius(getVertex7(), getVertex85(), getVertex86());
	var incenter160 = calulateIncenter(getVertex7(), getVertex85(), getVertex86());
	var ringGeometry160 = new THREE.RingGeometry((inradius160 - 0.005),inradius160, 32);
	const ringMaterial160 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh160 = new THREE.Mesh(ringGeometry160, ringMaterial160);

	function setCircleRotation160(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.24509803921568629],[0.,0.,0.23529411764705888]);

        ringMesh160.position.setX(incenter[0]);
        ringMesh160.position.setY(incenter[1]);
        ringMesh160.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex85(), getVertex86());
        var relRadius = inradius/inradius160;

        ringMesh160.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A160 = new THREE.Vector3(0.,-1.,0.);
        const B160 = new THREE.Vector3(0.,0.,0.24509803921568629);
        const C160 = new THREE.Vector3(0.,0.,0.23529411764705888);

        const normalVec160 = new THREE.Vector3();
        normalVec160.crossVectors(B160.sub(A160), C160.sub(A160));
        normalVec160.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal160 = new THREE.Vector3(0,0,1);

        const quaternionRotation160 = new THREE.Quaternion();
        quaternionRotation160.setFromUnitVectors(initialNormal160, normalVec160);

        ringMesh160.setRotationFromQuaternion(quaternionRotation160);

        return quaternionRotation160;
    }

    ringRoot.add(ringMesh160);
            
	var inradius161 = calulateInradius(getVertex8(), getVertex32(), getVertex33());
	var incenter161 = calulateIncenter(getVertex8(), getVertex32(), getVertex33());
	var ringGeometry161 = new THREE.RingGeometry((inradius161 - 0.005),inradius161, 32);
	const ringMaterial161 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh161 = new THREE.Mesh(ringGeometry161, ringMaterial161);

	function setCircleRotation161(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.76470588235294112],[0.,0.,0.75490196078431371]);

        ringMesh161.position.setX(incenter[0]);
        ringMesh161.position.setY(incenter[1]);
        ringMesh161.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex32(), getVertex33());
        var relRadius = inradius/inradius161;

        ringMesh161.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A161 = new THREE.Vector3(0.,-1.,1.);
        const B161 = new THREE.Vector3(0.,0.,0.76470588235294112);
        const C161 = new THREE.Vector3(0.,0.,0.75490196078431371);

        const normalVec161 = new THREE.Vector3();
        normalVec161.crossVectors(B161.sub(A161), C161.sub(A161));
        normalVec161.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal161 = new THREE.Vector3(0,0,1);

        const quaternionRotation161 = new THREE.Quaternion();
        quaternionRotation161.setFromUnitVectors(initialNormal161, normalVec161);

        ringMesh161.setRotationFromQuaternion(quaternionRotation161);

        return quaternionRotation161;
    }

    ringRoot.add(ringMesh161);
            
	var inradius162 = calulateInradius(getVertex7(), getVertex84(), getVertex85());
	var incenter162 = calulateIncenter(getVertex7(), getVertex84(), getVertex85());
	var ringGeometry162 = new THREE.RingGeometry((inradius162 - 0.005),inradius162, 32);
	const ringMaterial162 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh162 = new THREE.Mesh(ringGeometry162, ringMaterial162);

	function setCircleRotation162(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.25490196078431371],[0.,0.,0.24509803921568629]);

        ringMesh162.position.setX(incenter[0]);
        ringMesh162.position.setY(incenter[1]);
        ringMesh162.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex84(), getVertex85());
        var relRadius = inradius/inradius162;

        ringMesh162.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A162 = new THREE.Vector3(0.,-1.,0.);
        const B162 = new THREE.Vector3(0.,0.,0.25490196078431371);
        const C162 = new THREE.Vector3(0.,0.,0.24509803921568629);

        const normalVec162 = new THREE.Vector3();
        normalVec162.crossVectors(B162.sub(A162), C162.sub(A162));
        normalVec162.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal162 = new THREE.Vector3(0,0,1);

        const quaternionRotation162 = new THREE.Quaternion();
        quaternionRotation162.setFromUnitVectors(initialNormal162, normalVec162);

        ringMesh162.setRotationFromQuaternion(quaternionRotation162);

        return quaternionRotation162;
    }

    ringRoot.add(ringMesh162);
            
	var inradius163 = calulateInradius(getVertex8(), getVertex33(), getVertex34());
	var incenter163 = calulateIncenter(getVertex8(), getVertex33(), getVertex34());
	var ringGeometry163 = new THREE.RingGeometry((inradius163 - 0.005),inradius163, 32);
	const ringMaterial163 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh163 = new THREE.Mesh(ringGeometry163, ringMaterial163);

	function setCircleRotation163(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.75490196078431371],[0.,0.,0.74509803921568629]);

        ringMesh163.position.setX(incenter[0]);
        ringMesh163.position.setY(incenter[1]);
        ringMesh163.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex33(), getVertex34());
        var relRadius = inradius/inradius163;

        ringMesh163.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A163 = new THREE.Vector3(0.,-1.,1.);
        const B163 = new THREE.Vector3(0.,0.,0.75490196078431371);
        const C163 = new THREE.Vector3(0.,0.,0.74509803921568629);

        const normalVec163 = new THREE.Vector3();
        normalVec163.crossVectors(B163.sub(A163), C163.sub(A163));
        normalVec163.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal163 = new THREE.Vector3(0,0,1);

        const quaternionRotation163 = new THREE.Quaternion();
        quaternionRotation163.setFromUnitVectors(initialNormal163, normalVec163);

        ringMesh163.setRotationFromQuaternion(quaternionRotation163);

        return quaternionRotation163;
    }

    ringRoot.add(ringMesh163);
            
	var inradius164 = calulateInradius(getVertex7(), getVertex83(), getVertex84());
	var incenter164 = calulateIncenter(getVertex7(), getVertex83(), getVertex84());
	var ringGeometry164 = new THREE.RingGeometry((inradius164 - 0.005),inradius164, 32);
	const ringMaterial164 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh164 = new THREE.Mesh(ringGeometry164, ringMaterial164);

	function setCircleRotation164(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.26470588235294124],[0.,0.,0.25490196078431371]);

        ringMesh164.position.setX(incenter[0]);
        ringMesh164.position.setY(incenter[1]);
        ringMesh164.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex83(), getVertex84());
        var relRadius = inradius/inradius164;

        ringMesh164.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A164 = new THREE.Vector3(0.,-1.,0.);
        const B164 = new THREE.Vector3(0.,0.,0.26470588235294124);
        const C164 = new THREE.Vector3(0.,0.,0.25490196078431371);

        const normalVec164 = new THREE.Vector3();
        normalVec164.crossVectors(B164.sub(A164), C164.sub(A164));
        normalVec164.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal164 = new THREE.Vector3(0,0,1);

        const quaternionRotation164 = new THREE.Quaternion();
        quaternionRotation164.setFromUnitVectors(initialNormal164, normalVec164);

        ringMesh164.setRotationFromQuaternion(quaternionRotation164);

        return quaternionRotation164;
    }

    ringRoot.add(ringMesh164);
            
	var inradius165 = calulateInradius(getVertex8(), getVertex34(), getVertex35());
	var incenter165 = calulateIncenter(getVertex8(), getVertex34(), getVertex35());
	var ringGeometry165 = new THREE.RingGeometry((inradius165 - 0.005),inradius165, 32);
	const ringMaterial165 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh165 = new THREE.Mesh(ringGeometry165, ringMaterial165);

	function setCircleRotation165(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.74509803921568629],[0.,0.,0.73529411764705888]);

        ringMesh165.position.setX(incenter[0]);
        ringMesh165.position.setY(incenter[1]);
        ringMesh165.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex34(), getVertex35());
        var relRadius = inradius/inradius165;

        ringMesh165.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A165 = new THREE.Vector3(0.,-1.,1.);
        const B165 = new THREE.Vector3(0.,0.,0.74509803921568629);
        const C165 = new THREE.Vector3(0.,0.,0.73529411764705888);

        const normalVec165 = new THREE.Vector3();
        normalVec165.crossVectors(B165.sub(A165), C165.sub(A165));
        normalVec165.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal165 = new THREE.Vector3(0,0,1);

        const quaternionRotation165 = new THREE.Quaternion();
        quaternionRotation165.setFromUnitVectors(initialNormal165, normalVec165);

        ringMesh165.setRotationFromQuaternion(quaternionRotation165);

        return quaternionRotation165;
    }

    ringRoot.add(ringMesh165);
            
	var inradius166 = calulateInradius(getVertex7(), getVertex82(), getVertex83());
	var incenter166 = calulateIncenter(getVertex7(), getVertex82(), getVertex83());
	var ringGeometry166 = new THREE.RingGeometry((inradius166 - 0.005),inradius166, 32);
	const ringMaterial166 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh166 = new THREE.Mesh(ringGeometry166, ringMaterial166);

	function setCircleRotation166(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.27450980392156865],[0.,0.,0.26470588235294124]);

        ringMesh166.position.setX(incenter[0]);
        ringMesh166.position.setY(incenter[1]);
        ringMesh166.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex82(), getVertex83());
        var relRadius = inradius/inradius166;

        ringMesh166.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A166 = new THREE.Vector3(0.,-1.,0.);
        const B166 = new THREE.Vector3(0.,0.,0.27450980392156865);
        const C166 = new THREE.Vector3(0.,0.,0.26470588235294124);

        const normalVec166 = new THREE.Vector3();
        normalVec166.crossVectors(B166.sub(A166), C166.sub(A166));
        normalVec166.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal166 = new THREE.Vector3(0,0,1);

        const quaternionRotation166 = new THREE.Quaternion();
        quaternionRotation166.setFromUnitVectors(initialNormal166, normalVec166);

        ringMesh166.setRotationFromQuaternion(quaternionRotation166);

        return quaternionRotation166;
    }

    ringRoot.add(ringMesh166);
            
	var inradius167 = calulateInradius(getVertex8(), getVertex35(), getVertex36());
	var incenter167 = calulateIncenter(getVertex8(), getVertex35(), getVertex36());
	var ringGeometry167 = new THREE.RingGeometry((inradius167 - 0.005),inradius167, 32);
	const ringMaterial167 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh167 = new THREE.Mesh(ringGeometry167, ringMaterial167);

	function setCircleRotation167(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.73529411764705888],[0.,0.,0.72549019607843135]);

        ringMesh167.position.setX(incenter[0]);
        ringMesh167.position.setY(incenter[1]);
        ringMesh167.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex35(), getVertex36());
        var relRadius = inradius/inradius167;

        ringMesh167.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A167 = new THREE.Vector3(0.,-1.,1.);
        const B167 = new THREE.Vector3(0.,0.,0.73529411764705888);
        const C167 = new THREE.Vector3(0.,0.,0.72549019607843135);

        const normalVec167 = new THREE.Vector3();
        normalVec167.crossVectors(B167.sub(A167), C167.sub(A167));
        normalVec167.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal167 = new THREE.Vector3(0,0,1);

        const quaternionRotation167 = new THREE.Quaternion();
        quaternionRotation167.setFromUnitVectors(initialNormal167, normalVec167);

        ringMesh167.setRotationFromQuaternion(quaternionRotation167);

        return quaternionRotation167;
    }

    ringRoot.add(ringMesh167);
            
	var inradius168 = calulateInradius(getVertex7(), getVertex81(), getVertex82());
	var incenter168 = calulateIncenter(getVertex7(), getVertex81(), getVertex82());
	var ringGeometry168 = new THREE.RingGeometry((inradius168 - 0.005),inradius168, 32);
	const ringMaterial168 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh168 = new THREE.Mesh(ringGeometry168, ringMaterial168);

	function setCircleRotation168(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.28431372549019607],[0.,0.,0.27450980392156865]);

        ringMesh168.position.setX(incenter[0]);
        ringMesh168.position.setY(incenter[1]);
        ringMesh168.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex81(), getVertex82());
        var relRadius = inradius/inradius168;

        ringMesh168.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A168 = new THREE.Vector3(0.,-1.,0.);
        const B168 = new THREE.Vector3(0.,0.,0.28431372549019607);
        const C168 = new THREE.Vector3(0.,0.,0.27450980392156865);

        const normalVec168 = new THREE.Vector3();
        normalVec168.crossVectors(B168.sub(A168), C168.sub(A168));
        normalVec168.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal168 = new THREE.Vector3(0,0,1);

        const quaternionRotation168 = new THREE.Quaternion();
        quaternionRotation168.setFromUnitVectors(initialNormal168, normalVec168);

        ringMesh168.setRotationFromQuaternion(quaternionRotation168);

        return quaternionRotation168;
    }

    ringRoot.add(ringMesh168);
            
	var inradius169 = calulateInradius(getVertex8(), getVertex36(), getVertex37());
	var incenter169 = calulateIncenter(getVertex8(), getVertex36(), getVertex37());
	var ringGeometry169 = new THREE.RingGeometry((inradius169 - 0.005),inradius169, 32);
	const ringMaterial169 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh169 = new THREE.Mesh(ringGeometry169, ringMaterial169);

	function setCircleRotation169(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.72549019607843135],[0.,0.,0.71568627450980393]);

        ringMesh169.position.setX(incenter[0]);
        ringMesh169.position.setY(incenter[1]);
        ringMesh169.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex36(), getVertex37());
        var relRadius = inradius/inradius169;

        ringMesh169.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A169 = new THREE.Vector3(0.,-1.,1.);
        const B169 = new THREE.Vector3(0.,0.,0.72549019607843135);
        const C169 = new THREE.Vector3(0.,0.,0.71568627450980393);

        const normalVec169 = new THREE.Vector3();
        normalVec169.crossVectors(B169.sub(A169), C169.sub(A169));
        normalVec169.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal169 = new THREE.Vector3(0,0,1);

        const quaternionRotation169 = new THREE.Quaternion();
        quaternionRotation169.setFromUnitVectors(initialNormal169, normalVec169);

        ringMesh169.setRotationFromQuaternion(quaternionRotation169);

        return quaternionRotation169;
    }

    ringRoot.add(ringMesh169);
            
	var inradius170 = calulateInradius(getVertex7(), getVertex80(), getVertex81());
	var incenter170 = calulateIncenter(getVertex7(), getVertex80(), getVertex81());
	var ringGeometry170 = new THREE.RingGeometry((inradius170 - 0.005),inradius170, 32);
	const ringMaterial170 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh170 = new THREE.Mesh(ringGeometry170, ringMaterial170);

	function setCircleRotation170(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.29411764705882359],[0.,0.,0.28431372549019607]);

        ringMesh170.position.setX(incenter[0]);
        ringMesh170.position.setY(incenter[1]);
        ringMesh170.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex80(), getVertex81());
        var relRadius = inradius/inradius170;

        ringMesh170.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A170 = new THREE.Vector3(0.,-1.,0.);
        const B170 = new THREE.Vector3(0.,0.,0.29411764705882359);
        const C170 = new THREE.Vector3(0.,0.,0.28431372549019607);

        const normalVec170 = new THREE.Vector3();
        normalVec170.crossVectors(B170.sub(A170), C170.sub(A170));
        normalVec170.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal170 = new THREE.Vector3(0,0,1);

        const quaternionRotation170 = new THREE.Quaternion();
        quaternionRotation170.setFromUnitVectors(initialNormal170, normalVec170);

        ringMesh170.setRotationFromQuaternion(quaternionRotation170);

        return quaternionRotation170;
    }

    ringRoot.add(ringMesh170);
            
	var inradius171 = calulateInradius(getVertex8(), getVertex37(), getVertex38());
	var incenter171 = calulateIncenter(getVertex8(), getVertex37(), getVertex38());
	var ringGeometry171 = new THREE.RingGeometry((inradius171 - 0.005),inradius171, 32);
	const ringMaterial171 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh171 = new THREE.Mesh(ringGeometry171, ringMaterial171);

	function setCircleRotation171(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.71568627450980393],[0.,0.,0.70588235294117641]);

        ringMesh171.position.setX(incenter[0]);
        ringMesh171.position.setY(incenter[1]);
        ringMesh171.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex37(), getVertex38());
        var relRadius = inradius/inradius171;

        ringMesh171.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A171 = new THREE.Vector3(0.,-1.,1.);
        const B171 = new THREE.Vector3(0.,0.,0.71568627450980393);
        const C171 = new THREE.Vector3(0.,0.,0.70588235294117641);

        const normalVec171 = new THREE.Vector3();
        normalVec171.crossVectors(B171.sub(A171), C171.sub(A171));
        normalVec171.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal171 = new THREE.Vector3(0,0,1);

        const quaternionRotation171 = new THREE.Quaternion();
        quaternionRotation171.setFromUnitVectors(initialNormal171, normalVec171);

        ringMesh171.setRotationFromQuaternion(quaternionRotation171);

        return quaternionRotation171;
    }

    ringRoot.add(ringMesh171);
            
	var inradius172 = calulateInradius(getVertex7(), getVertex79(), getVertex80());
	var incenter172 = calulateIncenter(getVertex7(), getVertex79(), getVertex80());
	var ringGeometry172 = new THREE.RingGeometry((inradius172 - 0.005),inradius172, 32);
	const ringMaterial172 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh172 = new THREE.Mesh(ringGeometry172, ringMaterial172);

	function setCircleRotation172(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.30392156862745101],[0.,0.,0.29411764705882359]);

        ringMesh172.position.setX(incenter[0]);
        ringMesh172.position.setY(incenter[1]);
        ringMesh172.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex79(), getVertex80());
        var relRadius = inradius/inradius172;

        ringMesh172.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A172 = new THREE.Vector3(0.,-1.,0.);
        const B172 = new THREE.Vector3(0.,0.,0.30392156862745101);
        const C172 = new THREE.Vector3(0.,0.,0.29411764705882359);

        const normalVec172 = new THREE.Vector3();
        normalVec172.crossVectors(B172.sub(A172), C172.sub(A172));
        normalVec172.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal172 = new THREE.Vector3(0,0,1);

        const quaternionRotation172 = new THREE.Quaternion();
        quaternionRotation172.setFromUnitVectors(initialNormal172, normalVec172);

        ringMesh172.setRotationFromQuaternion(quaternionRotation172);

        return quaternionRotation172;
    }

    ringRoot.add(ringMesh172);
            
	var inradius173 = calulateInradius(getVertex8(), getVertex38(), getVertex39());
	var incenter173 = calulateIncenter(getVertex8(), getVertex38(), getVertex39());
	var ringGeometry173 = new THREE.RingGeometry((inradius173 - 0.005),inradius173, 32);
	const ringMaterial173 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh173 = new THREE.Mesh(ringGeometry173, ringMaterial173);

	function setCircleRotation173(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.70588235294117641],[0.,0.,0.69607843137254899]);

        ringMesh173.position.setX(incenter[0]);
        ringMesh173.position.setY(incenter[1]);
        ringMesh173.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex38(), getVertex39());
        var relRadius = inradius/inradius173;

        ringMesh173.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A173 = new THREE.Vector3(0.,-1.,1.);
        const B173 = new THREE.Vector3(0.,0.,0.70588235294117641);
        const C173 = new THREE.Vector3(0.,0.,0.69607843137254899);

        const normalVec173 = new THREE.Vector3();
        normalVec173.crossVectors(B173.sub(A173), C173.sub(A173));
        normalVec173.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal173 = new THREE.Vector3(0,0,1);

        const quaternionRotation173 = new THREE.Quaternion();
        quaternionRotation173.setFromUnitVectors(initialNormal173, normalVec173);

        ringMesh173.setRotationFromQuaternion(quaternionRotation173);

        return quaternionRotation173;
    }

    ringRoot.add(ringMesh173);
            
	var inradius174 = calulateInradius(getVertex7(), getVertex78(), getVertex79());
	var incenter174 = calulateIncenter(getVertex7(), getVertex78(), getVertex79());
	var ringGeometry174 = new THREE.RingGeometry((inradius174 - 0.005),inradius174, 32);
	const ringMaterial174 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh174 = new THREE.Mesh(ringGeometry174, ringMaterial174);

	function setCircleRotation174(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.31372549019607843],[0.,0.,0.30392156862745101]);

        ringMesh174.position.setX(incenter[0]);
        ringMesh174.position.setY(incenter[1]);
        ringMesh174.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex78(), getVertex79());
        var relRadius = inradius/inradius174;

        ringMesh174.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A174 = new THREE.Vector3(0.,-1.,0.);
        const B174 = new THREE.Vector3(0.,0.,0.31372549019607843);
        const C174 = new THREE.Vector3(0.,0.,0.30392156862745101);

        const normalVec174 = new THREE.Vector3();
        normalVec174.crossVectors(B174.sub(A174), C174.sub(A174));
        normalVec174.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal174 = new THREE.Vector3(0,0,1);

        const quaternionRotation174 = new THREE.Quaternion();
        quaternionRotation174.setFromUnitVectors(initialNormal174, normalVec174);

        ringMesh174.setRotationFromQuaternion(quaternionRotation174);

        return quaternionRotation174;
    }

    ringRoot.add(ringMesh174);
            
	var inradius175 = calulateInradius(getVertex8(), getVertex39(), getVertex40());
	var incenter175 = calulateIncenter(getVertex8(), getVertex39(), getVertex40());
	var ringGeometry175 = new THREE.RingGeometry((inradius175 - 0.005),inradius175, 32);
	const ringMaterial175 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh175 = new THREE.Mesh(ringGeometry175, ringMaterial175);

	function setCircleRotation175(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.69607843137254899],[0.,0.,0.68627450980392157]);

        ringMesh175.position.setX(incenter[0]);
        ringMesh175.position.setY(incenter[1]);
        ringMesh175.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex39(), getVertex40());
        var relRadius = inradius/inradius175;

        ringMesh175.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A175 = new THREE.Vector3(0.,-1.,1.);
        const B175 = new THREE.Vector3(0.,0.,0.69607843137254899);
        const C175 = new THREE.Vector3(0.,0.,0.68627450980392157);

        const normalVec175 = new THREE.Vector3();
        normalVec175.crossVectors(B175.sub(A175), C175.sub(A175));
        normalVec175.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal175 = new THREE.Vector3(0,0,1);

        const quaternionRotation175 = new THREE.Quaternion();
        quaternionRotation175.setFromUnitVectors(initialNormal175, normalVec175);

        ringMesh175.setRotationFromQuaternion(quaternionRotation175);

        return quaternionRotation175;
    }

    ringRoot.add(ringMesh175);
            
	var inradius176 = calulateInradius(getVertex7(), getVertex77(), getVertex78());
	var incenter176 = calulateIncenter(getVertex7(), getVertex77(), getVertex78());
	var ringGeometry176 = new THREE.RingGeometry((inradius176 - 0.005),inradius176, 32);
	const ringMaterial176 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh176 = new THREE.Mesh(ringGeometry176, ringMaterial176);

	function setCircleRotation176(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.32352941176470584],[0.,0.,0.31372549019607843]);

        ringMesh176.position.setX(incenter[0]);
        ringMesh176.position.setY(incenter[1]);
        ringMesh176.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex77(), getVertex78());
        var relRadius = inradius/inradius176;

        ringMesh176.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A176 = new THREE.Vector3(0.,-1.,0.);
        const B176 = new THREE.Vector3(0.,0.,0.32352941176470584);
        const C176 = new THREE.Vector3(0.,0.,0.31372549019607843);

        const normalVec176 = new THREE.Vector3();
        normalVec176.crossVectors(B176.sub(A176), C176.sub(A176));
        normalVec176.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal176 = new THREE.Vector3(0,0,1);

        const quaternionRotation176 = new THREE.Quaternion();
        quaternionRotation176.setFromUnitVectors(initialNormal176, normalVec176);

        ringMesh176.setRotationFromQuaternion(quaternionRotation176);

        return quaternionRotation176;
    }

    ringRoot.add(ringMesh176);
            
	var inradius177 = calulateInradius(getVertex8(), getVertex40(), getVertex41());
	var incenter177 = calulateIncenter(getVertex8(), getVertex40(), getVertex41());
	var ringGeometry177 = new THREE.RingGeometry((inradius177 - 0.005),inradius177, 32);
	const ringMaterial177 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh177 = new THREE.Mesh(ringGeometry177, ringMaterial177);

	function setCircleRotation177(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.68627450980392157],[0.,0.,0.67647058823529416]);

        ringMesh177.position.setX(incenter[0]);
        ringMesh177.position.setY(incenter[1]);
        ringMesh177.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex40(), getVertex41());
        var relRadius = inradius/inradius177;

        ringMesh177.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A177 = new THREE.Vector3(0.,-1.,1.);
        const B177 = new THREE.Vector3(0.,0.,0.68627450980392157);
        const C177 = new THREE.Vector3(0.,0.,0.67647058823529416);

        const normalVec177 = new THREE.Vector3();
        normalVec177.crossVectors(B177.sub(A177), C177.sub(A177));
        normalVec177.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal177 = new THREE.Vector3(0,0,1);

        const quaternionRotation177 = new THREE.Quaternion();
        quaternionRotation177.setFromUnitVectors(initialNormal177, normalVec177);

        ringMesh177.setRotationFromQuaternion(quaternionRotation177);

        return quaternionRotation177;
    }

    ringRoot.add(ringMesh177);
            
	var inradius178 = calulateInradius(getVertex7(), getVertex76(), getVertex77());
	var incenter178 = calulateIncenter(getVertex7(), getVertex76(), getVertex77());
	var ringGeometry178 = new THREE.RingGeometry((inradius178 - 0.005),inradius178, 32);
	const ringMaterial178 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh178 = new THREE.Mesh(ringGeometry178, ringMaterial178);

	function setCircleRotation178(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.33333333333333337],[0.,0.,0.32352941176470584]);

        ringMesh178.position.setX(incenter[0]);
        ringMesh178.position.setY(incenter[1]);
        ringMesh178.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex76(), getVertex77());
        var relRadius = inradius/inradius178;

        ringMesh178.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A178 = new THREE.Vector3(0.,-1.,0.);
        const B178 = new THREE.Vector3(0.,0.,0.33333333333333337);
        const C178 = new THREE.Vector3(0.,0.,0.32352941176470584);

        const normalVec178 = new THREE.Vector3();
        normalVec178.crossVectors(B178.sub(A178), C178.sub(A178));
        normalVec178.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal178 = new THREE.Vector3(0,0,1);

        const quaternionRotation178 = new THREE.Quaternion();
        quaternionRotation178.setFromUnitVectors(initialNormal178, normalVec178);

        ringMesh178.setRotationFromQuaternion(quaternionRotation178);

        return quaternionRotation178;
    }

    ringRoot.add(ringMesh178);
            
	var inradius179 = calulateInradius(getVertex8(), getVertex41(), getVertex42());
	var incenter179 = calulateIncenter(getVertex8(), getVertex41(), getVertex42());
	var ringGeometry179 = new THREE.RingGeometry((inradius179 - 0.005),inradius179, 32);
	const ringMaterial179 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh179 = new THREE.Mesh(ringGeometry179, ringMaterial179);

	function setCircleRotation179(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.67647058823529416],[0.,0.,0.66666666666666674]);

        ringMesh179.position.setX(incenter[0]);
        ringMesh179.position.setY(incenter[1]);
        ringMesh179.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex41(), getVertex42());
        var relRadius = inradius/inradius179;

        ringMesh179.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A179 = new THREE.Vector3(0.,-1.,1.);
        const B179 = new THREE.Vector3(0.,0.,0.67647058823529416);
        const C179 = new THREE.Vector3(0.,0.,0.66666666666666674);

        const normalVec179 = new THREE.Vector3();
        normalVec179.crossVectors(B179.sub(A179), C179.sub(A179));
        normalVec179.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal179 = new THREE.Vector3(0,0,1);

        const quaternionRotation179 = new THREE.Quaternion();
        quaternionRotation179.setFromUnitVectors(initialNormal179, normalVec179);

        ringMesh179.setRotationFromQuaternion(quaternionRotation179);

        return quaternionRotation179;
    }

    ringRoot.add(ringMesh179);
            
	var inradius180 = calulateInradius(getVertex7(), getVertex75(), getVertex76());
	var incenter180 = calulateIncenter(getVertex7(), getVertex75(), getVertex76());
	var ringGeometry180 = new THREE.RingGeometry((inradius180 - 0.005),inradius180, 32);
	const ringMaterial180 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh180 = new THREE.Mesh(ringGeometry180, ringMaterial180);

	function setCircleRotation180(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.34313725490196079],[0.,0.,0.33333333333333337]);

        ringMesh180.position.setX(incenter[0]);
        ringMesh180.position.setY(incenter[1]);
        ringMesh180.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex75(), getVertex76());
        var relRadius = inradius/inradius180;

        ringMesh180.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A180 = new THREE.Vector3(0.,-1.,0.);
        const B180 = new THREE.Vector3(0.,0.,0.34313725490196079);
        const C180 = new THREE.Vector3(0.,0.,0.33333333333333337);

        const normalVec180 = new THREE.Vector3();
        normalVec180.crossVectors(B180.sub(A180), C180.sub(A180));
        normalVec180.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal180 = new THREE.Vector3(0,0,1);

        const quaternionRotation180 = new THREE.Quaternion();
        quaternionRotation180.setFromUnitVectors(initialNormal180, normalVec180);

        ringMesh180.setRotationFromQuaternion(quaternionRotation180);

        return quaternionRotation180;
    }

    ringRoot.add(ringMesh180);
            
	var inradius181 = calulateInradius(getVertex8(), getVertex42(), getVertex43());
	var incenter181 = calulateIncenter(getVertex8(), getVertex42(), getVertex43());
	var ringGeometry181 = new THREE.RingGeometry((inradius181 - 0.005),inradius181, 32);
	const ringMaterial181 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh181 = new THREE.Mesh(ringGeometry181, ringMaterial181);

	function setCircleRotation181(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.66666666666666674],[0.,0.,0.65686274509803921]);

        ringMesh181.position.setX(incenter[0]);
        ringMesh181.position.setY(incenter[1]);
        ringMesh181.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex42(), getVertex43());
        var relRadius = inradius/inradius181;

        ringMesh181.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A181 = new THREE.Vector3(0.,-1.,1.);
        const B181 = new THREE.Vector3(0.,0.,0.66666666666666674);
        const C181 = new THREE.Vector3(0.,0.,0.65686274509803921);

        const normalVec181 = new THREE.Vector3();
        normalVec181.crossVectors(B181.sub(A181), C181.sub(A181));
        normalVec181.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal181 = new THREE.Vector3(0,0,1);

        const quaternionRotation181 = new THREE.Quaternion();
        quaternionRotation181.setFromUnitVectors(initialNormal181, normalVec181);

        ringMesh181.setRotationFromQuaternion(quaternionRotation181);

        return quaternionRotation181;
    }

    ringRoot.add(ringMesh181);
            
	var inradius182 = calulateInradius(getVertex7(), getVertex74(), getVertex75());
	var incenter182 = calulateIncenter(getVertex7(), getVertex74(), getVertex75());
	var ringGeometry182 = new THREE.RingGeometry((inradius182 - 0.005),inradius182, 32);
	const ringMaterial182 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh182 = new THREE.Mesh(ringGeometry182, ringMaterial182);

	function setCircleRotation182(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.3529411764705882],[0.,0.,0.34313725490196079]);

        ringMesh182.position.setX(incenter[0]);
        ringMesh182.position.setY(incenter[1]);
        ringMesh182.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex74(), getVertex75());
        var relRadius = inradius/inradius182;

        ringMesh182.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A182 = new THREE.Vector3(0.,-1.,0.);
        const B182 = new THREE.Vector3(0.,0.,0.3529411764705882);
        const C182 = new THREE.Vector3(0.,0.,0.34313725490196079);

        const normalVec182 = new THREE.Vector3();
        normalVec182.crossVectors(B182.sub(A182), C182.sub(A182));
        normalVec182.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal182 = new THREE.Vector3(0,0,1);

        const quaternionRotation182 = new THREE.Quaternion();
        quaternionRotation182.setFromUnitVectors(initialNormal182, normalVec182);

        ringMesh182.setRotationFromQuaternion(quaternionRotation182);

        return quaternionRotation182;
    }

    ringRoot.add(ringMesh182);
            
	var inradius183 = calulateInradius(getVertex8(), getVertex43(), getVertex44());
	var incenter183 = calulateIncenter(getVertex8(), getVertex43(), getVertex44());
	var ringGeometry183 = new THREE.RingGeometry((inradius183 - 0.005),inradius183, 32);
	const ringMaterial183 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh183 = new THREE.Mesh(ringGeometry183, ringMaterial183);

	function setCircleRotation183(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.65686274509803921],[0.,0.,0.6470588235294118]);

        ringMesh183.position.setX(incenter[0]);
        ringMesh183.position.setY(incenter[1]);
        ringMesh183.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex43(), getVertex44());
        var relRadius = inradius/inradius183;

        ringMesh183.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A183 = new THREE.Vector3(0.,-1.,1.);
        const B183 = new THREE.Vector3(0.,0.,0.65686274509803921);
        const C183 = new THREE.Vector3(0.,0.,0.6470588235294118);

        const normalVec183 = new THREE.Vector3();
        normalVec183.crossVectors(B183.sub(A183), C183.sub(A183));
        normalVec183.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal183 = new THREE.Vector3(0,0,1);

        const quaternionRotation183 = new THREE.Quaternion();
        quaternionRotation183.setFromUnitVectors(initialNormal183, normalVec183);

        ringMesh183.setRotationFromQuaternion(quaternionRotation183);

        return quaternionRotation183;
    }

    ringRoot.add(ringMesh183);
            
	var inradius184 = calulateInradius(getVertex7(), getVertex73(), getVertex74());
	var incenter184 = calulateIncenter(getVertex7(), getVertex73(), getVertex74());
	var ringGeometry184 = new THREE.RingGeometry((inradius184 - 0.005),inradius184, 32);
	const ringMaterial184 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh184 = new THREE.Mesh(ringGeometry184, ringMaterial184);

	function setCircleRotation184(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.36274509803921573],[0.,0.,0.3529411764705882]);

        ringMesh184.position.setX(incenter[0]);
        ringMesh184.position.setY(incenter[1]);
        ringMesh184.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex73(), getVertex74());
        var relRadius = inradius/inradius184;

        ringMesh184.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A184 = new THREE.Vector3(0.,-1.,0.);
        const B184 = new THREE.Vector3(0.,0.,0.36274509803921573);
        const C184 = new THREE.Vector3(0.,0.,0.3529411764705882);

        const normalVec184 = new THREE.Vector3();
        normalVec184.crossVectors(B184.sub(A184), C184.sub(A184));
        normalVec184.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal184 = new THREE.Vector3(0,0,1);

        const quaternionRotation184 = new THREE.Quaternion();
        quaternionRotation184.setFromUnitVectors(initialNormal184, normalVec184);

        ringMesh184.setRotationFromQuaternion(quaternionRotation184);

        return quaternionRotation184;
    }

    ringRoot.add(ringMesh184);
            
	var inradius185 = calulateInradius(getVertex8(), getVertex44(), getVertex45());
	var incenter185 = calulateIncenter(getVertex8(), getVertex44(), getVertex45());
	var ringGeometry185 = new THREE.RingGeometry((inradius185 - 0.005),inradius185, 32);
	const ringMaterial185 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh185 = new THREE.Mesh(ringGeometry185, ringMaterial185);

	function setCircleRotation185(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.6470588235294118],[0.,0.,0.63725490196078427]);

        ringMesh185.position.setX(incenter[0]);
        ringMesh185.position.setY(incenter[1]);
        ringMesh185.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex44(), getVertex45());
        var relRadius = inradius/inradius185;

        ringMesh185.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A185 = new THREE.Vector3(0.,-1.,1.);
        const B185 = new THREE.Vector3(0.,0.,0.6470588235294118);
        const C185 = new THREE.Vector3(0.,0.,0.63725490196078427);

        const normalVec185 = new THREE.Vector3();
        normalVec185.crossVectors(B185.sub(A185), C185.sub(A185));
        normalVec185.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal185 = new THREE.Vector3(0,0,1);

        const quaternionRotation185 = new THREE.Quaternion();
        quaternionRotation185.setFromUnitVectors(initialNormal185, normalVec185);

        ringMesh185.setRotationFromQuaternion(quaternionRotation185);

        return quaternionRotation185;
    }

    ringRoot.add(ringMesh185);
            
	var inradius186 = calulateInradius(getVertex7(), getVertex72(), getVertex73());
	var incenter186 = calulateIncenter(getVertex7(), getVertex72(), getVertex73());
	var ringGeometry186 = new THREE.RingGeometry((inradius186 - 0.005),inradius186, 32);
	const ringMaterial186 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh186 = new THREE.Mesh(ringGeometry186, ringMaterial186);

	function setCircleRotation186(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.37254901960784315],[0.,0.,0.36274509803921573]);

        ringMesh186.position.setX(incenter[0]);
        ringMesh186.position.setY(incenter[1]);
        ringMesh186.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex72(), getVertex73());
        var relRadius = inradius/inradius186;

        ringMesh186.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A186 = new THREE.Vector3(0.,-1.,0.);
        const B186 = new THREE.Vector3(0.,0.,0.37254901960784315);
        const C186 = new THREE.Vector3(0.,0.,0.36274509803921573);

        const normalVec186 = new THREE.Vector3();
        normalVec186.crossVectors(B186.sub(A186), C186.sub(A186));
        normalVec186.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal186 = new THREE.Vector3(0,0,1);

        const quaternionRotation186 = new THREE.Quaternion();
        quaternionRotation186.setFromUnitVectors(initialNormal186, normalVec186);

        ringMesh186.setRotationFromQuaternion(quaternionRotation186);

        return quaternionRotation186;
    }

    ringRoot.add(ringMesh186);
            
	var inradius187 = calulateInradius(getVertex8(), getVertex45(), getVertex46());
	var incenter187 = calulateIncenter(getVertex8(), getVertex45(), getVertex46());
	var ringGeometry187 = new THREE.RingGeometry((inradius187 - 0.005),inradius187, 32);
	const ringMaterial187 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh187 = new THREE.Mesh(ringGeometry187, ringMaterial187);

	function setCircleRotation187(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.63725490196078427],[0.,0.,0.62745098039215685]);

        ringMesh187.position.setX(incenter[0]);
        ringMesh187.position.setY(incenter[1]);
        ringMesh187.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex45(), getVertex46());
        var relRadius = inradius/inradius187;

        ringMesh187.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A187 = new THREE.Vector3(0.,-1.,1.);
        const B187 = new THREE.Vector3(0.,0.,0.63725490196078427);
        const C187 = new THREE.Vector3(0.,0.,0.62745098039215685);

        const normalVec187 = new THREE.Vector3();
        normalVec187.crossVectors(B187.sub(A187), C187.sub(A187));
        normalVec187.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal187 = new THREE.Vector3(0,0,1);

        const quaternionRotation187 = new THREE.Quaternion();
        quaternionRotation187.setFromUnitVectors(initialNormal187, normalVec187);

        ringMesh187.setRotationFromQuaternion(quaternionRotation187);

        return quaternionRotation187;
    }

    ringRoot.add(ringMesh187);
            
	var inradius188 = calulateInradius(getVertex7(), getVertex71(), getVertex72());
	var incenter188 = calulateIncenter(getVertex7(), getVertex71(), getVertex72());
	var ringGeometry188 = new THREE.RingGeometry((inradius188 - 0.005),inradius188, 32);
	const ringMaterial188 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh188 = new THREE.Mesh(ringGeometry188, ringMaterial188);

	function setCircleRotation188(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.38235294117647056],[0.,0.,0.37254901960784315]);

        ringMesh188.position.setX(incenter[0]);
        ringMesh188.position.setY(incenter[1]);
        ringMesh188.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex71(), getVertex72());
        var relRadius = inradius/inradius188;

        ringMesh188.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A188 = new THREE.Vector3(0.,-1.,0.);
        const B188 = new THREE.Vector3(0.,0.,0.38235294117647056);
        const C188 = new THREE.Vector3(0.,0.,0.37254901960784315);

        const normalVec188 = new THREE.Vector3();
        normalVec188.crossVectors(B188.sub(A188), C188.sub(A188));
        normalVec188.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal188 = new THREE.Vector3(0,0,1);

        const quaternionRotation188 = new THREE.Quaternion();
        quaternionRotation188.setFromUnitVectors(initialNormal188, normalVec188);

        ringMesh188.setRotationFromQuaternion(quaternionRotation188);

        return quaternionRotation188;
    }

    ringRoot.add(ringMesh188);
            
	var inradius189 = calulateInradius(getVertex8(), getVertex46(), getVertex47());
	var incenter189 = calulateIncenter(getVertex8(), getVertex46(), getVertex47());
	var ringGeometry189 = new THREE.RingGeometry((inradius189 - 0.005),inradius189, 32);
	const ringMaterial189 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh189 = new THREE.Mesh(ringGeometry189, ringMaterial189);

	function setCircleRotation189(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.62745098039215685],[0.,0.,0.61764705882352944]);

        ringMesh189.position.setX(incenter[0]);
        ringMesh189.position.setY(incenter[1]);
        ringMesh189.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex46(), getVertex47());
        var relRadius = inradius/inradius189;

        ringMesh189.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A189 = new THREE.Vector3(0.,-1.,1.);
        const B189 = new THREE.Vector3(0.,0.,0.62745098039215685);
        const C189 = new THREE.Vector3(0.,0.,0.61764705882352944);

        const normalVec189 = new THREE.Vector3();
        normalVec189.crossVectors(B189.sub(A189), C189.sub(A189));
        normalVec189.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal189 = new THREE.Vector3(0,0,1);

        const quaternionRotation189 = new THREE.Quaternion();
        quaternionRotation189.setFromUnitVectors(initialNormal189, normalVec189);

        ringMesh189.setRotationFromQuaternion(quaternionRotation189);

        return quaternionRotation189;
    }

    ringRoot.add(ringMesh189);
            
	var inradius190 = calulateInradius(getVertex7(), getVertex70(), getVertex71());
	var incenter190 = calulateIncenter(getVertex7(), getVertex70(), getVertex71());
	var ringGeometry190 = new THREE.RingGeometry((inradius190 - 0.005),inradius190, 32);
	const ringMaterial190 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh190 = new THREE.Mesh(ringGeometry190, ringMaterial190);

	function setCircleRotation190(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.39215686274509809],[0.,0.,0.38235294117647056]);

        ringMesh190.position.setX(incenter[0]);
        ringMesh190.position.setY(incenter[1]);
        ringMesh190.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex70(), getVertex71());
        var relRadius = inradius/inradius190;

        ringMesh190.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A190 = new THREE.Vector3(0.,-1.,0.);
        const B190 = new THREE.Vector3(0.,0.,0.39215686274509809);
        const C190 = new THREE.Vector3(0.,0.,0.38235294117647056);

        const normalVec190 = new THREE.Vector3();
        normalVec190.crossVectors(B190.sub(A190), C190.sub(A190));
        normalVec190.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal190 = new THREE.Vector3(0,0,1);

        const quaternionRotation190 = new THREE.Quaternion();
        quaternionRotation190.setFromUnitVectors(initialNormal190, normalVec190);

        ringMesh190.setRotationFromQuaternion(quaternionRotation190);

        return quaternionRotation190;
    }

    ringRoot.add(ringMesh190);
            
	var inradius191 = calulateInradius(getVertex8(), getVertex47(), getVertex48());
	var incenter191 = calulateIncenter(getVertex8(), getVertex47(), getVertex48());
	var ringGeometry191 = new THREE.RingGeometry((inradius191 - 0.005),inradius191, 32);
	const ringMaterial191 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh191 = new THREE.Mesh(ringGeometry191, ringMaterial191);

	function setCircleRotation191(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.61764705882352944],[0.,0.,0.60784313725490202]);

        ringMesh191.position.setX(incenter[0]);
        ringMesh191.position.setY(incenter[1]);
        ringMesh191.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex47(), getVertex48());
        var relRadius = inradius/inradius191;

        ringMesh191.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A191 = new THREE.Vector3(0.,-1.,1.);
        const B191 = new THREE.Vector3(0.,0.,0.61764705882352944);
        const C191 = new THREE.Vector3(0.,0.,0.60784313725490202);

        const normalVec191 = new THREE.Vector3();
        normalVec191.crossVectors(B191.sub(A191), C191.sub(A191));
        normalVec191.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal191 = new THREE.Vector3(0,0,1);

        const quaternionRotation191 = new THREE.Quaternion();
        quaternionRotation191.setFromUnitVectors(initialNormal191, normalVec191);

        ringMesh191.setRotationFromQuaternion(quaternionRotation191);

        return quaternionRotation191;
    }

    ringRoot.add(ringMesh191);
            
	var inradius192 = calulateInradius(getVertex7(), getVertex69(), getVertex70());
	var incenter192 = calulateIncenter(getVertex7(), getVertex69(), getVertex70());
	var ringGeometry192 = new THREE.RingGeometry((inradius192 - 0.005),inradius192, 32);
	const ringMaterial192 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh192 = new THREE.Mesh(ringGeometry192, ringMaterial192);

	function setCircleRotation192(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.40196078431372551],[0.,0.,0.39215686274509809]);

        ringMesh192.position.setX(incenter[0]);
        ringMesh192.position.setY(incenter[1]);
        ringMesh192.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex69(), getVertex70());
        var relRadius = inradius/inradius192;

        ringMesh192.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A192 = new THREE.Vector3(0.,-1.,0.);
        const B192 = new THREE.Vector3(0.,0.,0.40196078431372551);
        const C192 = new THREE.Vector3(0.,0.,0.39215686274509809);

        const normalVec192 = new THREE.Vector3();
        normalVec192.crossVectors(B192.sub(A192), C192.sub(A192));
        normalVec192.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal192 = new THREE.Vector3(0,0,1);

        const quaternionRotation192 = new THREE.Quaternion();
        quaternionRotation192.setFromUnitVectors(initialNormal192, normalVec192);

        ringMesh192.setRotationFromQuaternion(quaternionRotation192);

        return quaternionRotation192;
    }

    ringRoot.add(ringMesh192);
            
	var inradius193 = calulateInradius(getVertex8(), getVertex48(), getVertex49());
	var incenter193 = calulateIncenter(getVertex8(), getVertex48(), getVertex49());
	var ringGeometry193 = new THREE.RingGeometry((inradius193 - 0.005),inradius193, 32);
	const ringMaterial193 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh193 = new THREE.Mesh(ringGeometry193, ringMaterial193);

	function setCircleRotation193(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.60784313725490202],[0.,0.,0.59803921568627449]);

        ringMesh193.position.setX(incenter[0]);
        ringMesh193.position.setY(incenter[1]);
        ringMesh193.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex48(), getVertex49());
        var relRadius = inradius/inradius193;

        ringMesh193.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A193 = new THREE.Vector3(0.,-1.,1.);
        const B193 = new THREE.Vector3(0.,0.,0.60784313725490202);
        const C193 = new THREE.Vector3(0.,0.,0.59803921568627449);

        const normalVec193 = new THREE.Vector3();
        normalVec193.crossVectors(B193.sub(A193), C193.sub(A193));
        normalVec193.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal193 = new THREE.Vector3(0,0,1);

        const quaternionRotation193 = new THREE.Quaternion();
        quaternionRotation193.setFromUnitVectors(initialNormal193, normalVec193);

        ringMesh193.setRotationFromQuaternion(quaternionRotation193);

        return quaternionRotation193;
    }

    ringRoot.add(ringMesh193);
            
	var inradius194 = calulateInradius(getVertex7(), getVertex68(), getVertex69());
	var incenter194 = calulateIncenter(getVertex7(), getVertex68(), getVertex69());
	var ringGeometry194 = new THREE.RingGeometry((inradius194 - 0.005),inradius194, 32);
	const ringMaterial194 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh194 = new THREE.Mesh(ringGeometry194, ringMaterial194);

	function setCircleRotation194(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.41176470588235292],[0.,0.,0.40196078431372551]);

        ringMesh194.position.setX(incenter[0]);
        ringMesh194.position.setY(incenter[1]);
        ringMesh194.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex68(), getVertex69());
        var relRadius = inradius/inradius194;

        ringMesh194.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A194 = new THREE.Vector3(0.,-1.,0.);
        const B194 = new THREE.Vector3(0.,0.,0.41176470588235292);
        const C194 = new THREE.Vector3(0.,0.,0.40196078431372551);

        const normalVec194 = new THREE.Vector3();
        normalVec194.crossVectors(B194.sub(A194), C194.sub(A194));
        normalVec194.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal194 = new THREE.Vector3(0,0,1);

        const quaternionRotation194 = new THREE.Quaternion();
        quaternionRotation194.setFromUnitVectors(initialNormal194, normalVec194);

        ringMesh194.setRotationFromQuaternion(quaternionRotation194);

        return quaternionRotation194;
    }

    ringRoot.add(ringMesh194);
            
	var inradius195 = calulateInradius(getVertex8(), getVertex49(), getVertex50());
	var incenter195 = calulateIncenter(getVertex8(), getVertex49(), getVertex50());
	var ringGeometry195 = new THREE.RingGeometry((inradius195 - 0.005),inradius195, 32);
	const ringMaterial195 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh195 = new THREE.Mesh(ringGeometry195, ringMaterial195);

	function setCircleRotation195(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.59803921568627449],[0.,0.,0.58823529411764708]);

        ringMesh195.position.setX(incenter[0]);
        ringMesh195.position.setY(incenter[1]);
        ringMesh195.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex49(), getVertex50());
        var relRadius = inradius/inradius195;

        ringMesh195.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A195 = new THREE.Vector3(0.,-1.,1.);
        const B195 = new THREE.Vector3(0.,0.,0.59803921568627449);
        const C195 = new THREE.Vector3(0.,0.,0.58823529411764708);

        const normalVec195 = new THREE.Vector3();
        normalVec195.crossVectors(B195.sub(A195), C195.sub(A195));
        normalVec195.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal195 = new THREE.Vector3(0,0,1);

        const quaternionRotation195 = new THREE.Quaternion();
        quaternionRotation195.setFromUnitVectors(initialNormal195, normalVec195);

        ringMesh195.setRotationFromQuaternion(quaternionRotation195);

        return quaternionRotation195;
    }

    ringRoot.add(ringMesh195);
            
	var inradius196 = calulateInradius(getVertex7(), getVertex67(), getVertex68());
	var incenter196 = calulateIncenter(getVertex7(), getVertex67(), getVertex68());
	var ringGeometry196 = new THREE.RingGeometry((inradius196 - 0.005),inradius196, 32);
	const ringMaterial196 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh196 = new THREE.Mesh(ringGeometry196, ringMaterial196);

	function setCircleRotation196(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.42156862745098045],[0.,0.,0.41176470588235292]);

        ringMesh196.position.setX(incenter[0]);
        ringMesh196.position.setY(incenter[1]);
        ringMesh196.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex67(), getVertex68());
        var relRadius = inradius/inradius196;

        ringMesh196.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A196 = new THREE.Vector3(0.,-1.,0.);
        const B196 = new THREE.Vector3(0.,0.,0.42156862745098045);
        const C196 = new THREE.Vector3(0.,0.,0.41176470588235292);

        const normalVec196 = new THREE.Vector3();
        normalVec196.crossVectors(B196.sub(A196), C196.sub(A196));
        normalVec196.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal196 = new THREE.Vector3(0,0,1);

        const quaternionRotation196 = new THREE.Quaternion();
        quaternionRotation196.setFromUnitVectors(initialNormal196, normalVec196);

        ringMesh196.setRotationFromQuaternion(quaternionRotation196);

        return quaternionRotation196;
    }

    ringRoot.add(ringMesh196);
            
	var inradius197 = calulateInradius(getVertex8(), getVertex50(), getVertex51());
	var incenter197 = calulateIncenter(getVertex8(), getVertex50(), getVertex51());
	var ringGeometry197 = new THREE.RingGeometry((inradius197 - 0.005),inradius197, 32);
	const ringMaterial197 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh197 = new THREE.Mesh(ringGeometry197, ringMaterial197);

	function setCircleRotation197(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.58823529411764708],[0.,0.,0.57843137254901955]);

        ringMesh197.position.setX(incenter[0]);
        ringMesh197.position.setY(incenter[1]);
        ringMesh197.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex50(), getVertex51());
        var relRadius = inradius/inradius197;

        ringMesh197.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A197 = new THREE.Vector3(0.,-1.,1.);
        const B197 = new THREE.Vector3(0.,0.,0.58823529411764708);
        const C197 = new THREE.Vector3(0.,0.,0.57843137254901955);

        const normalVec197 = new THREE.Vector3();
        normalVec197.crossVectors(B197.sub(A197), C197.sub(A197));
        normalVec197.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal197 = new THREE.Vector3(0,0,1);

        const quaternionRotation197 = new THREE.Quaternion();
        quaternionRotation197.setFromUnitVectors(initialNormal197, normalVec197);

        ringMesh197.setRotationFromQuaternion(quaternionRotation197);

        return quaternionRotation197;
    }

    ringRoot.add(ringMesh197);
            
	var inradius198 = calulateInradius(getVertex7(), getVertex66(), getVertex67());
	var incenter198 = calulateIncenter(getVertex7(), getVertex66(), getVertex67());
	var ringGeometry198 = new THREE.RingGeometry((inradius198 - 0.005),inradius198, 32);
	const ringMaterial198 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh198 = new THREE.Mesh(ringGeometry198, ringMaterial198);

	function setCircleRotation198(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.43137254901960786],[0.,0.,0.42156862745098045]);

        ringMesh198.position.setX(incenter[0]);
        ringMesh198.position.setY(incenter[1]);
        ringMesh198.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex66(), getVertex67());
        var relRadius = inradius/inradius198;

        ringMesh198.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A198 = new THREE.Vector3(0.,-1.,0.);
        const B198 = new THREE.Vector3(0.,0.,0.43137254901960786);
        const C198 = new THREE.Vector3(0.,0.,0.42156862745098045);

        const normalVec198 = new THREE.Vector3();
        normalVec198.crossVectors(B198.sub(A198), C198.sub(A198));
        normalVec198.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal198 = new THREE.Vector3(0,0,1);

        const quaternionRotation198 = new THREE.Quaternion();
        quaternionRotation198.setFromUnitVectors(initialNormal198, normalVec198);

        ringMesh198.setRotationFromQuaternion(quaternionRotation198);

        return quaternionRotation198;
    }

    ringRoot.add(ringMesh198);
            
	var inradius199 = calulateInradius(getVertex8(), getVertex51(), getVertex52());
	var incenter199 = calulateIncenter(getVertex8(), getVertex51(), getVertex52());
	var ringGeometry199 = new THREE.RingGeometry((inradius199 - 0.005),inradius199, 32);
	const ringMaterial199 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh199 = new THREE.Mesh(ringGeometry199, ringMaterial199);

	function setCircleRotation199(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.57843137254901955],[0.,0.,0.56862745098039214]);

        ringMesh199.position.setX(incenter[0]);
        ringMesh199.position.setY(incenter[1]);
        ringMesh199.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex51(), getVertex52());
        var relRadius = inradius/inradius199;

        ringMesh199.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A199 = new THREE.Vector3(0.,-1.,1.);
        const B199 = new THREE.Vector3(0.,0.,0.57843137254901955);
        const C199 = new THREE.Vector3(0.,0.,0.56862745098039214);

        const normalVec199 = new THREE.Vector3();
        normalVec199.crossVectors(B199.sub(A199), C199.sub(A199));
        normalVec199.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal199 = new THREE.Vector3(0,0,1);

        const quaternionRotation199 = new THREE.Quaternion();
        quaternionRotation199.setFromUnitVectors(initialNormal199, normalVec199);

        ringMesh199.setRotationFromQuaternion(quaternionRotation199);

        return quaternionRotation199;
    }

    ringRoot.add(ringMesh199);
            
	var inradius200 = calulateInradius(getVertex7(), getVertex65(), getVertex66());
	var incenter200 = calulateIncenter(getVertex7(), getVertex65(), getVertex66());
	var ringGeometry200 = new THREE.RingGeometry((inradius200 - 0.005),inradius200, 32);
	const ringMaterial200 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh200 = new THREE.Mesh(ringGeometry200, ringMaterial200);

	function setCircleRotation200(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.44117647058823528],[0.,0.,0.43137254901960786]);

        ringMesh200.position.setX(incenter[0]);
        ringMesh200.position.setY(incenter[1]);
        ringMesh200.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex65(), getVertex66());
        var relRadius = inradius/inradius200;

        ringMesh200.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A200 = new THREE.Vector3(0.,-1.,0.);
        const B200 = new THREE.Vector3(0.,0.,0.44117647058823528);
        const C200 = new THREE.Vector3(0.,0.,0.43137254901960786);

        const normalVec200 = new THREE.Vector3();
        normalVec200.crossVectors(B200.sub(A200), C200.sub(A200));
        normalVec200.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal200 = new THREE.Vector3(0,0,1);

        const quaternionRotation200 = new THREE.Quaternion();
        quaternionRotation200.setFromUnitVectors(initialNormal200, normalVec200);

        ringMesh200.setRotationFromQuaternion(quaternionRotation200);

        return quaternionRotation200;
    }

    ringRoot.add(ringMesh200);
            
	var inradius201 = calulateInradius(getVertex8(), getVertex52(), getVertex53());
	var incenter201 = calulateIncenter(getVertex8(), getVertex52(), getVertex53());
	var ringGeometry201 = new THREE.RingGeometry((inradius201 - 0.005),inradius201, 32);
	const ringMaterial201 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh201 = new THREE.Mesh(ringGeometry201, ringMaterial201);

	function setCircleRotation201(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.56862745098039214],[0.,0.,0.55882352941176472]);

        ringMesh201.position.setX(incenter[0]);
        ringMesh201.position.setY(incenter[1]);
        ringMesh201.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex52(), getVertex53());
        var relRadius = inradius/inradius201;

        ringMesh201.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A201 = new THREE.Vector3(0.,-1.,1.);
        const B201 = new THREE.Vector3(0.,0.,0.56862745098039214);
        const C201 = new THREE.Vector3(0.,0.,0.55882352941176472);

        const normalVec201 = new THREE.Vector3();
        normalVec201.crossVectors(B201.sub(A201), C201.sub(A201));
        normalVec201.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal201 = new THREE.Vector3(0,0,1);

        const quaternionRotation201 = new THREE.Quaternion();
        quaternionRotation201.setFromUnitVectors(initialNormal201, normalVec201);

        ringMesh201.setRotationFromQuaternion(quaternionRotation201);

        return quaternionRotation201;
    }

    ringRoot.add(ringMesh201);
            
	var inradius202 = calulateInradius(getVertex7(), getVertex64(), getVertex65());
	var incenter202 = calulateIncenter(getVertex7(), getVertex64(), getVertex65());
	var ringGeometry202 = new THREE.RingGeometry((inradius202 - 0.005),inradius202, 32);
	const ringMaterial202 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh202 = new THREE.Mesh(ringGeometry202, ringMaterial202);

	function setCircleRotation202(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.4509803921568627],[0.,0.,0.44117647058823528]);

        ringMesh202.position.setX(incenter[0]);
        ringMesh202.position.setY(incenter[1]);
        ringMesh202.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex64(), getVertex65());
        var relRadius = inradius/inradius202;

        ringMesh202.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A202 = new THREE.Vector3(0.,-1.,0.);
        const B202 = new THREE.Vector3(0.,0.,0.4509803921568627);
        const C202 = new THREE.Vector3(0.,0.,0.44117647058823528);

        const normalVec202 = new THREE.Vector3();
        normalVec202.crossVectors(B202.sub(A202), C202.sub(A202));
        normalVec202.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal202 = new THREE.Vector3(0,0,1);

        const quaternionRotation202 = new THREE.Quaternion();
        quaternionRotation202.setFromUnitVectors(initialNormal202, normalVec202);

        ringMesh202.setRotationFromQuaternion(quaternionRotation202);

        return quaternionRotation202;
    }

    ringRoot.add(ringMesh202);
            
	var inradius203 = calulateInradius(getVertex8(), getVertex53(), getVertex54());
	var incenter203 = calulateIncenter(getVertex8(), getVertex53(), getVertex54());
	var ringGeometry203 = new THREE.RingGeometry((inradius203 - 0.005),inradius203, 32);
	const ringMaterial203 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh203 = new THREE.Mesh(ringGeometry203, ringMaterial203);

	function setCircleRotation203(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.55882352941176472],[0.,0.,0.5490196078431373]);

        ringMesh203.position.setX(incenter[0]);
        ringMesh203.position.setY(incenter[1]);
        ringMesh203.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex53(), getVertex54());
        var relRadius = inradius/inradius203;

        ringMesh203.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A203 = new THREE.Vector3(0.,-1.,1.);
        const B203 = new THREE.Vector3(0.,0.,0.55882352941176472);
        const C203 = new THREE.Vector3(0.,0.,0.5490196078431373);

        const normalVec203 = new THREE.Vector3();
        normalVec203.crossVectors(B203.sub(A203), C203.sub(A203));
        normalVec203.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal203 = new THREE.Vector3(0,0,1);

        const quaternionRotation203 = new THREE.Quaternion();
        quaternionRotation203.setFromUnitVectors(initialNormal203, normalVec203);

        ringMesh203.setRotationFromQuaternion(quaternionRotation203);

        return quaternionRotation203;
    }

    ringRoot.add(ringMesh203);
            
	var inradius204 = calulateInradius(getVertex7(), getVertex63(), getVertex64());
	var incenter204 = calulateIncenter(getVertex7(), getVertex63(), getVertex64());
	var ringGeometry204 = new THREE.RingGeometry((inradius204 - 0.005),inradius204, 32);
	const ringMaterial204 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh204 = new THREE.Mesh(ringGeometry204, ringMaterial204);

	function setCircleRotation204(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.46078431372549022],[0.,0.,0.4509803921568627]);

        ringMesh204.position.setX(incenter[0]);
        ringMesh204.position.setY(incenter[1]);
        ringMesh204.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex63(), getVertex64());
        var relRadius = inradius/inradius204;

        ringMesh204.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A204 = new THREE.Vector3(0.,-1.,0.);
        const B204 = new THREE.Vector3(0.,0.,0.46078431372549022);
        const C204 = new THREE.Vector3(0.,0.,0.4509803921568627);

        const normalVec204 = new THREE.Vector3();
        normalVec204.crossVectors(B204.sub(A204), C204.sub(A204));
        normalVec204.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal204 = new THREE.Vector3(0,0,1);

        const quaternionRotation204 = new THREE.Quaternion();
        quaternionRotation204.setFromUnitVectors(initialNormal204, normalVec204);

        ringMesh204.setRotationFromQuaternion(quaternionRotation204);

        return quaternionRotation204;
    }

    ringRoot.add(ringMesh204);
            
	var inradius205 = calulateInradius(getVertex8(), getVertex54(), getVertex55());
	var incenter205 = calulateIncenter(getVertex8(), getVertex54(), getVertex55());
	var ringGeometry205 = new THREE.RingGeometry((inradius205 - 0.005),inradius205, 32);
	const ringMaterial205 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh205 = new THREE.Mesh(ringGeometry205, ringMaterial205);

	function setCircleRotation205(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.5490196078431373],[0.,0.,0.53921568627450989]);

        ringMesh205.position.setX(incenter[0]);
        ringMesh205.position.setY(incenter[1]);
        ringMesh205.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex54(), getVertex55());
        var relRadius = inradius/inradius205;

        ringMesh205.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A205 = new THREE.Vector3(0.,-1.,1.);
        const B205 = new THREE.Vector3(0.,0.,0.5490196078431373);
        const C205 = new THREE.Vector3(0.,0.,0.53921568627450989);

        const normalVec205 = new THREE.Vector3();
        normalVec205.crossVectors(B205.sub(A205), C205.sub(A205));
        normalVec205.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal205 = new THREE.Vector3(0,0,1);

        const quaternionRotation205 = new THREE.Quaternion();
        quaternionRotation205.setFromUnitVectors(initialNormal205, normalVec205);

        ringMesh205.setRotationFromQuaternion(quaternionRotation205);

        return quaternionRotation205;
    }

    ringRoot.add(ringMesh205);
            
	var inradius206 = calulateInradius(getVertex7(), getVertex62(), getVertex63());
	var incenter206 = calulateIncenter(getVertex7(), getVertex62(), getVertex63());
	var ringGeometry206 = new THREE.RingGeometry((inradius206 - 0.005),inradius206, 32);
	const ringMaterial206 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh206 = new THREE.Mesh(ringGeometry206, ringMaterial206);

	function setCircleRotation206(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.47058823529411764],[0.,0.,0.46078431372549022]);

        ringMesh206.position.setX(incenter[0]);
        ringMesh206.position.setY(incenter[1]);
        ringMesh206.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex62(), getVertex63());
        var relRadius = inradius/inradius206;

        ringMesh206.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A206 = new THREE.Vector3(0.,-1.,0.);
        const B206 = new THREE.Vector3(0.,0.,0.47058823529411764);
        const C206 = new THREE.Vector3(0.,0.,0.46078431372549022);

        const normalVec206 = new THREE.Vector3();
        normalVec206.crossVectors(B206.sub(A206), C206.sub(A206));
        normalVec206.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal206 = new THREE.Vector3(0,0,1);

        const quaternionRotation206 = new THREE.Quaternion();
        quaternionRotation206.setFromUnitVectors(initialNormal206, normalVec206);

        ringMesh206.setRotationFromQuaternion(quaternionRotation206);

        return quaternionRotation206;
    }

    ringRoot.add(ringMesh206);
            
	var inradius207 = calulateInradius(getVertex8(), getVertex55(), getVertex56());
	var incenter207 = calulateIncenter(getVertex8(), getVertex55(), getVertex56());
	var ringGeometry207 = new THREE.RingGeometry((inradius207 - 0.005),inradius207, 32);
	const ringMaterial207 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh207 = new THREE.Mesh(ringGeometry207, ringMaterial207);

	function setCircleRotation207(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.53921568627450989],[0.,0.,0.52941176470588236]);

        ringMesh207.position.setX(incenter[0]);
        ringMesh207.position.setY(incenter[1]);
        ringMesh207.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex55(), getVertex56());
        var relRadius = inradius/inradius207;

        ringMesh207.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A207 = new THREE.Vector3(0.,-1.,1.);
        const B207 = new THREE.Vector3(0.,0.,0.53921568627450989);
        const C207 = new THREE.Vector3(0.,0.,0.52941176470588236);

        const normalVec207 = new THREE.Vector3();
        normalVec207.crossVectors(B207.sub(A207), C207.sub(A207));
        normalVec207.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal207 = new THREE.Vector3(0,0,1);

        const quaternionRotation207 = new THREE.Quaternion();
        quaternionRotation207.setFromUnitVectors(initialNormal207, normalVec207);

        ringMesh207.setRotationFromQuaternion(quaternionRotation207);

        return quaternionRotation207;
    }

    ringRoot.add(ringMesh207);
            
	var inradius208 = calulateInradius(getVertex7(), getVertex61(), getVertex62());
	var incenter208 = calulateIncenter(getVertex7(), getVertex61(), getVertex62());
	var ringGeometry208 = new THREE.RingGeometry((inradius208 - 0.005),inradius208, 32);
	const ringMaterial208 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh208 = new THREE.Mesh(ringGeometry208, ringMaterial208);

	function setCircleRotation208(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.48039215686274506],[0.,0.,0.47058823529411764]);

        ringMesh208.position.setX(incenter[0]);
        ringMesh208.position.setY(incenter[1]);
        ringMesh208.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex61(), getVertex62());
        var relRadius = inradius/inradius208;

        ringMesh208.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A208 = new THREE.Vector3(0.,-1.,0.);
        const B208 = new THREE.Vector3(0.,0.,0.48039215686274506);
        const C208 = new THREE.Vector3(0.,0.,0.47058823529411764);

        const normalVec208 = new THREE.Vector3();
        normalVec208.crossVectors(B208.sub(A208), C208.sub(A208));
        normalVec208.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal208 = new THREE.Vector3(0,0,1);

        const quaternionRotation208 = new THREE.Quaternion();
        quaternionRotation208.setFromUnitVectors(initialNormal208, normalVec208);

        ringMesh208.setRotationFromQuaternion(quaternionRotation208);

        return quaternionRotation208;
    }

    ringRoot.add(ringMesh208);
            
	var inradius209 = calulateInradius(getVertex8(), getVertex56(), getVertex57());
	var incenter209 = calulateIncenter(getVertex8(), getVertex56(), getVertex57());
	var ringGeometry209 = new THREE.RingGeometry((inradius209 - 0.005),inradius209, 32);
	const ringMaterial209 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh209 = new THREE.Mesh(ringGeometry209, ringMaterial209);

	function setCircleRotation209(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.52941176470588236],[0.,0.,0.51960784313725483]);

        ringMesh209.position.setX(incenter[0]);
        ringMesh209.position.setY(incenter[1]);
        ringMesh209.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex56(), getVertex57());
        var relRadius = inradius/inradius209;

        ringMesh209.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A209 = new THREE.Vector3(0.,-1.,1.);
        const B209 = new THREE.Vector3(0.,0.,0.52941176470588236);
        const C209 = new THREE.Vector3(0.,0.,0.51960784313725483);

        const normalVec209 = new THREE.Vector3();
        normalVec209.crossVectors(B209.sub(A209), C209.sub(A209));
        normalVec209.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal209 = new THREE.Vector3(0,0,1);

        const quaternionRotation209 = new THREE.Quaternion();
        quaternionRotation209.setFromUnitVectors(initialNormal209, normalVec209);

        ringMesh209.setRotationFromQuaternion(quaternionRotation209);

        return quaternionRotation209;
    }

    ringRoot.add(ringMesh209);
            
	var inradius210 = calulateInradius(getVertex7(), getVertex60(), getVertex61());
	var incenter210 = calulateIncenter(getVertex7(), getVertex60(), getVertex61());
	var ringGeometry210 = new THREE.RingGeometry((inradius210 - 0.005),inradius210, 32);
	const ringMaterial210 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh210 = new THREE.Mesh(ringGeometry210, ringMaterial210);

	function setCircleRotation210(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.49019607843137258],[0.,0.,0.48039215686274506]);

        ringMesh210.position.setX(incenter[0]);
        ringMesh210.position.setY(incenter[1]);
        ringMesh210.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex60(), getVertex61());
        var relRadius = inradius/inradius210;

        ringMesh210.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A210 = new THREE.Vector3(0.,-1.,0.);
        const B210 = new THREE.Vector3(0.,0.,0.49019607843137258);
        const C210 = new THREE.Vector3(0.,0.,0.48039215686274506);

        const normalVec210 = new THREE.Vector3();
        normalVec210.crossVectors(B210.sub(A210), C210.sub(A210));
        normalVec210.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal210 = new THREE.Vector3(0,0,1);

        const quaternionRotation210 = new THREE.Quaternion();
        quaternionRotation210.setFromUnitVectors(initialNormal210, normalVec210);

        ringMesh210.setRotationFromQuaternion(quaternionRotation210);

        return quaternionRotation210;
    }

    ringRoot.add(ringMesh210);
            
	var inradius211 = calulateInradius(getVertex8(), getVertex57(), getVertex58());
	var incenter211 = calulateIncenter(getVertex8(), getVertex57(), getVertex58());
	var ringGeometry211 = new THREE.RingGeometry((inradius211 - 0.005),inradius211, 32);
	const ringMaterial211 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh211 = new THREE.Mesh(ringGeometry211, ringMaterial211);

	function setCircleRotation211(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.51960784313725483],[0.,0.,0.50980392156862742]);

        ringMesh211.position.setX(incenter[0]);
        ringMesh211.position.setY(incenter[1]);
        ringMesh211.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex57(), getVertex58());
        var relRadius = inradius/inradius211;

        ringMesh211.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A211 = new THREE.Vector3(0.,-1.,1.);
        const B211 = new THREE.Vector3(0.,0.,0.51960784313725483);
        const C211 = new THREE.Vector3(0.,0.,0.50980392156862742);

        const normalVec211 = new THREE.Vector3();
        normalVec211.crossVectors(B211.sub(A211), C211.sub(A211));
        normalVec211.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal211 = new THREE.Vector3(0,0,1);

        const quaternionRotation211 = new THREE.Quaternion();
        quaternionRotation211.setFromUnitVectors(initialNormal211, normalVec211);

        ringMesh211.setRotationFromQuaternion(quaternionRotation211);

        return quaternionRotation211;
    }

    ringRoot.add(ringMesh211);
            
	var inradius212 = calulateInradius(getVertex7(), getVertex59(), getVertex60());
	var incenter212 = calulateIncenter(getVertex7(), getVertex59(), getVertex60());
	var ringGeometry212 = new THREE.RingGeometry((inradius212 - 0.005),inradius212, 32);
	const ringMaterial212 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh212 = new THREE.Mesh(ringGeometry212, ringMaterial212);

	function setCircleRotation212(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.5],[0.,0.,0.49019607843137258]);

        ringMesh212.position.setX(incenter[0]);
        ringMesh212.position.setY(incenter[1]);
        ringMesh212.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex59(), getVertex60());
        var relRadius = inradius/inradius212;

        ringMesh212.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A212 = new THREE.Vector3(0.,-1.,0.);
        const B212 = new THREE.Vector3(0.,0.,0.5);
        const C212 = new THREE.Vector3(0.,0.,0.49019607843137258);

        const normalVec212 = new THREE.Vector3();
        normalVec212.crossVectors(B212.sub(A212), C212.sub(A212));
        normalVec212.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal212 = new THREE.Vector3(0,0,1);

        const quaternionRotation212 = new THREE.Quaternion();
        quaternionRotation212.setFromUnitVectors(initialNormal212, normalVec212);

        ringMesh212.setRotationFromQuaternion(quaternionRotation212);

        return quaternionRotation212;
    }

    ringRoot.add(ringMesh212);
            
	var inradius213 = calulateInradius(getVertex8(), getVertex58(), getVertex59());
	var incenter213 = calulateIncenter(getVertex8(), getVertex58(), getVertex59());
	var ringGeometry213 = new THREE.RingGeometry((inradius213 - 0.005),inradius213, 32);
	const ringMaterial213 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh213 = new THREE.Mesh(ringGeometry213, ringMaterial213);

	function setCircleRotation213(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.50980392156862742],[0.,0.,0.5]);

        ringMesh213.position.setX(incenter[0]);
        ringMesh213.position.setY(incenter[1]);
        ringMesh213.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex58(), getVertex59());
        var relRadius = inradius/inradius213;

        ringMesh213.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A213 = new THREE.Vector3(0.,-1.,1.);
        const B213 = new THREE.Vector3(0.,0.,0.50980392156862742);
        const C213 = new THREE.Vector3(0.,0.,0.5);

        const normalVec213 = new THREE.Vector3();
        normalVec213.crossVectors(B213.sub(A213), C213.sub(A213));
        normalVec213.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal213 = new THREE.Vector3(0,0,1);

        const quaternionRotation213 = new THREE.Quaternion();
        quaternionRotation213.setFromUnitVectors(initialNormal213, normalVec213);

        ringMesh213.setRotationFromQuaternion(quaternionRotation213);

        return quaternionRotation213;
    }

    ringRoot.add(ringMesh213);
            
	var inradius214 = calulateInradius(getVertex7(), getVertex8(), getVertex59());
	var incenter214 = calulateIncenter(getVertex7(), getVertex8(), getVertex59());
	var ringGeometry214 = new THREE.RingGeometry((inradius214 - 0.005),inradius214, 32);
	const ringMaterial214 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh214 = new THREE.Mesh(ringGeometry214, ringMaterial214);

	function setCircleRotation214(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,-1.,0.],[ 0.,-1.,1.],[0.,0.,0.5]);

        ringMesh214.position.setX(incenter[0]);
        ringMesh214.position.setY(incenter[1]);
        ringMesh214.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex8(), getVertex59());
        var relRadius = inradius/inradius214;

        ringMesh214.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A214 = new THREE.Vector3(0.,-1.,0.);
        const B214 = new THREE.Vector3(0.,-1.,1.);
        const C214 = new THREE.Vector3(0.,0.,0.5);

        const normalVec214 = new THREE.Vector3();
        normalVec214.crossVectors(B214.sub(A214), C214.sub(A214));
        normalVec214.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal214 = new THREE.Vector3(0,0,1);

        const quaternionRotation214 = new THREE.Quaternion();
        quaternionRotation214.setFromUnitVectors(initialNormal214, normalVec214);

        ringMesh214.setRotationFromQuaternion(quaternionRotation214);

        return quaternionRotation214;
    }

    ringRoot.add(ringMesh214);
            
	var inradius215 = calulateInradius(getVertex110(), getVertex111(), getVertex112());
	var incenter215 = calulateIncenter(getVertex110(), getVertex111(), getVertex112());
	var ringGeometry215 = new THREE.RingGeometry((inradius215 - 0.005),inradius215, 32);
	const ringMaterial215 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh215 = new THREE.Mesh(ringGeometry215, ringMaterial215);

	function setCircleRotation215(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,1.,1.],[ 1.,1.,0.],[1.,0.,0.]);

        ringMesh215.position.setX(incenter[0]);
        ringMesh215.position.setY(incenter[1]);
        ringMesh215.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex110(), getVertex111(), getVertex112());
        var relRadius = inradius/inradius215;

        ringMesh215.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A215 = new THREE.Vector3(1.,1.,1.);
        const B215 = new THREE.Vector3(1.,1.,0.);
        const C215 = new THREE.Vector3(1.,0.,0.);

        const normalVec215 = new THREE.Vector3();
        normalVec215.crossVectors(B215.sub(A215), C215.sub(A215));
        normalVec215.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal215 = new THREE.Vector3(0,0,1);

        const quaternionRotation215 = new THREE.Quaternion();
        quaternionRotation215.setFromUnitVectors(initialNormal215, normalVec215);

        ringMesh215.setRotationFromQuaternion(quaternionRotation215);

        return quaternionRotation215;
    }

    ringRoot.add(ringMesh215);
            
	var inradius216 = calulateInradius(getVertex110(), getVertex112(), getVertex113());
	var incenter216 = calulateIncenter(getVertex110(), getVertex112(), getVertex113());
	var ringGeometry216 = new THREE.RingGeometry((inradius216 - 0.005),inradius216, 32);
	const ringMaterial216 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh216 = new THREE.Mesh(ringGeometry216, ringMaterial216);

	function setCircleRotation216(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,1.,1.],[ 1.,0.,0.],[1.,0.,1.]);

        ringMesh216.position.setX(incenter[0]);
        ringMesh216.position.setY(incenter[1]);
        ringMesh216.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex110(), getVertex112(), getVertex113());
        var relRadius = inradius/inradius216;

        ringMesh216.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A216 = new THREE.Vector3(1.,1.,1.);
        const B216 = new THREE.Vector3(1.,0.,0.);
        const C216 = new THREE.Vector3(1.,0.,1.);

        const normalVec216 = new THREE.Vector3();
        normalVec216.crossVectors(B216.sub(A216), C216.sub(A216));
        normalVec216.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal216 = new THREE.Vector3(0,0,1);

        const quaternionRotation216 = new THREE.Quaternion();
        quaternionRotation216.setFromUnitVectors(initialNormal216, normalVec216);

        ringMesh216.setRotationFromQuaternion(quaternionRotation216);

        return quaternionRotation216;
    }

    ringRoot.add(ringMesh216);
            
	var inradius217 = calulateInradius(getVertex110(), getVertex111(), getVertex116());
	var incenter217 = calulateIncenter(getVertex110(), getVertex111(), getVertex116());
	var ringGeometry217 = new THREE.RingGeometry((inradius217 - 0.005),inradius217, 32);
	const ringMaterial217 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh217 = new THREE.Mesh(ringGeometry217, ringMaterial217);

	function setCircleRotation217(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,1.,1.],[ 1.,1.,0.],[0.,1.,0.]);

        ringMesh217.position.setX(incenter[0]);
        ringMesh217.position.setY(incenter[1]);
        ringMesh217.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex110(), getVertex111(), getVertex116());
        var relRadius = inradius/inradius217;

        ringMesh217.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A217 = new THREE.Vector3(1.,1.,1.);
        const B217 = new THREE.Vector3(1.,1.,0.);
        const C217 = new THREE.Vector3(0.,1.,0.);

        const normalVec217 = new THREE.Vector3();
        normalVec217.crossVectors(B217.sub(A217), C217.sub(A217));
        normalVec217.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal217 = new THREE.Vector3(0,0,1);

        const quaternionRotation217 = new THREE.Quaternion();
        quaternionRotation217.setFromUnitVectors(initialNormal217, normalVec217);

        ringMesh217.setRotationFromQuaternion(quaternionRotation217);

        return quaternionRotation217;
    }

    ringRoot.add(ringMesh217);
            
	var inradius218 = calulateInradius(getVertex110(), getVertex116(), getVertex117());
	var incenter218 = calulateIncenter(getVertex110(), getVertex116(), getVertex117());
	var ringGeometry218 = new THREE.RingGeometry((inradius218 - 0.005),inradius218, 32);
	const ringMaterial218 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh218 = new THREE.Mesh(ringGeometry218, ringMaterial218);

	function setCircleRotation218(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,1.,1.],[ 0.,1.,0.],[0.,1.,1.]);

        ringMesh218.position.setX(incenter[0]);
        ringMesh218.position.setY(incenter[1]);
        ringMesh218.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex110(), getVertex116(), getVertex117());
        var relRadius = inradius/inradius218;

        ringMesh218.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A218 = new THREE.Vector3(1.,1.,1.);
        const B218 = new THREE.Vector3(0.,1.,0.);
        const C218 = new THREE.Vector3(0.,1.,1.);

        const normalVec218 = new THREE.Vector3();
        normalVec218.crossVectors(B218.sub(A218), C218.sub(A218));
        normalVec218.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal218 = new THREE.Vector3(0,0,1);

        const quaternionRotation218 = new THREE.Quaternion();
        quaternionRotation218.setFromUnitVectors(initialNormal218, normalVec218);

        ringMesh218.setRotationFromQuaternion(quaternionRotation218);

        return quaternionRotation218;
    }

    ringRoot.add(ringMesh218);
            
	var inradius219 = calulateInradius(getVertex111(), getVertex112(), getVertex116());
	var incenter219 = calulateIncenter(getVertex111(), getVertex112(), getVertex116());
	var ringGeometry219 = new THREE.RingGeometry((inradius219 - 0.005),inradius219, 32);
	const ringMaterial219 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh219 = new THREE.Mesh(ringGeometry219, ringMaterial219);

	function setCircleRotation219(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,1.,0.],[ 1.,0.,0.],[0.,1.,0.]);

        ringMesh219.position.setX(incenter[0]);
        ringMesh219.position.setY(incenter[1]);
        ringMesh219.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex111(), getVertex112(), getVertex116());
        var relRadius = inradius/inradius219;

        ringMesh219.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A219 = new THREE.Vector3(1.,1.,0.);
        const B219 = new THREE.Vector3(1.,0.,0.);
        const C219 = new THREE.Vector3(0.,1.,0.);

        const normalVec219 = new THREE.Vector3();
        normalVec219.crossVectors(B219.sub(A219), C219.sub(A219));
        normalVec219.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal219 = new THREE.Vector3(0,0,1);

        const quaternionRotation219 = new THREE.Quaternion();
        quaternionRotation219.setFromUnitVectors(initialNormal219, normalVec219);

        ringMesh219.setRotationFromQuaternion(quaternionRotation219);

        return quaternionRotation219;
    }

    ringRoot.add(ringMesh219);
            
	var inradius220 = calulateInradius(getVertex112(), getVertex115(), getVertex116());
	var incenter220 = calulateIncenter(getVertex112(), getVertex115(), getVertex116());
	var ringGeometry220 = new THREE.RingGeometry((inradius220 - 0.005),inradius220, 32);
	const ringMaterial220 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh220 = new THREE.Mesh(ringGeometry220, ringMaterial220);

	function setCircleRotation220(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.],[0.,1.,0.]);

        ringMesh220.position.setX(incenter[0]);
        ringMesh220.position.setY(incenter[1]);
        ringMesh220.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex115(), getVertex116());
        var relRadius = inradius/inradius220;

        ringMesh220.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A220 = new THREE.Vector3(1.,0.,0.);
        const B220 = new THREE.Vector3(0.,0.,0.);
        const C220 = new THREE.Vector3(0.,1.,0.);

        const normalVec220 = new THREE.Vector3();
        normalVec220.crossVectors(B220.sub(A220), C220.sub(A220));
        normalVec220.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal220 = new THREE.Vector3(0,0,1);

        const quaternionRotation220 = new THREE.Quaternion();
        quaternionRotation220.setFromUnitVectors(initialNormal220, normalVec220);

        ringMesh220.setRotationFromQuaternion(quaternionRotation220);

        return quaternionRotation220;
    }

    ringRoot.add(ringMesh220);
            
	var inradius221 = calulateInradius(getVertex110(), getVertex113(), getVertex117());
	var incenter221 = calulateIncenter(getVertex110(), getVertex113(), getVertex117());
	var ringGeometry221 = new THREE.RingGeometry((inradius221 - 0.005),inradius221, 32);
	const ringMaterial221 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh221 = new THREE.Mesh(ringGeometry221, ringMaterial221);

	function setCircleRotation221(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,1.,1.],[ 1.,0.,1.],[0.,1.,1.]);

        ringMesh221.position.setX(incenter[0]);
        ringMesh221.position.setY(incenter[1]);
        ringMesh221.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex110(), getVertex113(), getVertex117());
        var relRadius = inradius/inradius221;

        ringMesh221.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A221 = new THREE.Vector3(1.,1.,1.);
        const B221 = new THREE.Vector3(1.,0.,1.);
        const C221 = new THREE.Vector3(0.,1.,1.);

        const normalVec221 = new THREE.Vector3();
        normalVec221.crossVectors(B221.sub(A221), C221.sub(A221));
        normalVec221.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal221 = new THREE.Vector3(0,0,1);

        const quaternionRotation221 = new THREE.Quaternion();
        quaternionRotation221.setFromUnitVectors(initialNormal221, normalVec221);

        ringMesh221.setRotationFromQuaternion(quaternionRotation221);

        return quaternionRotation221;
    }

    ringRoot.add(ringMesh221);
            
	var inradius222 = calulateInradius(getVertex113(), getVertex114(), getVertex117());
	var incenter222 = calulateIncenter(getVertex113(), getVertex114(), getVertex117());
	var ringGeometry222 = new THREE.RingGeometry((inradius222 - 0.005),inradius222, 32);
	const ringMaterial222 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh222 = new THREE.Mesh(ringGeometry222, ringMaterial222);

	function setCircleRotation222(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,1.],[0.,1.,1.]);

        ringMesh222.position.setX(incenter[0]);
        ringMesh222.position.setY(incenter[1]);
        ringMesh222.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex114(), getVertex117());
        var relRadius = inradius/inradius222;

        ringMesh222.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A222 = new THREE.Vector3(1.,0.,1.);
        const B222 = new THREE.Vector3(0.,0.,1.);
        const C222 = new THREE.Vector3(0.,1.,1.);

        const normalVec222 = new THREE.Vector3();
        normalVec222.crossVectors(B222.sub(A222), C222.sub(A222));
        normalVec222.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal222 = new THREE.Vector3(0,0,1);

        const quaternionRotation222 = new THREE.Quaternion();
        quaternionRotation222.setFromUnitVectors(initialNormal222, normalVec222);

        ringMesh222.setRotationFromQuaternion(quaternionRotation222);

        return quaternionRotation222;
    }

    ringRoot.add(ringMesh222);
            
	var inradius223 = calulateInradius(getVertex112(), getVertex115(), getVertex218());
	var incenter223 = calulateIncenter(getVertex112(), getVertex115(), getVertex218());
	var ringGeometry223 = new THREE.RingGeometry((inradius223 - 0.005),inradius223, 32);
	const ringMaterial223 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh223 = new THREE.Mesh(ringGeometry223, ringMaterial223);

	function setCircleRotation223(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.],[0.,0.,0.0098039215686274161]);

        ringMesh223.position.setX(incenter[0]);
        ringMesh223.position.setY(incenter[1]);
        ringMesh223.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex115(), getVertex218());
        var relRadius = inradius/inradius223;

        ringMesh223.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A223 = new THREE.Vector3(1.,0.,0.);
        const B223 = new THREE.Vector3(0.,0.,0.);
        const C223 = new THREE.Vector3(0.,0.,0.0098039215686274161);

        const normalVec223 = new THREE.Vector3();
        normalVec223.crossVectors(B223.sub(A223), C223.sub(A223));
        normalVec223.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal223 = new THREE.Vector3(0,0,1);

        const quaternionRotation223 = new THREE.Quaternion();
        quaternionRotation223.setFromUnitVectors(initialNormal223, normalVec223);

        ringMesh223.setRotationFromQuaternion(quaternionRotation223);

        return quaternionRotation223;
    }

    ringRoot.add(ringMesh223);
            
	var inradius224 = calulateInradius(getVertex113(), getVertex114(), getVertex118());
	var incenter224 = calulateIncenter(getVertex113(), getVertex114(), getVertex118());
	var ringGeometry224 = new THREE.RingGeometry((inradius224 - 0.005),inradius224, 32);
	const ringMaterial224 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh224 = new THREE.Mesh(ringGeometry224, ringMaterial224);

	function setCircleRotation224(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,1.],[0.,0.,0.99019607843137258]);

        ringMesh224.position.setX(incenter[0]);
        ringMesh224.position.setY(incenter[1]);
        ringMesh224.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex114(), getVertex118());
        var relRadius = inradius/inradius224;

        ringMesh224.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A224 = new THREE.Vector3(1.,0.,1.);
        const B224 = new THREE.Vector3(0.,0.,1.);
        const C224 = new THREE.Vector3(0.,0.,0.99019607843137258);

        const normalVec224 = new THREE.Vector3();
        normalVec224.crossVectors(B224.sub(A224), C224.sub(A224));
        normalVec224.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal224 = new THREE.Vector3(0,0,1);

        const quaternionRotation224 = new THREE.Quaternion();
        quaternionRotation224.setFromUnitVectors(initialNormal224, normalVec224);

        ringMesh224.setRotationFromQuaternion(quaternionRotation224);

        return quaternionRotation224;
    }

    ringRoot.add(ringMesh224);
            
	var inradius225 = calulateInradius(getVertex112(), getVertex217(), getVertex218());
	var incenter225 = calulateIncenter(getVertex112(), getVertex217(), getVertex218());
	var ringGeometry225 = new THREE.RingGeometry((inradius225 - 0.005),inradius225, 32);
	const ringMaterial225 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh225 = new THREE.Mesh(ringGeometry225, ringMaterial225);

	function setCircleRotation225(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.019607843137254943],[0.,0.,0.0098039215686274161]);

        ringMesh225.position.setX(incenter[0]);
        ringMesh225.position.setY(incenter[1]);
        ringMesh225.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex217(), getVertex218());
        var relRadius = inradius/inradius225;

        ringMesh225.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A225 = new THREE.Vector3(1.,0.,0.);
        const B225 = new THREE.Vector3(0.,0.,0.019607843137254943);
        const C225 = new THREE.Vector3(0.,0.,0.0098039215686274161);

        const normalVec225 = new THREE.Vector3();
        normalVec225.crossVectors(B225.sub(A225), C225.sub(A225));
        normalVec225.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal225 = new THREE.Vector3(0,0,1);

        const quaternionRotation225 = new THREE.Quaternion();
        quaternionRotation225.setFromUnitVectors(initialNormal225, normalVec225);

        ringMesh225.setRotationFromQuaternion(quaternionRotation225);

        return quaternionRotation225;
    }

    ringRoot.add(ringMesh225);
            
	var inradius226 = calulateInradius(getVertex113(), getVertex118(), getVertex119());
	var incenter226 = calulateIncenter(getVertex113(), getVertex118(), getVertex119());
	var ringGeometry226 = new THREE.RingGeometry((inradius226 - 0.005),inradius226, 32);
	const ringMaterial226 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh226 = new THREE.Mesh(ringGeometry226, ringMaterial226);

	function setCircleRotation226(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.99019607843137258],[0.,0.,0.98039215686274506]);

        ringMesh226.position.setX(incenter[0]);
        ringMesh226.position.setY(incenter[1]);
        ringMesh226.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex118(), getVertex119());
        var relRadius = inradius/inradius226;

        ringMesh226.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A226 = new THREE.Vector3(1.,0.,1.);
        const B226 = new THREE.Vector3(0.,0.,0.99019607843137258);
        const C226 = new THREE.Vector3(0.,0.,0.98039215686274506);

        const normalVec226 = new THREE.Vector3();
        normalVec226.crossVectors(B226.sub(A226), C226.sub(A226));
        normalVec226.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal226 = new THREE.Vector3(0,0,1);

        const quaternionRotation226 = new THREE.Quaternion();
        quaternionRotation226.setFromUnitVectors(initialNormal226, normalVec226);

        ringMesh226.setRotationFromQuaternion(quaternionRotation226);

        return quaternionRotation226;
    }

    ringRoot.add(ringMesh226);
            
	var inradius227 = calulateInradius(getVertex112(), getVertex216(), getVertex217());
	var incenter227 = calulateIncenter(getVertex112(), getVertex216(), getVertex217());
	var ringGeometry227 = new THREE.RingGeometry((inradius227 - 0.005),inradius227, 32);
	const ringMaterial227 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh227 = new THREE.Mesh(ringGeometry227, ringMaterial227);

	function setCircleRotation227(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.029411764705882359],[0.,0.,0.019607843137254943]);

        ringMesh227.position.setX(incenter[0]);
        ringMesh227.position.setY(incenter[1]);
        ringMesh227.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex216(), getVertex217());
        var relRadius = inradius/inradius227;

        ringMesh227.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A227 = new THREE.Vector3(1.,0.,0.);
        const B227 = new THREE.Vector3(0.,0.,0.029411764705882359);
        const C227 = new THREE.Vector3(0.,0.,0.019607843137254943);

        const normalVec227 = new THREE.Vector3();
        normalVec227.crossVectors(B227.sub(A227), C227.sub(A227));
        normalVec227.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal227 = new THREE.Vector3(0,0,1);

        const quaternionRotation227 = new THREE.Quaternion();
        quaternionRotation227.setFromUnitVectors(initialNormal227, normalVec227);

        ringMesh227.setRotationFromQuaternion(quaternionRotation227);

        return quaternionRotation227;
    }

    ringRoot.add(ringMesh227);
            
	var inradius228 = calulateInradius(getVertex113(), getVertex119(), getVertex120());
	var incenter228 = calulateIncenter(getVertex113(), getVertex119(), getVertex120());
	var ringGeometry228 = new THREE.RingGeometry((inradius228 - 0.005),inradius228, 32);
	const ringMaterial228 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh228 = new THREE.Mesh(ringGeometry228, ringMaterial228);

	function setCircleRotation228(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.98039215686274506],[0.,0.,0.97058823529411764]);

        ringMesh228.position.setX(incenter[0]);
        ringMesh228.position.setY(incenter[1]);
        ringMesh228.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex119(), getVertex120());
        var relRadius = inradius/inradius228;

        ringMesh228.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A228 = new THREE.Vector3(1.,0.,1.);
        const B228 = new THREE.Vector3(0.,0.,0.98039215686274506);
        const C228 = new THREE.Vector3(0.,0.,0.97058823529411764);

        const normalVec228 = new THREE.Vector3();
        normalVec228.crossVectors(B228.sub(A228), C228.sub(A228));
        normalVec228.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal228 = new THREE.Vector3(0,0,1);

        const quaternionRotation228 = new THREE.Quaternion();
        quaternionRotation228.setFromUnitVectors(initialNormal228, normalVec228);

        ringMesh228.setRotationFromQuaternion(quaternionRotation228);

        return quaternionRotation228;
    }

    ringRoot.add(ringMesh228);
            
	var inradius229 = calulateInradius(getVertex112(), getVertex215(), getVertex216());
	var incenter229 = calulateIncenter(getVertex112(), getVertex215(), getVertex216());
	var ringGeometry229 = new THREE.RingGeometry((inradius229 - 0.005),inradius229, 32);
	const ringMaterial229 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh229 = new THREE.Mesh(ringGeometry229, ringMaterial229);

	function setCircleRotation229(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.039215686274509776],[0.,0.,0.029411764705882359]);

        ringMesh229.position.setX(incenter[0]);
        ringMesh229.position.setY(incenter[1]);
        ringMesh229.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex215(), getVertex216());
        var relRadius = inradius/inradius229;

        ringMesh229.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A229 = new THREE.Vector3(1.,0.,0.);
        const B229 = new THREE.Vector3(0.,0.,0.039215686274509776);
        const C229 = new THREE.Vector3(0.,0.,0.029411764705882359);

        const normalVec229 = new THREE.Vector3();
        normalVec229.crossVectors(B229.sub(A229), C229.sub(A229));
        normalVec229.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal229 = new THREE.Vector3(0,0,1);

        const quaternionRotation229 = new THREE.Quaternion();
        quaternionRotation229.setFromUnitVectors(initialNormal229, normalVec229);

        ringMesh229.setRotationFromQuaternion(quaternionRotation229);

        return quaternionRotation229;
    }

    ringRoot.add(ringMesh229);
            
	var inradius230 = calulateInradius(getVertex113(), getVertex120(), getVertex121());
	var incenter230 = calulateIncenter(getVertex113(), getVertex120(), getVertex121());
	var ringGeometry230 = new THREE.RingGeometry((inradius230 - 0.005),inradius230, 32);
	const ringMaterial230 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh230 = new THREE.Mesh(ringGeometry230, ringMaterial230);

	function setCircleRotation230(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.97058823529411764],[0.,0.,0.96078431372549022]);

        ringMesh230.position.setX(incenter[0]);
        ringMesh230.position.setY(incenter[1]);
        ringMesh230.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex120(), getVertex121());
        var relRadius = inradius/inradius230;

        ringMesh230.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A230 = new THREE.Vector3(1.,0.,1.);
        const B230 = new THREE.Vector3(0.,0.,0.97058823529411764);
        const C230 = new THREE.Vector3(0.,0.,0.96078431372549022);

        const normalVec230 = new THREE.Vector3();
        normalVec230.crossVectors(B230.sub(A230), C230.sub(A230));
        normalVec230.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal230 = new THREE.Vector3(0,0,1);

        const quaternionRotation230 = new THREE.Quaternion();
        quaternionRotation230.setFromUnitVectors(initialNormal230, normalVec230);

        ringMesh230.setRotationFromQuaternion(quaternionRotation230);

        return quaternionRotation230;
    }

    ringRoot.add(ringMesh230);
            
	var inradius231 = calulateInradius(getVertex112(), getVertex214(), getVertex215());
	var incenter231 = calulateIncenter(getVertex112(), getVertex214(), getVertex215());
	var ringGeometry231 = new THREE.RingGeometry((inradius231 - 0.005),inradius231, 32);
	const ringMaterial231 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh231 = new THREE.Mesh(ringGeometry231, ringMaterial231);

	function setCircleRotation231(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.049019607843137303],[0.,0.,0.039215686274509776]);

        ringMesh231.position.setX(incenter[0]);
        ringMesh231.position.setY(incenter[1]);
        ringMesh231.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex214(), getVertex215());
        var relRadius = inradius/inradius231;

        ringMesh231.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A231 = new THREE.Vector3(1.,0.,0.);
        const B231 = new THREE.Vector3(0.,0.,0.049019607843137303);
        const C231 = new THREE.Vector3(0.,0.,0.039215686274509776);

        const normalVec231 = new THREE.Vector3();
        normalVec231.crossVectors(B231.sub(A231), C231.sub(A231));
        normalVec231.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal231 = new THREE.Vector3(0,0,1);

        const quaternionRotation231 = new THREE.Quaternion();
        quaternionRotation231.setFromUnitVectors(initialNormal231, normalVec231);

        ringMesh231.setRotationFromQuaternion(quaternionRotation231);

        return quaternionRotation231;
    }

    ringRoot.add(ringMesh231);
            
	var inradius232 = calulateInradius(getVertex113(), getVertex121(), getVertex122());
	var incenter232 = calulateIncenter(getVertex113(), getVertex121(), getVertex122());
	var ringGeometry232 = new THREE.RingGeometry((inradius232 - 0.005),inradius232, 32);
	const ringMaterial232 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh232 = new THREE.Mesh(ringGeometry232, ringMaterial232);

	function setCircleRotation232(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.96078431372549022],[0.,0.,0.9509803921568627]);

        ringMesh232.position.setX(incenter[0]);
        ringMesh232.position.setY(incenter[1]);
        ringMesh232.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex121(), getVertex122());
        var relRadius = inradius/inradius232;

        ringMesh232.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A232 = new THREE.Vector3(1.,0.,1.);
        const B232 = new THREE.Vector3(0.,0.,0.96078431372549022);
        const C232 = new THREE.Vector3(0.,0.,0.9509803921568627);

        const normalVec232 = new THREE.Vector3();
        normalVec232.crossVectors(B232.sub(A232), C232.sub(A232));
        normalVec232.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal232 = new THREE.Vector3(0,0,1);

        const quaternionRotation232 = new THREE.Quaternion();
        quaternionRotation232.setFromUnitVectors(initialNormal232, normalVec232);

        ringMesh232.setRotationFromQuaternion(quaternionRotation232);

        return quaternionRotation232;
    }

    ringRoot.add(ringMesh232);
            
	var inradius233 = calulateInradius(getVertex112(), getVertex213(), getVertex214());
	var incenter233 = calulateIncenter(getVertex112(), getVertex213(), getVertex214());
	var ringGeometry233 = new THREE.RingGeometry((inradius233 - 0.005),inradius233, 32);
	const ringMaterial233 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh233 = new THREE.Mesh(ringGeometry233, ringMaterial233);

	function setCircleRotation233(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.058823529411764719],[0.,0.,0.049019607843137303]);

        ringMesh233.position.setX(incenter[0]);
        ringMesh233.position.setY(incenter[1]);
        ringMesh233.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex213(), getVertex214());
        var relRadius = inradius/inradius233;

        ringMesh233.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A233 = new THREE.Vector3(1.,0.,0.);
        const B233 = new THREE.Vector3(0.,0.,0.058823529411764719);
        const C233 = new THREE.Vector3(0.,0.,0.049019607843137303);

        const normalVec233 = new THREE.Vector3();
        normalVec233.crossVectors(B233.sub(A233), C233.sub(A233));
        normalVec233.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal233 = new THREE.Vector3(0,0,1);

        const quaternionRotation233 = new THREE.Quaternion();
        quaternionRotation233.setFromUnitVectors(initialNormal233, normalVec233);

        ringMesh233.setRotationFromQuaternion(quaternionRotation233);

        return quaternionRotation233;
    }

    ringRoot.add(ringMesh233);
            
	var inradius234 = calulateInradius(getVertex113(), getVertex122(), getVertex123());
	var incenter234 = calulateIncenter(getVertex113(), getVertex122(), getVertex123());
	var ringGeometry234 = new THREE.RingGeometry((inradius234 - 0.005),inradius234, 32);
	const ringMaterial234 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh234 = new THREE.Mesh(ringGeometry234, ringMaterial234);

	function setCircleRotation234(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.9509803921568627],[0.,0.,0.94117647058823528]);

        ringMesh234.position.setX(incenter[0]);
        ringMesh234.position.setY(incenter[1]);
        ringMesh234.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex122(), getVertex123());
        var relRadius = inradius/inradius234;

        ringMesh234.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A234 = new THREE.Vector3(1.,0.,1.);
        const B234 = new THREE.Vector3(0.,0.,0.9509803921568627);
        const C234 = new THREE.Vector3(0.,0.,0.94117647058823528);

        const normalVec234 = new THREE.Vector3();
        normalVec234.crossVectors(B234.sub(A234), C234.sub(A234));
        normalVec234.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal234 = new THREE.Vector3(0,0,1);

        const quaternionRotation234 = new THREE.Quaternion();
        quaternionRotation234.setFromUnitVectors(initialNormal234, normalVec234);

        ringMesh234.setRotationFromQuaternion(quaternionRotation234);

        return quaternionRotation234;
    }

    ringRoot.add(ringMesh234);
            
	var inradius235 = calulateInradius(getVertex112(), getVertex212(), getVertex213());
	var incenter235 = calulateIncenter(getVertex112(), getVertex212(), getVertex213());
	var ringGeometry235 = new THREE.RingGeometry((inradius235 - 0.005),inradius235, 32);
	const ringMaterial235 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh235 = new THREE.Mesh(ringGeometry235, ringMaterial235);

	function setCircleRotation235(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.068627450980392135],[0.,0.,0.058823529411764719]);

        ringMesh235.position.setX(incenter[0]);
        ringMesh235.position.setY(incenter[1]);
        ringMesh235.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex212(), getVertex213());
        var relRadius = inradius/inradius235;

        ringMesh235.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A235 = new THREE.Vector3(1.,0.,0.);
        const B235 = new THREE.Vector3(0.,0.,0.068627450980392135);
        const C235 = new THREE.Vector3(0.,0.,0.058823529411764719);

        const normalVec235 = new THREE.Vector3();
        normalVec235.crossVectors(B235.sub(A235), C235.sub(A235));
        normalVec235.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal235 = new THREE.Vector3(0,0,1);

        const quaternionRotation235 = new THREE.Quaternion();
        quaternionRotation235.setFromUnitVectors(initialNormal235, normalVec235);

        ringMesh235.setRotationFromQuaternion(quaternionRotation235);

        return quaternionRotation235;
    }

    ringRoot.add(ringMesh235);
            
	var inradius236 = calulateInradius(getVertex113(), getVertex123(), getVertex124());
	var incenter236 = calulateIncenter(getVertex113(), getVertex123(), getVertex124());
	var ringGeometry236 = new THREE.RingGeometry((inradius236 - 0.005),inradius236, 32);
	const ringMaterial236 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh236 = new THREE.Mesh(ringGeometry236, ringMaterial236);

	function setCircleRotation236(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.94117647058823528],[0.,0.,0.93137254901960786]);

        ringMesh236.position.setX(incenter[0]);
        ringMesh236.position.setY(incenter[1]);
        ringMesh236.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex123(), getVertex124());
        var relRadius = inradius/inradius236;

        ringMesh236.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A236 = new THREE.Vector3(1.,0.,1.);
        const B236 = new THREE.Vector3(0.,0.,0.94117647058823528);
        const C236 = new THREE.Vector3(0.,0.,0.93137254901960786);

        const normalVec236 = new THREE.Vector3();
        normalVec236.crossVectors(B236.sub(A236), C236.sub(A236));
        normalVec236.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal236 = new THREE.Vector3(0,0,1);

        const quaternionRotation236 = new THREE.Quaternion();
        quaternionRotation236.setFromUnitVectors(initialNormal236, normalVec236);

        ringMesh236.setRotationFromQuaternion(quaternionRotation236);

        return quaternionRotation236;
    }

    ringRoot.add(ringMesh236);
            
	var inradius237 = calulateInradius(getVertex112(), getVertex211(), getVertex212());
	var incenter237 = calulateIncenter(getVertex112(), getVertex211(), getVertex212());
	var ringGeometry237 = new THREE.RingGeometry((inradius237 - 0.005),inradius237, 32);
	const ringMaterial237 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh237 = new THREE.Mesh(ringGeometry237, ringMaterial237);

	function setCircleRotation237(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.078431372549019662],[0.,0.,0.068627450980392135]);

        ringMesh237.position.setX(incenter[0]);
        ringMesh237.position.setY(incenter[1]);
        ringMesh237.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex211(), getVertex212());
        var relRadius = inradius/inradius237;

        ringMesh237.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A237 = new THREE.Vector3(1.,0.,0.);
        const B237 = new THREE.Vector3(0.,0.,0.078431372549019662);
        const C237 = new THREE.Vector3(0.,0.,0.068627450980392135);

        const normalVec237 = new THREE.Vector3();
        normalVec237.crossVectors(B237.sub(A237), C237.sub(A237));
        normalVec237.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal237 = new THREE.Vector3(0,0,1);

        const quaternionRotation237 = new THREE.Quaternion();
        quaternionRotation237.setFromUnitVectors(initialNormal237, normalVec237);

        ringMesh237.setRotationFromQuaternion(quaternionRotation237);

        return quaternionRotation237;
    }

    ringRoot.add(ringMesh237);
            
	var inradius238 = calulateInradius(getVertex113(), getVertex124(), getVertex125());
	var incenter238 = calulateIncenter(getVertex113(), getVertex124(), getVertex125());
	var ringGeometry238 = new THREE.RingGeometry((inradius238 - 0.005),inradius238, 32);
	const ringMaterial238 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh238 = new THREE.Mesh(ringGeometry238, ringMaterial238);

	function setCircleRotation238(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.93137254901960786],[0.,0.,0.92156862745098045]);

        ringMesh238.position.setX(incenter[0]);
        ringMesh238.position.setY(incenter[1]);
        ringMesh238.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex124(), getVertex125());
        var relRadius = inradius/inradius238;

        ringMesh238.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A238 = new THREE.Vector3(1.,0.,1.);
        const B238 = new THREE.Vector3(0.,0.,0.93137254901960786);
        const C238 = new THREE.Vector3(0.,0.,0.92156862745098045);

        const normalVec238 = new THREE.Vector3();
        normalVec238.crossVectors(B238.sub(A238), C238.sub(A238));
        normalVec238.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal238 = new THREE.Vector3(0,0,1);

        const quaternionRotation238 = new THREE.Quaternion();
        quaternionRotation238.setFromUnitVectors(initialNormal238, normalVec238);

        ringMesh238.setRotationFromQuaternion(quaternionRotation238);

        return quaternionRotation238;
    }

    ringRoot.add(ringMesh238);
            
	var inradius239 = calulateInradius(getVertex112(), getVertex210(), getVertex211());
	var incenter239 = calulateIncenter(getVertex112(), getVertex210(), getVertex211());
	var ringGeometry239 = new THREE.RingGeometry((inradius239 - 0.005),inradius239, 32);
	const ringMaterial239 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh239 = new THREE.Mesh(ringGeometry239, ringMaterial239);

	function setCircleRotation239(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.088235294117647078],[0.,0.,0.078431372549019662]);

        ringMesh239.position.setX(incenter[0]);
        ringMesh239.position.setY(incenter[1]);
        ringMesh239.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex210(), getVertex211());
        var relRadius = inradius/inradius239;

        ringMesh239.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A239 = new THREE.Vector3(1.,0.,0.);
        const B239 = new THREE.Vector3(0.,0.,0.088235294117647078);
        const C239 = new THREE.Vector3(0.,0.,0.078431372549019662);

        const normalVec239 = new THREE.Vector3();
        normalVec239.crossVectors(B239.sub(A239), C239.sub(A239));
        normalVec239.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal239 = new THREE.Vector3(0,0,1);

        const quaternionRotation239 = new THREE.Quaternion();
        quaternionRotation239.setFromUnitVectors(initialNormal239, normalVec239);

        ringMesh239.setRotationFromQuaternion(quaternionRotation239);

        return quaternionRotation239;
    }

    ringRoot.add(ringMesh239);
            
	var inradius240 = calulateInradius(getVertex113(), getVertex125(), getVertex126());
	var incenter240 = calulateIncenter(getVertex113(), getVertex125(), getVertex126());
	var ringGeometry240 = new THREE.RingGeometry((inradius240 - 0.005),inradius240, 32);
	const ringMaterial240 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh240 = new THREE.Mesh(ringGeometry240, ringMaterial240);

	function setCircleRotation240(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.92156862745098045],[0.,0.,0.91176470588235292]);

        ringMesh240.position.setX(incenter[0]);
        ringMesh240.position.setY(incenter[1]);
        ringMesh240.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex125(), getVertex126());
        var relRadius = inradius/inradius240;

        ringMesh240.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A240 = new THREE.Vector3(1.,0.,1.);
        const B240 = new THREE.Vector3(0.,0.,0.92156862745098045);
        const C240 = new THREE.Vector3(0.,0.,0.91176470588235292);

        const normalVec240 = new THREE.Vector3();
        normalVec240.crossVectors(B240.sub(A240), C240.sub(A240));
        normalVec240.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal240 = new THREE.Vector3(0,0,1);

        const quaternionRotation240 = new THREE.Quaternion();
        quaternionRotation240.setFromUnitVectors(initialNormal240, normalVec240);

        ringMesh240.setRotationFromQuaternion(quaternionRotation240);

        return quaternionRotation240;
    }

    ringRoot.add(ringMesh240);
            
	var inradius241 = calulateInradius(getVertex112(), getVertex209(), getVertex210());
	var incenter241 = calulateIncenter(getVertex112(), getVertex209(), getVertex210());
	var ringGeometry241 = new THREE.RingGeometry((inradius241 - 0.005),inradius241, 32);
	const ringMaterial241 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh241 = new THREE.Mesh(ringGeometry241, ringMaterial241);

	function setCircleRotation241(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.098039215686274495],[0.,0.,0.088235294117647078]);

        ringMesh241.position.setX(incenter[0]);
        ringMesh241.position.setY(incenter[1]);
        ringMesh241.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex209(), getVertex210());
        var relRadius = inradius/inradius241;

        ringMesh241.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A241 = new THREE.Vector3(1.,0.,0.);
        const B241 = new THREE.Vector3(0.,0.,0.098039215686274495);
        const C241 = new THREE.Vector3(0.,0.,0.088235294117647078);

        const normalVec241 = new THREE.Vector3();
        normalVec241.crossVectors(B241.sub(A241), C241.sub(A241));
        normalVec241.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal241 = new THREE.Vector3(0,0,1);

        const quaternionRotation241 = new THREE.Quaternion();
        quaternionRotation241.setFromUnitVectors(initialNormal241, normalVec241);

        ringMesh241.setRotationFromQuaternion(quaternionRotation241);

        return quaternionRotation241;
    }

    ringRoot.add(ringMesh241);
            
	var inradius242 = calulateInradius(getVertex113(), getVertex126(), getVertex127());
	var incenter242 = calulateIncenter(getVertex113(), getVertex126(), getVertex127());
	var ringGeometry242 = new THREE.RingGeometry((inradius242 - 0.005),inradius242, 32);
	const ringMaterial242 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh242 = new THREE.Mesh(ringGeometry242, ringMaterial242);

	function setCircleRotation242(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.91176470588235292],[0.,0.,0.90196078431372551]);

        ringMesh242.position.setX(incenter[0]);
        ringMesh242.position.setY(incenter[1]);
        ringMesh242.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex126(), getVertex127());
        var relRadius = inradius/inradius242;

        ringMesh242.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A242 = new THREE.Vector3(1.,0.,1.);
        const B242 = new THREE.Vector3(0.,0.,0.91176470588235292);
        const C242 = new THREE.Vector3(0.,0.,0.90196078431372551);

        const normalVec242 = new THREE.Vector3();
        normalVec242.crossVectors(B242.sub(A242), C242.sub(A242));
        normalVec242.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal242 = new THREE.Vector3(0,0,1);

        const quaternionRotation242 = new THREE.Quaternion();
        quaternionRotation242.setFromUnitVectors(initialNormal242, normalVec242);

        ringMesh242.setRotationFromQuaternion(quaternionRotation242);

        return quaternionRotation242;
    }

    ringRoot.add(ringMesh242);
            
	var inradius243 = calulateInradius(getVertex112(), getVertex208(), getVertex209());
	var incenter243 = calulateIncenter(getVertex112(), getVertex208(), getVertex209());
	var ringGeometry243 = new THREE.RingGeometry((inradius243 - 0.005),inradius243, 32);
	const ringMaterial243 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh243 = new THREE.Mesh(ringGeometry243, ringMaterial243);

	function setCircleRotation243(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.10784313725490202],[0.,0.,0.098039215686274495]);

        ringMesh243.position.setX(incenter[0]);
        ringMesh243.position.setY(incenter[1]);
        ringMesh243.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex208(), getVertex209());
        var relRadius = inradius/inradius243;

        ringMesh243.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A243 = new THREE.Vector3(1.,0.,0.);
        const B243 = new THREE.Vector3(0.,0.,0.10784313725490202);
        const C243 = new THREE.Vector3(0.,0.,0.098039215686274495);

        const normalVec243 = new THREE.Vector3();
        normalVec243.crossVectors(B243.sub(A243), C243.sub(A243));
        normalVec243.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal243 = new THREE.Vector3(0,0,1);

        const quaternionRotation243 = new THREE.Quaternion();
        quaternionRotation243.setFromUnitVectors(initialNormal243, normalVec243);

        ringMesh243.setRotationFromQuaternion(quaternionRotation243);

        return quaternionRotation243;
    }

    ringRoot.add(ringMesh243);
            
	var inradius244 = calulateInradius(getVertex113(), getVertex127(), getVertex128());
	var incenter244 = calulateIncenter(getVertex113(), getVertex127(), getVertex128());
	var ringGeometry244 = new THREE.RingGeometry((inradius244 - 0.005),inradius244, 32);
	const ringMaterial244 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh244 = new THREE.Mesh(ringGeometry244, ringMaterial244);

	function setCircleRotation244(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.90196078431372551],[0.,0.,0.89215686274509798]);

        ringMesh244.position.setX(incenter[0]);
        ringMesh244.position.setY(incenter[1]);
        ringMesh244.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex127(), getVertex128());
        var relRadius = inradius/inradius244;

        ringMesh244.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A244 = new THREE.Vector3(1.,0.,1.);
        const B244 = new THREE.Vector3(0.,0.,0.90196078431372551);
        const C244 = new THREE.Vector3(0.,0.,0.89215686274509798);

        const normalVec244 = new THREE.Vector3();
        normalVec244.crossVectors(B244.sub(A244), C244.sub(A244));
        normalVec244.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal244 = new THREE.Vector3(0,0,1);

        const quaternionRotation244 = new THREE.Quaternion();
        quaternionRotation244.setFromUnitVectors(initialNormal244, normalVec244);

        ringMesh244.setRotationFromQuaternion(quaternionRotation244);

        return quaternionRotation244;
    }

    ringRoot.add(ringMesh244);
            
	var inradius245 = calulateInradius(getVertex112(), getVertex207(), getVertex208());
	var incenter245 = calulateIncenter(getVertex112(), getVertex207(), getVertex208());
	var ringGeometry245 = new THREE.RingGeometry((inradius245 - 0.005),inradius245, 32);
	const ringMaterial245 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh245 = new THREE.Mesh(ringGeometry245, ringMaterial245);

	function setCircleRotation245(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.11764705882352944],[0.,0.,0.10784313725490202]);

        ringMesh245.position.setX(incenter[0]);
        ringMesh245.position.setY(incenter[1]);
        ringMesh245.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex207(), getVertex208());
        var relRadius = inradius/inradius245;

        ringMesh245.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A245 = new THREE.Vector3(1.,0.,0.);
        const B245 = new THREE.Vector3(0.,0.,0.11764705882352944);
        const C245 = new THREE.Vector3(0.,0.,0.10784313725490202);

        const normalVec245 = new THREE.Vector3();
        normalVec245.crossVectors(B245.sub(A245), C245.sub(A245));
        normalVec245.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal245 = new THREE.Vector3(0,0,1);

        const quaternionRotation245 = new THREE.Quaternion();
        quaternionRotation245.setFromUnitVectors(initialNormal245, normalVec245);

        ringMesh245.setRotationFromQuaternion(quaternionRotation245);

        return quaternionRotation245;
    }

    ringRoot.add(ringMesh245);
            
	var inradius246 = calulateInradius(getVertex113(), getVertex128(), getVertex129());
	var incenter246 = calulateIncenter(getVertex113(), getVertex128(), getVertex129());
	var ringGeometry246 = new THREE.RingGeometry((inradius246 - 0.005),inradius246, 32);
	const ringMaterial246 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh246 = new THREE.Mesh(ringGeometry246, ringMaterial246);

	function setCircleRotation246(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.89215686274509798],[0.,0.,0.88235294117647056]);

        ringMesh246.position.setX(incenter[0]);
        ringMesh246.position.setY(incenter[1]);
        ringMesh246.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex128(), getVertex129());
        var relRadius = inradius/inradius246;

        ringMesh246.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A246 = new THREE.Vector3(1.,0.,1.);
        const B246 = new THREE.Vector3(0.,0.,0.89215686274509798);
        const C246 = new THREE.Vector3(0.,0.,0.88235294117647056);

        const normalVec246 = new THREE.Vector3();
        normalVec246.crossVectors(B246.sub(A246), C246.sub(A246));
        normalVec246.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal246 = new THREE.Vector3(0,0,1);

        const quaternionRotation246 = new THREE.Quaternion();
        quaternionRotation246.setFromUnitVectors(initialNormal246, normalVec246);

        ringMesh246.setRotationFromQuaternion(quaternionRotation246);

        return quaternionRotation246;
    }

    ringRoot.add(ringMesh246);
            
	var inradius247 = calulateInradius(getVertex112(), getVertex206(), getVertex207());
	var incenter247 = calulateIncenter(getVertex112(), getVertex206(), getVertex207());
	var ringGeometry247 = new THREE.RingGeometry((inradius247 - 0.005),inradius247, 32);
	const ringMaterial247 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh247 = new THREE.Mesh(ringGeometry247, ringMaterial247);

	function setCircleRotation247(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.12745098039215685],[0.,0.,0.11764705882352944]);

        ringMesh247.position.setX(incenter[0]);
        ringMesh247.position.setY(incenter[1]);
        ringMesh247.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex206(), getVertex207());
        var relRadius = inradius/inradius247;

        ringMesh247.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A247 = new THREE.Vector3(1.,0.,0.);
        const B247 = new THREE.Vector3(0.,0.,0.12745098039215685);
        const C247 = new THREE.Vector3(0.,0.,0.11764705882352944);

        const normalVec247 = new THREE.Vector3();
        normalVec247.crossVectors(B247.sub(A247), C247.sub(A247));
        normalVec247.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal247 = new THREE.Vector3(0,0,1);

        const quaternionRotation247 = new THREE.Quaternion();
        quaternionRotation247.setFromUnitVectors(initialNormal247, normalVec247);

        ringMesh247.setRotationFromQuaternion(quaternionRotation247);

        return quaternionRotation247;
    }

    ringRoot.add(ringMesh247);
            
	var inradius248 = calulateInradius(getVertex113(), getVertex129(), getVertex130());
	var incenter248 = calulateIncenter(getVertex113(), getVertex129(), getVertex130());
	var ringGeometry248 = new THREE.RingGeometry((inradius248 - 0.005),inradius248, 32);
	const ringMaterial248 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh248 = new THREE.Mesh(ringGeometry248, ringMaterial248);

	function setCircleRotation248(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.88235294117647056],[0.,0.,0.87254901960784315]);

        ringMesh248.position.setX(incenter[0]);
        ringMesh248.position.setY(incenter[1]);
        ringMesh248.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex129(), getVertex130());
        var relRadius = inradius/inradius248;

        ringMesh248.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A248 = new THREE.Vector3(1.,0.,1.);
        const B248 = new THREE.Vector3(0.,0.,0.88235294117647056);
        const C248 = new THREE.Vector3(0.,0.,0.87254901960784315);

        const normalVec248 = new THREE.Vector3();
        normalVec248.crossVectors(B248.sub(A248), C248.sub(A248));
        normalVec248.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal248 = new THREE.Vector3(0,0,1);

        const quaternionRotation248 = new THREE.Quaternion();
        quaternionRotation248.setFromUnitVectors(initialNormal248, normalVec248);

        ringMesh248.setRotationFromQuaternion(quaternionRotation248);

        return quaternionRotation248;
    }

    ringRoot.add(ringMesh248);
            
	var inradius249 = calulateInradius(getVertex112(), getVertex205(), getVertex206());
	var incenter249 = calulateIncenter(getVertex112(), getVertex205(), getVertex206());
	var ringGeometry249 = new THREE.RingGeometry((inradius249 - 0.005),inradius249, 32);
	const ringMaterial249 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh249 = new THREE.Mesh(ringGeometry249, ringMaterial249);

	function setCircleRotation249(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.13725490196078427],[0.,0.,0.12745098039215685]);

        ringMesh249.position.setX(incenter[0]);
        ringMesh249.position.setY(incenter[1]);
        ringMesh249.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex205(), getVertex206());
        var relRadius = inradius/inradius249;

        ringMesh249.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A249 = new THREE.Vector3(1.,0.,0.);
        const B249 = new THREE.Vector3(0.,0.,0.13725490196078427);
        const C249 = new THREE.Vector3(0.,0.,0.12745098039215685);

        const normalVec249 = new THREE.Vector3();
        normalVec249.crossVectors(B249.sub(A249), C249.sub(A249));
        normalVec249.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal249 = new THREE.Vector3(0,0,1);

        const quaternionRotation249 = new THREE.Quaternion();
        quaternionRotation249.setFromUnitVectors(initialNormal249, normalVec249);

        ringMesh249.setRotationFromQuaternion(quaternionRotation249);

        return quaternionRotation249;
    }

    ringRoot.add(ringMesh249);
            
	var inradius250 = calulateInradius(getVertex113(), getVertex130(), getVertex131());
	var incenter250 = calulateIncenter(getVertex113(), getVertex130(), getVertex131());
	var ringGeometry250 = new THREE.RingGeometry((inradius250 - 0.005),inradius250, 32);
	const ringMaterial250 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh250 = new THREE.Mesh(ringGeometry250, ringMaterial250);

	function setCircleRotation250(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.87254901960784315],[0.,0.,0.86274509803921573]);

        ringMesh250.position.setX(incenter[0]);
        ringMesh250.position.setY(incenter[1]);
        ringMesh250.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex130(), getVertex131());
        var relRadius = inradius/inradius250;

        ringMesh250.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A250 = new THREE.Vector3(1.,0.,1.);
        const B250 = new THREE.Vector3(0.,0.,0.87254901960784315);
        const C250 = new THREE.Vector3(0.,0.,0.86274509803921573);

        const normalVec250 = new THREE.Vector3();
        normalVec250.crossVectors(B250.sub(A250), C250.sub(A250));
        normalVec250.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal250 = new THREE.Vector3(0,0,1);

        const quaternionRotation250 = new THREE.Quaternion();
        quaternionRotation250.setFromUnitVectors(initialNormal250, normalVec250);

        ringMesh250.setRotationFromQuaternion(quaternionRotation250);

        return quaternionRotation250;
    }

    ringRoot.add(ringMesh250);
            
	var inradius251 = calulateInradius(getVertex112(), getVertex204(), getVertex205());
	var incenter251 = calulateIncenter(getVertex112(), getVertex204(), getVertex205());
	var ringGeometry251 = new THREE.RingGeometry((inradius251 - 0.005),inradius251, 32);
	const ringMaterial251 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh251 = new THREE.Mesh(ringGeometry251, ringMaterial251);

	function setCircleRotation251(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.1470588235294118],[0.,0.,0.13725490196078427]);

        ringMesh251.position.setX(incenter[0]);
        ringMesh251.position.setY(incenter[1]);
        ringMesh251.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex204(), getVertex205());
        var relRadius = inradius/inradius251;

        ringMesh251.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A251 = new THREE.Vector3(1.,0.,0.);
        const B251 = new THREE.Vector3(0.,0.,0.1470588235294118);
        const C251 = new THREE.Vector3(0.,0.,0.13725490196078427);

        const normalVec251 = new THREE.Vector3();
        normalVec251.crossVectors(B251.sub(A251), C251.sub(A251));
        normalVec251.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal251 = new THREE.Vector3(0,0,1);

        const quaternionRotation251 = new THREE.Quaternion();
        quaternionRotation251.setFromUnitVectors(initialNormal251, normalVec251);

        ringMesh251.setRotationFromQuaternion(quaternionRotation251);

        return quaternionRotation251;
    }

    ringRoot.add(ringMesh251);
            
	var inradius252 = calulateInradius(getVertex113(), getVertex131(), getVertex132());
	var incenter252 = calulateIncenter(getVertex113(), getVertex131(), getVertex132());
	var ringGeometry252 = new THREE.RingGeometry((inradius252 - 0.005),inradius252, 32);
	const ringMaterial252 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh252 = new THREE.Mesh(ringGeometry252, ringMaterial252);

	function setCircleRotation252(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.86274509803921573],[0.,0.,0.8529411764705882]);

        ringMesh252.position.setX(incenter[0]);
        ringMesh252.position.setY(incenter[1]);
        ringMesh252.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex131(), getVertex132());
        var relRadius = inradius/inradius252;

        ringMesh252.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A252 = new THREE.Vector3(1.,0.,1.);
        const B252 = new THREE.Vector3(0.,0.,0.86274509803921573);
        const C252 = new THREE.Vector3(0.,0.,0.8529411764705882);

        const normalVec252 = new THREE.Vector3();
        normalVec252.crossVectors(B252.sub(A252), C252.sub(A252));
        normalVec252.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal252 = new THREE.Vector3(0,0,1);

        const quaternionRotation252 = new THREE.Quaternion();
        quaternionRotation252.setFromUnitVectors(initialNormal252, normalVec252);

        ringMesh252.setRotationFromQuaternion(quaternionRotation252);

        return quaternionRotation252;
    }

    ringRoot.add(ringMesh252);
            
	var inradius253 = calulateInradius(getVertex112(), getVertex203(), getVertex204());
	var incenter253 = calulateIncenter(getVertex112(), getVertex203(), getVertex204());
	var ringGeometry253 = new THREE.RingGeometry((inradius253 - 0.005),inradius253, 32);
	const ringMaterial253 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh253 = new THREE.Mesh(ringGeometry253, ringMaterial253);

	function setCircleRotation253(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.15686274509803921],[0.,0.,0.1470588235294118]);

        ringMesh253.position.setX(incenter[0]);
        ringMesh253.position.setY(incenter[1]);
        ringMesh253.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex203(), getVertex204());
        var relRadius = inradius/inradius253;

        ringMesh253.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A253 = new THREE.Vector3(1.,0.,0.);
        const B253 = new THREE.Vector3(0.,0.,0.15686274509803921);
        const C253 = new THREE.Vector3(0.,0.,0.1470588235294118);

        const normalVec253 = new THREE.Vector3();
        normalVec253.crossVectors(B253.sub(A253), C253.sub(A253));
        normalVec253.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal253 = new THREE.Vector3(0,0,1);

        const quaternionRotation253 = new THREE.Quaternion();
        quaternionRotation253.setFromUnitVectors(initialNormal253, normalVec253);

        ringMesh253.setRotationFromQuaternion(quaternionRotation253);

        return quaternionRotation253;
    }

    ringRoot.add(ringMesh253);
            
	var inradius254 = calulateInradius(getVertex113(), getVertex132(), getVertex133());
	var incenter254 = calulateIncenter(getVertex113(), getVertex132(), getVertex133());
	var ringGeometry254 = new THREE.RingGeometry((inradius254 - 0.005),inradius254, 32);
	const ringMaterial254 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh254 = new THREE.Mesh(ringGeometry254, ringMaterial254);

	function setCircleRotation254(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.8529411764705882],[0.,0.,0.84313725490196079]);

        ringMesh254.position.setX(incenter[0]);
        ringMesh254.position.setY(incenter[1]);
        ringMesh254.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex132(), getVertex133());
        var relRadius = inradius/inradius254;

        ringMesh254.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A254 = new THREE.Vector3(1.,0.,1.);
        const B254 = new THREE.Vector3(0.,0.,0.8529411764705882);
        const C254 = new THREE.Vector3(0.,0.,0.84313725490196079);

        const normalVec254 = new THREE.Vector3();
        normalVec254.crossVectors(B254.sub(A254), C254.sub(A254));
        normalVec254.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal254 = new THREE.Vector3(0,0,1);

        const quaternionRotation254 = new THREE.Quaternion();
        quaternionRotation254.setFromUnitVectors(initialNormal254, normalVec254);

        ringMesh254.setRotationFromQuaternion(quaternionRotation254);

        return quaternionRotation254;
    }

    ringRoot.add(ringMesh254);
            
	var inradius255 = calulateInradius(getVertex112(), getVertex202(), getVertex203());
	var incenter255 = calulateIncenter(getVertex112(), getVertex202(), getVertex203());
	var ringGeometry255 = new THREE.RingGeometry((inradius255 - 0.005),inradius255, 32);
	const ringMaterial255 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh255 = new THREE.Mesh(ringGeometry255, ringMaterial255);

	function setCircleRotation255(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.16666666666666663],[0.,0.,0.15686274509803921]);

        ringMesh255.position.setX(incenter[0]);
        ringMesh255.position.setY(incenter[1]);
        ringMesh255.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex202(), getVertex203());
        var relRadius = inradius/inradius255;

        ringMesh255.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A255 = new THREE.Vector3(1.,0.,0.);
        const B255 = new THREE.Vector3(0.,0.,0.16666666666666663);
        const C255 = new THREE.Vector3(0.,0.,0.15686274509803921);

        const normalVec255 = new THREE.Vector3();
        normalVec255.crossVectors(B255.sub(A255), C255.sub(A255));
        normalVec255.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal255 = new THREE.Vector3(0,0,1);

        const quaternionRotation255 = new THREE.Quaternion();
        quaternionRotation255.setFromUnitVectors(initialNormal255, normalVec255);

        ringMesh255.setRotationFromQuaternion(quaternionRotation255);

        return quaternionRotation255;
    }

    ringRoot.add(ringMesh255);
            
	var inradius256 = calulateInradius(getVertex113(), getVertex133(), getVertex134());
	var incenter256 = calulateIncenter(getVertex113(), getVertex133(), getVertex134());
	var ringGeometry256 = new THREE.RingGeometry((inradius256 - 0.005),inradius256, 32);
	const ringMaterial256 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh256 = new THREE.Mesh(ringGeometry256, ringMaterial256);

	function setCircleRotation256(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.84313725490196079],[0.,0.,0.83333333333333337]);

        ringMesh256.position.setX(incenter[0]);
        ringMesh256.position.setY(incenter[1]);
        ringMesh256.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex133(), getVertex134());
        var relRadius = inradius/inradius256;

        ringMesh256.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A256 = new THREE.Vector3(1.,0.,1.);
        const B256 = new THREE.Vector3(0.,0.,0.84313725490196079);
        const C256 = new THREE.Vector3(0.,0.,0.83333333333333337);

        const normalVec256 = new THREE.Vector3();
        normalVec256.crossVectors(B256.sub(A256), C256.sub(A256));
        normalVec256.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal256 = new THREE.Vector3(0,0,1);

        const quaternionRotation256 = new THREE.Quaternion();
        quaternionRotation256.setFromUnitVectors(initialNormal256, normalVec256);

        ringMesh256.setRotationFromQuaternion(quaternionRotation256);

        return quaternionRotation256;
    }

    ringRoot.add(ringMesh256);
            
	var inradius257 = calulateInradius(getVertex112(), getVertex201(), getVertex202());
	var incenter257 = calulateIncenter(getVertex112(), getVertex201(), getVertex202());
	var ringGeometry257 = new THREE.RingGeometry((inradius257 - 0.005),inradius257, 32);
	const ringMaterial257 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh257 = new THREE.Mesh(ringGeometry257, ringMaterial257);

	function setCircleRotation257(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.17647058823529416],[0.,0.,0.16666666666666663]);

        ringMesh257.position.setX(incenter[0]);
        ringMesh257.position.setY(incenter[1]);
        ringMesh257.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex201(), getVertex202());
        var relRadius = inradius/inradius257;

        ringMesh257.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A257 = new THREE.Vector3(1.,0.,0.);
        const B257 = new THREE.Vector3(0.,0.,0.17647058823529416);
        const C257 = new THREE.Vector3(0.,0.,0.16666666666666663);

        const normalVec257 = new THREE.Vector3();
        normalVec257.crossVectors(B257.sub(A257), C257.sub(A257));
        normalVec257.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal257 = new THREE.Vector3(0,0,1);

        const quaternionRotation257 = new THREE.Quaternion();
        quaternionRotation257.setFromUnitVectors(initialNormal257, normalVec257);

        ringMesh257.setRotationFromQuaternion(quaternionRotation257);

        return quaternionRotation257;
    }

    ringRoot.add(ringMesh257);
            
	var inradius258 = calulateInradius(getVertex113(), getVertex134(), getVertex135());
	var incenter258 = calulateIncenter(getVertex113(), getVertex134(), getVertex135());
	var ringGeometry258 = new THREE.RingGeometry((inradius258 - 0.005),inradius258, 32);
	const ringMaterial258 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh258 = new THREE.Mesh(ringGeometry258, ringMaterial258);

	function setCircleRotation258(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.83333333333333337],[0.,0.,0.82352941176470584]);

        ringMesh258.position.setX(incenter[0]);
        ringMesh258.position.setY(incenter[1]);
        ringMesh258.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex134(), getVertex135());
        var relRadius = inradius/inradius258;

        ringMesh258.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A258 = new THREE.Vector3(1.,0.,1.);
        const B258 = new THREE.Vector3(0.,0.,0.83333333333333337);
        const C258 = new THREE.Vector3(0.,0.,0.82352941176470584);

        const normalVec258 = new THREE.Vector3();
        normalVec258.crossVectors(B258.sub(A258), C258.sub(A258));
        normalVec258.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal258 = new THREE.Vector3(0,0,1);

        const quaternionRotation258 = new THREE.Quaternion();
        quaternionRotation258.setFromUnitVectors(initialNormal258, normalVec258);

        ringMesh258.setRotationFromQuaternion(quaternionRotation258);

        return quaternionRotation258;
    }

    ringRoot.add(ringMesh258);
            
	var inradius259 = calulateInradius(getVertex112(), getVertex200(), getVertex201());
	var incenter259 = calulateIncenter(getVertex112(), getVertex200(), getVertex201());
	var ringGeometry259 = new THREE.RingGeometry((inradius259 - 0.005),inradius259, 32);
	const ringMaterial259 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh259 = new THREE.Mesh(ringGeometry259, ringMaterial259);

	function setCircleRotation259(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.18627450980392157],[0.,0.,0.17647058823529416]);

        ringMesh259.position.setX(incenter[0]);
        ringMesh259.position.setY(incenter[1]);
        ringMesh259.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex200(), getVertex201());
        var relRadius = inradius/inradius259;

        ringMesh259.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A259 = new THREE.Vector3(1.,0.,0.);
        const B259 = new THREE.Vector3(0.,0.,0.18627450980392157);
        const C259 = new THREE.Vector3(0.,0.,0.17647058823529416);

        const normalVec259 = new THREE.Vector3();
        normalVec259.crossVectors(B259.sub(A259), C259.sub(A259));
        normalVec259.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal259 = new THREE.Vector3(0,0,1);

        const quaternionRotation259 = new THREE.Quaternion();
        quaternionRotation259.setFromUnitVectors(initialNormal259, normalVec259);

        ringMesh259.setRotationFromQuaternion(quaternionRotation259);

        return quaternionRotation259;
    }

    ringRoot.add(ringMesh259);
            
	var inradius260 = calulateInradius(getVertex113(), getVertex135(), getVertex136());
	var incenter260 = calulateIncenter(getVertex113(), getVertex135(), getVertex136());
	var ringGeometry260 = new THREE.RingGeometry((inradius260 - 0.005),inradius260, 32);
	const ringMaterial260 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh260 = new THREE.Mesh(ringGeometry260, ringMaterial260);

	function setCircleRotation260(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.82352941176470584],[0.,0.,0.81372549019607843]);

        ringMesh260.position.setX(incenter[0]);
        ringMesh260.position.setY(incenter[1]);
        ringMesh260.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex135(), getVertex136());
        var relRadius = inradius/inradius260;

        ringMesh260.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A260 = new THREE.Vector3(1.,0.,1.);
        const B260 = new THREE.Vector3(0.,0.,0.82352941176470584);
        const C260 = new THREE.Vector3(0.,0.,0.81372549019607843);

        const normalVec260 = new THREE.Vector3();
        normalVec260.crossVectors(B260.sub(A260), C260.sub(A260));
        normalVec260.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal260 = new THREE.Vector3(0,0,1);

        const quaternionRotation260 = new THREE.Quaternion();
        quaternionRotation260.setFromUnitVectors(initialNormal260, normalVec260);

        ringMesh260.setRotationFromQuaternion(quaternionRotation260);

        return quaternionRotation260;
    }

    ringRoot.add(ringMesh260);
            
	var inradius261 = calulateInradius(getVertex112(), getVertex199(), getVertex200());
	var incenter261 = calulateIncenter(getVertex112(), getVertex199(), getVertex200());
	var ringGeometry261 = new THREE.RingGeometry((inradius261 - 0.005),inradius261, 32);
	const ringMaterial261 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh261 = new THREE.Mesh(ringGeometry261, ringMaterial261);

	function setCircleRotation261(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.19607843137254899],[0.,0.,0.18627450980392157]);

        ringMesh261.position.setX(incenter[0]);
        ringMesh261.position.setY(incenter[1]);
        ringMesh261.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex199(), getVertex200());
        var relRadius = inradius/inradius261;

        ringMesh261.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A261 = new THREE.Vector3(1.,0.,0.);
        const B261 = new THREE.Vector3(0.,0.,0.19607843137254899);
        const C261 = new THREE.Vector3(0.,0.,0.18627450980392157);

        const normalVec261 = new THREE.Vector3();
        normalVec261.crossVectors(B261.sub(A261), C261.sub(A261));
        normalVec261.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal261 = new THREE.Vector3(0,0,1);

        const quaternionRotation261 = new THREE.Quaternion();
        quaternionRotation261.setFromUnitVectors(initialNormal261, normalVec261);

        ringMesh261.setRotationFromQuaternion(quaternionRotation261);

        return quaternionRotation261;
    }

    ringRoot.add(ringMesh261);
            
	var inradius262 = calulateInradius(getVertex113(), getVertex136(), getVertex137());
	var incenter262 = calulateIncenter(getVertex113(), getVertex136(), getVertex137());
	var ringGeometry262 = new THREE.RingGeometry((inradius262 - 0.005),inradius262, 32);
	const ringMaterial262 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh262 = new THREE.Mesh(ringGeometry262, ringMaterial262);

	function setCircleRotation262(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.81372549019607843],[0.,0.,0.80392156862745101]);

        ringMesh262.position.setX(incenter[0]);
        ringMesh262.position.setY(incenter[1]);
        ringMesh262.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex136(), getVertex137());
        var relRadius = inradius/inradius262;

        ringMesh262.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A262 = new THREE.Vector3(1.,0.,1.);
        const B262 = new THREE.Vector3(0.,0.,0.81372549019607843);
        const C262 = new THREE.Vector3(0.,0.,0.80392156862745101);

        const normalVec262 = new THREE.Vector3();
        normalVec262.crossVectors(B262.sub(A262), C262.sub(A262));
        normalVec262.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal262 = new THREE.Vector3(0,0,1);

        const quaternionRotation262 = new THREE.Quaternion();
        quaternionRotation262.setFromUnitVectors(initialNormal262, normalVec262);

        ringMesh262.setRotationFromQuaternion(quaternionRotation262);

        return quaternionRotation262;
    }

    ringRoot.add(ringMesh262);
            
	var inradius263 = calulateInradius(getVertex112(), getVertex198(), getVertex199());
	var incenter263 = calulateIncenter(getVertex112(), getVertex198(), getVertex199());
	var ringGeometry263 = new THREE.RingGeometry((inradius263 - 0.005),inradius263, 32);
	const ringMaterial263 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh263 = new THREE.Mesh(ringGeometry263, ringMaterial263);

	function setCircleRotation263(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.20588235294117652],[0.,0.,0.19607843137254899]);

        ringMesh263.position.setX(incenter[0]);
        ringMesh263.position.setY(incenter[1]);
        ringMesh263.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex198(), getVertex199());
        var relRadius = inradius/inradius263;

        ringMesh263.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A263 = new THREE.Vector3(1.,0.,0.);
        const B263 = new THREE.Vector3(0.,0.,0.20588235294117652);
        const C263 = new THREE.Vector3(0.,0.,0.19607843137254899);

        const normalVec263 = new THREE.Vector3();
        normalVec263.crossVectors(B263.sub(A263), C263.sub(A263));
        normalVec263.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal263 = new THREE.Vector3(0,0,1);

        const quaternionRotation263 = new THREE.Quaternion();
        quaternionRotation263.setFromUnitVectors(initialNormal263, normalVec263);

        ringMesh263.setRotationFromQuaternion(quaternionRotation263);

        return quaternionRotation263;
    }

    ringRoot.add(ringMesh263);
            
	var inradius264 = calulateInradius(getVertex113(), getVertex137(), getVertex138());
	var incenter264 = calulateIncenter(getVertex113(), getVertex137(), getVertex138());
	var ringGeometry264 = new THREE.RingGeometry((inradius264 - 0.005),inradius264, 32);
	const ringMaterial264 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh264 = new THREE.Mesh(ringGeometry264, ringMaterial264);

	function setCircleRotation264(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.80392156862745101],[0.,0.,0.79411764705882359]);

        ringMesh264.position.setX(incenter[0]);
        ringMesh264.position.setY(incenter[1]);
        ringMesh264.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex137(), getVertex138());
        var relRadius = inradius/inradius264;

        ringMesh264.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A264 = new THREE.Vector3(1.,0.,1.);
        const B264 = new THREE.Vector3(0.,0.,0.80392156862745101);
        const C264 = new THREE.Vector3(0.,0.,0.79411764705882359);

        const normalVec264 = new THREE.Vector3();
        normalVec264.crossVectors(B264.sub(A264), C264.sub(A264));
        normalVec264.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal264 = new THREE.Vector3(0,0,1);

        const quaternionRotation264 = new THREE.Quaternion();
        quaternionRotation264.setFromUnitVectors(initialNormal264, normalVec264);

        ringMesh264.setRotationFromQuaternion(quaternionRotation264);

        return quaternionRotation264;
    }

    ringRoot.add(ringMesh264);
            
	var inradius265 = calulateInradius(getVertex112(), getVertex197(), getVertex198());
	var incenter265 = calulateIncenter(getVertex112(), getVertex197(), getVertex198());
	var ringGeometry265 = new THREE.RingGeometry((inradius265 - 0.005),inradius265, 32);
	const ringMaterial265 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh265 = new THREE.Mesh(ringGeometry265, ringMaterial265);

	function setCircleRotation265(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.21568627450980393],[0.,0.,0.20588235294117652]);

        ringMesh265.position.setX(incenter[0]);
        ringMesh265.position.setY(incenter[1]);
        ringMesh265.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex197(), getVertex198());
        var relRadius = inradius/inradius265;

        ringMesh265.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A265 = new THREE.Vector3(1.,0.,0.);
        const B265 = new THREE.Vector3(0.,0.,0.21568627450980393);
        const C265 = new THREE.Vector3(0.,0.,0.20588235294117652);

        const normalVec265 = new THREE.Vector3();
        normalVec265.crossVectors(B265.sub(A265), C265.sub(A265));
        normalVec265.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal265 = new THREE.Vector3(0,0,1);

        const quaternionRotation265 = new THREE.Quaternion();
        quaternionRotation265.setFromUnitVectors(initialNormal265, normalVec265);

        ringMesh265.setRotationFromQuaternion(quaternionRotation265);

        return quaternionRotation265;
    }

    ringRoot.add(ringMesh265);
            
	var inradius266 = calulateInradius(getVertex113(), getVertex138(), getVertex139());
	var incenter266 = calulateIncenter(getVertex113(), getVertex138(), getVertex139());
	var ringGeometry266 = new THREE.RingGeometry((inradius266 - 0.005),inradius266, 32);
	const ringMaterial266 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh266 = new THREE.Mesh(ringGeometry266, ringMaterial266);

	function setCircleRotation266(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.79411764705882359],[0.,0.,0.78431372549019607]);

        ringMesh266.position.setX(incenter[0]);
        ringMesh266.position.setY(incenter[1]);
        ringMesh266.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex138(), getVertex139());
        var relRadius = inradius/inradius266;

        ringMesh266.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A266 = new THREE.Vector3(1.,0.,1.);
        const B266 = new THREE.Vector3(0.,0.,0.79411764705882359);
        const C266 = new THREE.Vector3(0.,0.,0.78431372549019607);

        const normalVec266 = new THREE.Vector3();
        normalVec266.crossVectors(B266.sub(A266), C266.sub(A266));
        normalVec266.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal266 = new THREE.Vector3(0,0,1);

        const quaternionRotation266 = new THREE.Quaternion();
        quaternionRotation266.setFromUnitVectors(initialNormal266, normalVec266);

        ringMesh266.setRotationFromQuaternion(quaternionRotation266);

        return quaternionRotation266;
    }

    ringRoot.add(ringMesh266);
            
	var inradius267 = calulateInradius(getVertex112(), getVertex196(), getVertex197());
	var incenter267 = calulateIncenter(getVertex112(), getVertex196(), getVertex197());
	var ringGeometry267 = new THREE.RingGeometry((inradius267 - 0.005),inradius267, 32);
	const ringMaterial267 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh267 = new THREE.Mesh(ringGeometry267, ringMaterial267);

	function setCircleRotation267(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.22549019607843135],[0.,0.,0.21568627450980393]);

        ringMesh267.position.setX(incenter[0]);
        ringMesh267.position.setY(incenter[1]);
        ringMesh267.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex196(), getVertex197());
        var relRadius = inradius/inradius267;

        ringMesh267.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A267 = new THREE.Vector3(1.,0.,0.);
        const B267 = new THREE.Vector3(0.,0.,0.22549019607843135);
        const C267 = new THREE.Vector3(0.,0.,0.21568627450980393);

        const normalVec267 = new THREE.Vector3();
        normalVec267.crossVectors(B267.sub(A267), C267.sub(A267));
        normalVec267.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal267 = new THREE.Vector3(0,0,1);

        const quaternionRotation267 = new THREE.Quaternion();
        quaternionRotation267.setFromUnitVectors(initialNormal267, normalVec267);

        ringMesh267.setRotationFromQuaternion(quaternionRotation267);

        return quaternionRotation267;
    }

    ringRoot.add(ringMesh267);
            
	var inradius268 = calulateInradius(getVertex113(), getVertex139(), getVertex140());
	var incenter268 = calulateIncenter(getVertex113(), getVertex139(), getVertex140());
	var ringGeometry268 = new THREE.RingGeometry((inradius268 - 0.005),inradius268, 32);
	const ringMaterial268 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh268 = new THREE.Mesh(ringGeometry268, ringMaterial268);

	function setCircleRotation268(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.78431372549019607],[0.,0.,0.77450980392156865]);

        ringMesh268.position.setX(incenter[0]);
        ringMesh268.position.setY(incenter[1]);
        ringMesh268.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex139(), getVertex140());
        var relRadius = inradius/inradius268;

        ringMesh268.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A268 = new THREE.Vector3(1.,0.,1.);
        const B268 = new THREE.Vector3(0.,0.,0.78431372549019607);
        const C268 = new THREE.Vector3(0.,0.,0.77450980392156865);

        const normalVec268 = new THREE.Vector3();
        normalVec268.crossVectors(B268.sub(A268), C268.sub(A268));
        normalVec268.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal268 = new THREE.Vector3(0,0,1);

        const quaternionRotation268 = new THREE.Quaternion();
        quaternionRotation268.setFromUnitVectors(initialNormal268, normalVec268);

        ringMesh268.setRotationFromQuaternion(quaternionRotation268);

        return quaternionRotation268;
    }

    ringRoot.add(ringMesh268);
            
	var inradius269 = calulateInradius(getVertex112(), getVertex195(), getVertex196());
	var incenter269 = calulateIncenter(getVertex112(), getVertex195(), getVertex196());
	var ringGeometry269 = new THREE.RingGeometry((inradius269 - 0.005),inradius269, 32);
	const ringMaterial269 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh269 = new THREE.Mesh(ringGeometry269, ringMaterial269);

	function setCircleRotation269(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.23529411764705888],[0.,0.,0.22549019607843135]);

        ringMesh269.position.setX(incenter[0]);
        ringMesh269.position.setY(incenter[1]);
        ringMesh269.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex195(), getVertex196());
        var relRadius = inradius/inradius269;

        ringMesh269.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A269 = new THREE.Vector3(1.,0.,0.);
        const B269 = new THREE.Vector3(0.,0.,0.23529411764705888);
        const C269 = new THREE.Vector3(0.,0.,0.22549019607843135);

        const normalVec269 = new THREE.Vector3();
        normalVec269.crossVectors(B269.sub(A269), C269.sub(A269));
        normalVec269.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal269 = new THREE.Vector3(0,0,1);

        const quaternionRotation269 = new THREE.Quaternion();
        quaternionRotation269.setFromUnitVectors(initialNormal269, normalVec269);

        ringMesh269.setRotationFromQuaternion(quaternionRotation269);

        return quaternionRotation269;
    }

    ringRoot.add(ringMesh269);
            
	var inradius270 = calulateInradius(getVertex113(), getVertex140(), getVertex141());
	var incenter270 = calulateIncenter(getVertex113(), getVertex140(), getVertex141());
	var ringGeometry270 = new THREE.RingGeometry((inradius270 - 0.005),inradius270, 32);
	const ringMaterial270 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh270 = new THREE.Mesh(ringGeometry270, ringMaterial270);

	function setCircleRotation270(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.77450980392156865],[0.,0.,0.76470588235294112]);

        ringMesh270.position.setX(incenter[0]);
        ringMesh270.position.setY(incenter[1]);
        ringMesh270.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex140(), getVertex141());
        var relRadius = inradius/inradius270;

        ringMesh270.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A270 = new THREE.Vector3(1.,0.,1.);
        const B270 = new THREE.Vector3(0.,0.,0.77450980392156865);
        const C270 = new THREE.Vector3(0.,0.,0.76470588235294112);

        const normalVec270 = new THREE.Vector3();
        normalVec270.crossVectors(B270.sub(A270), C270.sub(A270));
        normalVec270.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal270 = new THREE.Vector3(0,0,1);

        const quaternionRotation270 = new THREE.Quaternion();
        quaternionRotation270.setFromUnitVectors(initialNormal270, normalVec270);

        ringMesh270.setRotationFromQuaternion(quaternionRotation270);

        return quaternionRotation270;
    }

    ringRoot.add(ringMesh270);
            
	var inradius271 = calulateInradius(getVertex112(), getVertex194(), getVertex195());
	var incenter271 = calulateIncenter(getVertex112(), getVertex194(), getVertex195());
	var ringGeometry271 = new THREE.RingGeometry((inradius271 - 0.005),inradius271, 32);
	const ringMaterial271 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh271 = new THREE.Mesh(ringGeometry271, ringMaterial271);

	function setCircleRotation271(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.24509803921568629],[0.,0.,0.23529411764705888]);

        ringMesh271.position.setX(incenter[0]);
        ringMesh271.position.setY(incenter[1]);
        ringMesh271.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex194(), getVertex195());
        var relRadius = inradius/inradius271;

        ringMesh271.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A271 = new THREE.Vector3(1.,0.,0.);
        const B271 = new THREE.Vector3(0.,0.,0.24509803921568629);
        const C271 = new THREE.Vector3(0.,0.,0.23529411764705888);

        const normalVec271 = new THREE.Vector3();
        normalVec271.crossVectors(B271.sub(A271), C271.sub(A271));
        normalVec271.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal271 = new THREE.Vector3(0,0,1);

        const quaternionRotation271 = new THREE.Quaternion();
        quaternionRotation271.setFromUnitVectors(initialNormal271, normalVec271);

        ringMesh271.setRotationFromQuaternion(quaternionRotation271);

        return quaternionRotation271;
    }

    ringRoot.add(ringMesh271);
            
	var inradius272 = calulateInradius(getVertex113(), getVertex141(), getVertex142());
	var incenter272 = calulateIncenter(getVertex113(), getVertex141(), getVertex142());
	var ringGeometry272 = new THREE.RingGeometry((inradius272 - 0.005),inradius272, 32);
	const ringMaterial272 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh272 = new THREE.Mesh(ringGeometry272, ringMaterial272);

	function setCircleRotation272(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.76470588235294112],[0.,0.,0.75490196078431371]);

        ringMesh272.position.setX(incenter[0]);
        ringMesh272.position.setY(incenter[1]);
        ringMesh272.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex141(), getVertex142());
        var relRadius = inradius/inradius272;

        ringMesh272.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A272 = new THREE.Vector3(1.,0.,1.);
        const B272 = new THREE.Vector3(0.,0.,0.76470588235294112);
        const C272 = new THREE.Vector3(0.,0.,0.75490196078431371);

        const normalVec272 = new THREE.Vector3();
        normalVec272.crossVectors(B272.sub(A272), C272.sub(A272));
        normalVec272.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal272 = new THREE.Vector3(0,0,1);

        const quaternionRotation272 = new THREE.Quaternion();
        quaternionRotation272.setFromUnitVectors(initialNormal272, normalVec272);

        ringMesh272.setRotationFromQuaternion(quaternionRotation272);

        return quaternionRotation272;
    }

    ringRoot.add(ringMesh272);
            
	var inradius273 = calulateInradius(getVertex112(), getVertex193(), getVertex194());
	var incenter273 = calulateIncenter(getVertex112(), getVertex193(), getVertex194());
	var ringGeometry273 = new THREE.RingGeometry((inradius273 - 0.005),inradius273, 32);
	const ringMaterial273 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh273 = new THREE.Mesh(ringGeometry273, ringMaterial273);

	function setCircleRotation273(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.25490196078431371],[0.,0.,0.24509803921568629]);

        ringMesh273.position.setX(incenter[0]);
        ringMesh273.position.setY(incenter[1]);
        ringMesh273.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex193(), getVertex194());
        var relRadius = inradius/inradius273;

        ringMesh273.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A273 = new THREE.Vector3(1.,0.,0.);
        const B273 = new THREE.Vector3(0.,0.,0.25490196078431371);
        const C273 = new THREE.Vector3(0.,0.,0.24509803921568629);

        const normalVec273 = new THREE.Vector3();
        normalVec273.crossVectors(B273.sub(A273), C273.sub(A273));
        normalVec273.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal273 = new THREE.Vector3(0,0,1);

        const quaternionRotation273 = new THREE.Quaternion();
        quaternionRotation273.setFromUnitVectors(initialNormal273, normalVec273);

        ringMesh273.setRotationFromQuaternion(quaternionRotation273);

        return quaternionRotation273;
    }

    ringRoot.add(ringMesh273);
            
	var inradius274 = calulateInradius(getVertex113(), getVertex142(), getVertex143());
	var incenter274 = calulateIncenter(getVertex113(), getVertex142(), getVertex143());
	var ringGeometry274 = new THREE.RingGeometry((inradius274 - 0.005),inradius274, 32);
	const ringMaterial274 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh274 = new THREE.Mesh(ringGeometry274, ringMaterial274);

	function setCircleRotation274(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.75490196078431371],[0.,0.,0.74509803921568629]);

        ringMesh274.position.setX(incenter[0]);
        ringMesh274.position.setY(incenter[1]);
        ringMesh274.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex142(), getVertex143());
        var relRadius = inradius/inradius274;

        ringMesh274.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A274 = new THREE.Vector3(1.,0.,1.);
        const B274 = new THREE.Vector3(0.,0.,0.75490196078431371);
        const C274 = new THREE.Vector3(0.,0.,0.74509803921568629);

        const normalVec274 = new THREE.Vector3();
        normalVec274.crossVectors(B274.sub(A274), C274.sub(A274));
        normalVec274.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal274 = new THREE.Vector3(0,0,1);

        const quaternionRotation274 = new THREE.Quaternion();
        quaternionRotation274.setFromUnitVectors(initialNormal274, normalVec274);

        ringMesh274.setRotationFromQuaternion(quaternionRotation274);

        return quaternionRotation274;
    }

    ringRoot.add(ringMesh274);
            
	var inradius275 = calulateInradius(getVertex112(), getVertex192(), getVertex193());
	var incenter275 = calulateIncenter(getVertex112(), getVertex192(), getVertex193());
	var ringGeometry275 = new THREE.RingGeometry((inradius275 - 0.005),inradius275, 32);
	const ringMaterial275 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh275 = new THREE.Mesh(ringGeometry275, ringMaterial275);

	function setCircleRotation275(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.26470588235294124],[0.,0.,0.25490196078431371]);

        ringMesh275.position.setX(incenter[0]);
        ringMesh275.position.setY(incenter[1]);
        ringMesh275.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex192(), getVertex193());
        var relRadius = inradius/inradius275;

        ringMesh275.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A275 = new THREE.Vector3(1.,0.,0.);
        const B275 = new THREE.Vector3(0.,0.,0.26470588235294124);
        const C275 = new THREE.Vector3(0.,0.,0.25490196078431371);

        const normalVec275 = new THREE.Vector3();
        normalVec275.crossVectors(B275.sub(A275), C275.sub(A275));
        normalVec275.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal275 = new THREE.Vector3(0,0,1);

        const quaternionRotation275 = new THREE.Quaternion();
        quaternionRotation275.setFromUnitVectors(initialNormal275, normalVec275);

        ringMesh275.setRotationFromQuaternion(quaternionRotation275);

        return quaternionRotation275;
    }

    ringRoot.add(ringMesh275);
            
	var inradius276 = calulateInradius(getVertex113(), getVertex143(), getVertex144());
	var incenter276 = calulateIncenter(getVertex113(), getVertex143(), getVertex144());
	var ringGeometry276 = new THREE.RingGeometry((inradius276 - 0.005),inradius276, 32);
	const ringMaterial276 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh276 = new THREE.Mesh(ringGeometry276, ringMaterial276);

	function setCircleRotation276(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.74509803921568629],[0.,0.,0.73529411764705888]);

        ringMesh276.position.setX(incenter[0]);
        ringMesh276.position.setY(incenter[1]);
        ringMesh276.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex143(), getVertex144());
        var relRadius = inradius/inradius276;

        ringMesh276.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A276 = new THREE.Vector3(1.,0.,1.);
        const B276 = new THREE.Vector3(0.,0.,0.74509803921568629);
        const C276 = new THREE.Vector3(0.,0.,0.73529411764705888);

        const normalVec276 = new THREE.Vector3();
        normalVec276.crossVectors(B276.sub(A276), C276.sub(A276));
        normalVec276.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal276 = new THREE.Vector3(0,0,1);

        const quaternionRotation276 = new THREE.Quaternion();
        quaternionRotation276.setFromUnitVectors(initialNormal276, normalVec276);

        ringMesh276.setRotationFromQuaternion(quaternionRotation276);

        return quaternionRotation276;
    }

    ringRoot.add(ringMesh276);
            
	var inradius277 = calulateInradius(getVertex112(), getVertex191(), getVertex192());
	var incenter277 = calulateIncenter(getVertex112(), getVertex191(), getVertex192());
	var ringGeometry277 = new THREE.RingGeometry((inradius277 - 0.005),inradius277, 32);
	const ringMaterial277 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh277 = new THREE.Mesh(ringGeometry277, ringMaterial277);

	function setCircleRotation277(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.27450980392156865],[0.,0.,0.26470588235294124]);

        ringMesh277.position.setX(incenter[0]);
        ringMesh277.position.setY(incenter[1]);
        ringMesh277.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex191(), getVertex192());
        var relRadius = inradius/inradius277;

        ringMesh277.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A277 = new THREE.Vector3(1.,0.,0.);
        const B277 = new THREE.Vector3(0.,0.,0.27450980392156865);
        const C277 = new THREE.Vector3(0.,0.,0.26470588235294124);

        const normalVec277 = new THREE.Vector3();
        normalVec277.crossVectors(B277.sub(A277), C277.sub(A277));
        normalVec277.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal277 = new THREE.Vector3(0,0,1);

        const quaternionRotation277 = new THREE.Quaternion();
        quaternionRotation277.setFromUnitVectors(initialNormal277, normalVec277);

        ringMesh277.setRotationFromQuaternion(quaternionRotation277);

        return quaternionRotation277;
    }

    ringRoot.add(ringMesh277);
            
	var inradius278 = calulateInradius(getVertex113(), getVertex144(), getVertex145());
	var incenter278 = calulateIncenter(getVertex113(), getVertex144(), getVertex145());
	var ringGeometry278 = new THREE.RingGeometry((inradius278 - 0.005),inradius278, 32);
	const ringMaterial278 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh278 = new THREE.Mesh(ringGeometry278, ringMaterial278);

	function setCircleRotation278(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.73529411764705888],[0.,0.,0.72549019607843135]);

        ringMesh278.position.setX(incenter[0]);
        ringMesh278.position.setY(incenter[1]);
        ringMesh278.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex144(), getVertex145());
        var relRadius = inradius/inradius278;

        ringMesh278.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A278 = new THREE.Vector3(1.,0.,1.);
        const B278 = new THREE.Vector3(0.,0.,0.73529411764705888);
        const C278 = new THREE.Vector3(0.,0.,0.72549019607843135);

        const normalVec278 = new THREE.Vector3();
        normalVec278.crossVectors(B278.sub(A278), C278.sub(A278));
        normalVec278.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal278 = new THREE.Vector3(0,0,1);

        const quaternionRotation278 = new THREE.Quaternion();
        quaternionRotation278.setFromUnitVectors(initialNormal278, normalVec278);

        ringMesh278.setRotationFromQuaternion(quaternionRotation278);

        return quaternionRotation278;
    }

    ringRoot.add(ringMesh278);
            
	var inradius279 = calulateInradius(getVertex112(), getVertex190(), getVertex191());
	var incenter279 = calulateIncenter(getVertex112(), getVertex190(), getVertex191());
	var ringGeometry279 = new THREE.RingGeometry((inradius279 - 0.005),inradius279, 32);
	const ringMaterial279 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh279 = new THREE.Mesh(ringGeometry279, ringMaterial279);

	function setCircleRotation279(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.28431372549019607],[0.,0.,0.27450980392156865]);

        ringMesh279.position.setX(incenter[0]);
        ringMesh279.position.setY(incenter[1]);
        ringMesh279.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex190(), getVertex191());
        var relRadius = inradius/inradius279;

        ringMesh279.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A279 = new THREE.Vector3(1.,0.,0.);
        const B279 = new THREE.Vector3(0.,0.,0.28431372549019607);
        const C279 = new THREE.Vector3(0.,0.,0.27450980392156865);

        const normalVec279 = new THREE.Vector3();
        normalVec279.crossVectors(B279.sub(A279), C279.sub(A279));
        normalVec279.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal279 = new THREE.Vector3(0,0,1);

        const quaternionRotation279 = new THREE.Quaternion();
        quaternionRotation279.setFromUnitVectors(initialNormal279, normalVec279);

        ringMesh279.setRotationFromQuaternion(quaternionRotation279);

        return quaternionRotation279;
    }

    ringRoot.add(ringMesh279);
            
	var inradius280 = calulateInradius(getVertex113(), getVertex145(), getVertex146());
	var incenter280 = calulateIncenter(getVertex113(), getVertex145(), getVertex146());
	var ringGeometry280 = new THREE.RingGeometry((inradius280 - 0.005),inradius280, 32);
	const ringMaterial280 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh280 = new THREE.Mesh(ringGeometry280, ringMaterial280);

	function setCircleRotation280(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.72549019607843135],[0.,0.,0.71568627450980393]);

        ringMesh280.position.setX(incenter[0]);
        ringMesh280.position.setY(incenter[1]);
        ringMesh280.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex145(), getVertex146());
        var relRadius = inradius/inradius280;

        ringMesh280.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A280 = new THREE.Vector3(1.,0.,1.);
        const B280 = new THREE.Vector3(0.,0.,0.72549019607843135);
        const C280 = new THREE.Vector3(0.,0.,0.71568627450980393);

        const normalVec280 = new THREE.Vector3();
        normalVec280.crossVectors(B280.sub(A280), C280.sub(A280));
        normalVec280.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal280 = new THREE.Vector3(0,0,1);

        const quaternionRotation280 = new THREE.Quaternion();
        quaternionRotation280.setFromUnitVectors(initialNormal280, normalVec280);

        ringMesh280.setRotationFromQuaternion(quaternionRotation280);

        return quaternionRotation280;
    }

    ringRoot.add(ringMesh280);
            
	var inradius281 = calulateInradius(getVertex112(), getVertex189(), getVertex190());
	var incenter281 = calulateIncenter(getVertex112(), getVertex189(), getVertex190());
	var ringGeometry281 = new THREE.RingGeometry((inradius281 - 0.005),inradius281, 32);
	const ringMaterial281 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh281 = new THREE.Mesh(ringGeometry281, ringMaterial281);

	function setCircleRotation281(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.29411764705882359],[0.,0.,0.28431372549019607]);

        ringMesh281.position.setX(incenter[0]);
        ringMesh281.position.setY(incenter[1]);
        ringMesh281.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex189(), getVertex190());
        var relRadius = inradius/inradius281;

        ringMesh281.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A281 = new THREE.Vector3(1.,0.,0.);
        const B281 = new THREE.Vector3(0.,0.,0.29411764705882359);
        const C281 = new THREE.Vector3(0.,0.,0.28431372549019607);

        const normalVec281 = new THREE.Vector3();
        normalVec281.crossVectors(B281.sub(A281), C281.sub(A281));
        normalVec281.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal281 = new THREE.Vector3(0,0,1);

        const quaternionRotation281 = new THREE.Quaternion();
        quaternionRotation281.setFromUnitVectors(initialNormal281, normalVec281);

        ringMesh281.setRotationFromQuaternion(quaternionRotation281);

        return quaternionRotation281;
    }

    ringRoot.add(ringMesh281);
            
	var inradius282 = calulateInradius(getVertex113(), getVertex146(), getVertex147());
	var incenter282 = calulateIncenter(getVertex113(), getVertex146(), getVertex147());
	var ringGeometry282 = new THREE.RingGeometry((inradius282 - 0.005),inradius282, 32);
	const ringMaterial282 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh282 = new THREE.Mesh(ringGeometry282, ringMaterial282);

	function setCircleRotation282(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.71568627450980393],[0.,0.,0.70588235294117641]);

        ringMesh282.position.setX(incenter[0]);
        ringMesh282.position.setY(incenter[1]);
        ringMesh282.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex146(), getVertex147());
        var relRadius = inradius/inradius282;

        ringMesh282.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A282 = new THREE.Vector3(1.,0.,1.);
        const B282 = new THREE.Vector3(0.,0.,0.71568627450980393);
        const C282 = new THREE.Vector3(0.,0.,0.70588235294117641);

        const normalVec282 = new THREE.Vector3();
        normalVec282.crossVectors(B282.sub(A282), C282.sub(A282));
        normalVec282.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal282 = new THREE.Vector3(0,0,1);

        const quaternionRotation282 = new THREE.Quaternion();
        quaternionRotation282.setFromUnitVectors(initialNormal282, normalVec282);

        ringMesh282.setRotationFromQuaternion(quaternionRotation282);

        return quaternionRotation282;
    }

    ringRoot.add(ringMesh282);
            
	var inradius283 = calulateInradius(getVertex112(), getVertex188(), getVertex189());
	var incenter283 = calulateIncenter(getVertex112(), getVertex188(), getVertex189());
	var ringGeometry283 = new THREE.RingGeometry((inradius283 - 0.005),inradius283, 32);
	const ringMaterial283 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh283 = new THREE.Mesh(ringGeometry283, ringMaterial283);

	function setCircleRotation283(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.30392156862745101],[0.,0.,0.29411764705882359]);

        ringMesh283.position.setX(incenter[0]);
        ringMesh283.position.setY(incenter[1]);
        ringMesh283.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex188(), getVertex189());
        var relRadius = inradius/inradius283;

        ringMesh283.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A283 = new THREE.Vector3(1.,0.,0.);
        const B283 = new THREE.Vector3(0.,0.,0.30392156862745101);
        const C283 = new THREE.Vector3(0.,0.,0.29411764705882359);

        const normalVec283 = new THREE.Vector3();
        normalVec283.crossVectors(B283.sub(A283), C283.sub(A283));
        normalVec283.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal283 = new THREE.Vector3(0,0,1);

        const quaternionRotation283 = new THREE.Quaternion();
        quaternionRotation283.setFromUnitVectors(initialNormal283, normalVec283);

        ringMesh283.setRotationFromQuaternion(quaternionRotation283);

        return quaternionRotation283;
    }

    ringRoot.add(ringMesh283);
            
	var inradius284 = calulateInradius(getVertex113(), getVertex147(), getVertex148());
	var incenter284 = calulateIncenter(getVertex113(), getVertex147(), getVertex148());
	var ringGeometry284 = new THREE.RingGeometry((inradius284 - 0.005),inradius284, 32);
	const ringMaterial284 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh284 = new THREE.Mesh(ringGeometry284, ringMaterial284);

	function setCircleRotation284(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.70588235294117641],[0.,0.,0.69607843137254899]);

        ringMesh284.position.setX(incenter[0]);
        ringMesh284.position.setY(incenter[1]);
        ringMesh284.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex147(), getVertex148());
        var relRadius = inradius/inradius284;

        ringMesh284.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A284 = new THREE.Vector3(1.,0.,1.);
        const B284 = new THREE.Vector3(0.,0.,0.70588235294117641);
        const C284 = new THREE.Vector3(0.,0.,0.69607843137254899);

        const normalVec284 = new THREE.Vector3();
        normalVec284.crossVectors(B284.sub(A284), C284.sub(A284));
        normalVec284.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal284 = new THREE.Vector3(0,0,1);

        const quaternionRotation284 = new THREE.Quaternion();
        quaternionRotation284.setFromUnitVectors(initialNormal284, normalVec284);

        ringMesh284.setRotationFromQuaternion(quaternionRotation284);

        return quaternionRotation284;
    }

    ringRoot.add(ringMesh284);
            
	var inradius285 = calulateInradius(getVertex112(), getVertex187(), getVertex188());
	var incenter285 = calulateIncenter(getVertex112(), getVertex187(), getVertex188());
	var ringGeometry285 = new THREE.RingGeometry((inradius285 - 0.005),inradius285, 32);
	const ringMaterial285 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh285 = new THREE.Mesh(ringGeometry285, ringMaterial285);

	function setCircleRotation285(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.31372549019607843],[0.,0.,0.30392156862745101]);

        ringMesh285.position.setX(incenter[0]);
        ringMesh285.position.setY(incenter[1]);
        ringMesh285.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex187(), getVertex188());
        var relRadius = inradius/inradius285;

        ringMesh285.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A285 = new THREE.Vector3(1.,0.,0.);
        const B285 = new THREE.Vector3(0.,0.,0.31372549019607843);
        const C285 = new THREE.Vector3(0.,0.,0.30392156862745101);

        const normalVec285 = new THREE.Vector3();
        normalVec285.crossVectors(B285.sub(A285), C285.sub(A285));
        normalVec285.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal285 = new THREE.Vector3(0,0,1);

        const quaternionRotation285 = new THREE.Quaternion();
        quaternionRotation285.setFromUnitVectors(initialNormal285, normalVec285);

        ringMesh285.setRotationFromQuaternion(quaternionRotation285);

        return quaternionRotation285;
    }

    ringRoot.add(ringMesh285);
            
	var inradius286 = calulateInradius(getVertex113(), getVertex148(), getVertex149());
	var incenter286 = calulateIncenter(getVertex113(), getVertex148(), getVertex149());
	var ringGeometry286 = new THREE.RingGeometry((inradius286 - 0.005),inradius286, 32);
	const ringMaterial286 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh286 = new THREE.Mesh(ringGeometry286, ringMaterial286);

	function setCircleRotation286(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.69607843137254899],[0.,0.,0.68627450980392157]);

        ringMesh286.position.setX(incenter[0]);
        ringMesh286.position.setY(incenter[1]);
        ringMesh286.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex148(), getVertex149());
        var relRadius = inradius/inradius286;

        ringMesh286.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A286 = new THREE.Vector3(1.,0.,1.);
        const B286 = new THREE.Vector3(0.,0.,0.69607843137254899);
        const C286 = new THREE.Vector3(0.,0.,0.68627450980392157);

        const normalVec286 = new THREE.Vector3();
        normalVec286.crossVectors(B286.sub(A286), C286.sub(A286));
        normalVec286.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal286 = new THREE.Vector3(0,0,1);

        const quaternionRotation286 = new THREE.Quaternion();
        quaternionRotation286.setFromUnitVectors(initialNormal286, normalVec286);

        ringMesh286.setRotationFromQuaternion(quaternionRotation286);

        return quaternionRotation286;
    }

    ringRoot.add(ringMesh286);
            
	var inradius287 = calulateInradius(getVertex112(), getVertex186(), getVertex187());
	var incenter287 = calulateIncenter(getVertex112(), getVertex186(), getVertex187());
	var ringGeometry287 = new THREE.RingGeometry((inradius287 - 0.005),inradius287, 32);
	const ringMaterial287 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh287 = new THREE.Mesh(ringGeometry287, ringMaterial287);

	function setCircleRotation287(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.32352941176470584],[0.,0.,0.31372549019607843]);

        ringMesh287.position.setX(incenter[0]);
        ringMesh287.position.setY(incenter[1]);
        ringMesh287.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex186(), getVertex187());
        var relRadius = inradius/inradius287;

        ringMesh287.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A287 = new THREE.Vector3(1.,0.,0.);
        const B287 = new THREE.Vector3(0.,0.,0.32352941176470584);
        const C287 = new THREE.Vector3(0.,0.,0.31372549019607843);

        const normalVec287 = new THREE.Vector3();
        normalVec287.crossVectors(B287.sub(A287), C287.sub(A287));
        normalVec287.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal287 = new THREE.Vector3(0,0,1);

        const quaternionRotation287 = new THREE.Quaternion();
        quaternionRotation287.setFromUnitVectors(initialNormal287, normalVec287);

        ringMesh287.setRotationFromQuaternion(quaternionRotation287);

        return quaternionRotation287;
    }

    ringRoot.add(ringMesh287);
            
	var inradius288 = calulateInradius(getVertex113(), getVertex149(), getVertex150());
	var incenter288 = calulateIncenter(getVertex113(), getVertex149(), getVertex150());
	var ringGeometry288 = new THREE.RingGeometry((inradius288 - 0.005),inradius288, 32);
	const ringMaterial288 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh288 = new THREE.Mesh(ringGeometry288, ringMaterial288);

	function setCircleRotation288(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.68627450980392157],[0.,0.,0.67647058823529416]);

        ringMesh288.position.setX(incenter[0]);
        ringMesh288.position.setY(incenter[1]);
        ringMesh288.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex149(), getVertex150());
        var relRadius = inradius/inradius288;

        ringMesh288.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A288 = new THREE.Vector3(1.,0.,1.);
        const B288 = new THREE.Vector3(0.,0.,0.68627450980392157);
        const C288 = new THREE.Vector3(0.,0.,0.67647058823529416);

        const normalVec288 = new THREE.Vector3();
        normalVec288.crossVectors(B288.sub(A288), C288.sub(A288));
        normalVec288.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal288 = new THREE.Vector3(0,0,1);

        const quaternionRotation288 = new THREE.Quaternion();
        quaternionRotation288.setFromUnitVectors(initialNormal288, normalVec288);

        ringMesh288.setRotationFromQuaternion(quaternionRotation288);

        return quaternionRotation288;
    }

    ringRoot.add(ringMesh288);
            
	var inradius289 = calulateInradius(getVertex112(), getVertex185(), getVertex186());
	var incenter289 = calulateIncenter(getVertex112(), getVertex185(), getVertex186());
	var ringGeometry289 = new THREE.RingGeometry((inradius289 - 0.005),inradius289, 32);
	const ringMaterial289 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh289 = new THREE.Mesh(ringGeometry289, ringMaterial289);

	function setCircleRotation289(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.33333333333333337],[0.,0.,0.32352941176470584]);

        ringMesh289.position.setX(incenter[0]);
        ringMesh289.position.setY(incenter[1]);
        ringMesh289.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex185(), getVertex186());
        var relRadius = inradius/inradius289;

        ringMesh289.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A289 = new THREE.Vector3(1.,0.,0.);
        const B289 = new THREE.Vector3(0.,0.,0.33333333333333337);
        const C289 = new THREE.Vector3(0.,0.,0.32352941176470584);

        const normalVec289 = new THREE.Vector3();
        normalVec289.crossVectors(B289.sub(A289), C289.sub(A289));
        normalVec289.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal289 = new THREE.Vector3(0,0,1);

        const quaternionRotation289 = new THREE.Quaternion();
        quaternionRotation289.setFromUnitVectors(initialNormal289, normalVec289);

        ringMesh289.setRotationFromQuaternion(quaternionRotation289);

        return quaternionRotation289;
    }

    ringRoot.add(ringMesh289);
            
	var inradius290 = calulateInradius(getVertex113(), getVertex150(), getVertex151());
	var incenter290 = calulateIncenter(getVertex113(), getVertex150(), getVertex151());
	var ringGeometry290 = new THREE.RingGeometry((inradius290 - 0.005),inradius290, 32);
	const ringMaterial290 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh290 = new THREE.Mesh(ringGeometry290, ringMaterial290);

	function setCircleRotation290(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.67647058823529416],[0.,0.,0.66666666666666674]);

        ringMesh290.position.setX(incenter[0]);
        ringMesh290.position.setY(incenter[1]);
        ringMesh290.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex150(), getVertex151());
        var relRadius = inradius/inradius290;

        ringMesh290.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A290 = new THREE.Vector3(1.,0.,1.);
        const B290 = new THREE.Vector3(0.,0.,0.67647058823529416);
        const C290 = new THREE.Vector3(0.,0.,0.66666666666666674);

        const normalVec290 = new THREE.Vector3();
        normalVec290.crossVectors(B290.sub(A290), C290.sub(A290));
        normalVec290.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal290 = new THREE.Vector3(0,0,1);

        const quaternionRotation290 = new THREE.Quaternion();
        quaternionRotation290.setFromUnitVectors(initialNormal290, normalVec290);

        ringMesh290.setRotationFromQuaternion(quaternionRotation290);

        return quaternionRotation290;
    }

    ringRoot.add(ringMesh290);
            
	var inradius291 = calulateInradius(getVertex112(), getVertex184(), getVertex185());
	var incenter291 = calulateIncenter(getVertex112(), getVertex184(), getVertex185());
	var ringGeometry291 = new THREE.RingGeometry((inradius291 - 0.005),inradius291, 32);
	const ringMaterial291 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh291 = new THREE.Mesh(ringGeometry291, ringMaterial291);

	function setCircleRotation291(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.34313725490196079],[0.,0.,0.33333333333333337]);

        ringMesh291.position.setX(incenter[0]);
        ringMesh291.position.setY(incenter[1]);
        ringMesh291.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex184(), getVertex185());
        var relRadius = inradius/inradius291;

        ringMesh291.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A291 = new THREE.Vector3(1.,0.,0.);
        const B291 = new THREE.Vector3(0.,0.,0.34313725490196079);
        const C291 = new THREE.Vector3(0.,0.,0.33333333333333337);

        const normalVec291 = new THREE.Vector3();
        normalVec291.crossVectors(B291.sub(A291), C291.sub(A291));
        normalVec291.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal291 = new THREE.Vector3(0,0,1);

        const quaternionRotation291 = new THREE.Quaternion();
        quaternionRotation291.setFromUnitVectors(initialNormal291, normalVec291);

        ringMesh291.setRotationFromQuaternion(quaternionRotation291);

        return quaternionRotation291;
    }

    ringRoot.add(ringMesh291);
            
	var inradius292 = calulateInradius(getVertex113(), getVertex151(), getVertex152());
	var incenter292 = calulateIncenter(getVertex113(), getVertex151(), getVertex152());
	var ringGeometry292 = new THREE.RingGeometry((inradius292 - 0.005),inradius292, 32);
	const ringMaterial292 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh292 = new THREE.Mesh(ringGeometry292, ringMaterial292);

	function setCircleRotation292(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.66666666666666674],[0.,0.,0.65686274509803921]);

        ringMesh292.position.setX(incenter[0]);
        ringMesh292.position.setY(incenter[1]);
        ringMesh292.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex151(), getVertex152());
        var relRadius = inradius/inradius292;

        ringMesh292.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A292 = new THREE.Vector3(1.,0.,1.);
        const B292 = new THREE.Vector3(0.,0.,0.66666666666666674);
        const C292 = new THREE.Vector3(0.,0.,0.65686274509803921);

        const normalVec292 = new THREE.Vector3();
        normalVec292.crossVectors(B292.sub(A292), C292.sub(A292));
        normalVec292.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal292 = new THREE.Vector3(0,0,1);

        const quaternionRotation292 = new THREE.Quaternion();
        quaternionRotation292.setFromUnitVectors(initialNormal292, normalVec292);

        ringMesh292.setRotationFromQuaternion(quaternionRotation292);

        return quaternionRotation292;
    }

    ringRoot.add(ringMesh292);
            
	var inradius293 = calulateInradius(getVertex112(), getVertex183(), getVertex184());
	var incenter293 = calulateIncenter(getVertex112(), getVertex183(), getVertex184());
	var ringGeometry293 = new THREE.RingGeometry((inradius293 - 0.005),inradius293, 32);
	const ringMaterial293 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh293 = new THREE.Mesh(ringGeometry293, ringMaterial293);

	function setCircleRotation293(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.3529411764705882],[0.,0.,0.34313725490196079]);

        ringMesh293.position.setX(incenter[0]);
        ringMesh293.position.setY(incenter[1]);
        ringMesh293.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex183(), getVertex184());
        var relRadius = inradius/inradius293;

        ringMesh293.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A293 = new THREE.Vector3(1.,0.,0.);
        const B293 = new THREE.Vector3(0.,0.,0.3529411764705882);
        const C293 = new THREE.Vector3(0.,0.,0.34313725490196079);

        const normalVec293 = new THREE.Vector3();
        normalVec293.crossVectors(B293.sub(A293), C293.sub(A293));
        normalVec293.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal293 = new THREE.Vector3(0,0,1);

        const quaternionRotation293 = new THREE.Quaternion();
        quaternionRotation293.setFromUnitVectors(initialNormal293, normalVec293);

        ringMesh293.setRotationFromQuaternion(quaternionRotation293);

        return quaternionRotation293;
    }

    ringRoot.add(ringMesh293);
            
	var inradius294 = calulateInradius(getVertex113(), getVertex152(), getVertex153());
	var incenter294 = calulateIncenter(getVertex113(), getVertex152(), getVertex153());
	var ringGeometry294 = new THREE.RingGeometry((inradius294 - 0.005),inradius294, 32);
	const ringMaterial294 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh294 = new THREE.Mesh(ringGeometry294, ringMaterial294);

	function setCircleRotation294(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.65686274509803921],[0.,0.,0.6470588235294118]);

        ringMesh294.position.setX(incenter[0]);
        ringMesh294.position.setY(incenter[1]);
        ringMesh294.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex152(), getVertex153());
        var relRadius = inradius/inradius294;

        ringMesh294.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A294 = new THREE.Vector3(1.,0.,1.);
        const B294 = new THREE.Vector3(0.,0.,0.65686274509803921);
        const C294 = new THREE.Vector3(0.,0.,0.6470588235294118);

        const normalVec294 = new THREE.Vector3();
        normalVec294.crossVectors(B294.sub(A294), C294.sub(A294));
        normalVec294.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal294 = new THREE.Vector3(0,0,1);

        const quaternionRotation294 = new THREE.Quaternion();
        quaternionRotation294.setFromUnitVectors(initialNormal294, normalVec294);

        ringMesh294.setRotationFromQuaternion(quaternionRotation294);

        return quaternionRotation294;
    }

    ringRoot.add(ringMesh294);
            
	var inradius295 = calulateInradius(getVertex112(), getVertex182(), getVertex183());
	var incenter295 = calulateIncenter(getVertex112(), getVertex182(), getVertex183());
	var ringGeometry295 = new THREE.RingGeometry((inradius295 - 0.005),inradius295, 32);
	const ringMaterial295 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh295 = new THREE.Mesh(ringGeometry295, ringMaterial295);

	function setCircleRotation295(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.36274509803921573],[0.,0.,0.3529411764705882]);

        ringMesh295.position.setX(incenter[0]);
        ringMesh295.position.setY(incenter[1]);
        ringMesh295.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex182(), getVertex183());
        var relRadius = inradius/inradius295;

        ringMesh295.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A295 = new THREE.Vector3(1.,0.,0.);
        const B295 = new THREE.Vector3(0.,0.,0.36274509803921573);
        const C295 = new THREE.Vector3(0.,0.,0.3529411764705882);

        const normalVec295 = new THREE.Vector3();
        normalVec295.crossVectors(B295.sub(A295), C295.sub(A295));
        normalVec295.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal295 = new THREE.Vector3(0,0,1);

        const quaternionRotation295 = new THREE.Quaternion();
        quaternionRotation295.setFromUnitVectors(initialNormal295, normalVec295);

        ringMesh295.setRotationFromQuaternion(quaternionRotation295);

        return quaternionRotation295;
    }

    ringRoot.add(ringMesh295);
            
	var inradius296 = calulateInradius(getVertex113(), getVertex153(), getVertex154());
	var incenter296 = calulateIncenter(getVertex113(), getVertex153(), getVertex154());
	var ringGeometry296 = new THREE.RingGeometry((inradius296 - 0.005),inradius296, 32);
	const ringMaterial296 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh296 = new THREE.Mesh(ringGeometry296, ringMaterial296);

	function setCircleRotation296(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.6470588235294118],[0.,0.,0.63725490196078427]);

        ringMesh296.position.setX(incenter[0]);
        ringMesh296.position.setY(incenter[1]);
        ringMesh296.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex153(), getVertex154());
        var relRadius = inradius/inradius296;

        ringMesh296.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A296 = new THREE.Vector3(1.,0.,1.);
        const B296 = new THREE.Vector3(0.,0.,0.6470588235294118);
        const C296 = new THREE.Vector3(0.,0.,0.63725490196078427);

        const normalVec296 = new THREE.Vector3();
        normalVec296.crossVectors(B296.sub(A296), C296.sub(A296));
        normalVec296.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal296 = new THREE.Vector3(0,0,1);

        const quaternionRotation296 = new THREE.Quaternion();
        quaternionRotation296.setFromUnitVectors(initialNormal296, normalVec296);

        ringMesh296.setRotationFromQuaternion(quaternionRotation296);

        return quaternionRotation296;
    }

    ringRoot.add(ringMesh296);
            
	var inradius297 = calulateInradius(getVertex112(), getVertex181(), getVertex182());
	var incenter297 = calulateIncenter(getVertex112(), getVertex181(), getVertex182());
	var ringGeometry297 = new THREE.RingGeometry((inradius297 - 0.005),inradius297, 32);
	const ringMaterial297 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh297 = new THREE.Mesh(ringGeometry297, ringMaterial297);

	function setCircleRotation297(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.37254901960784315],[0.,0.,0.36274509803921573]);

        ringMesh297.position.setX(incenter[0]);
        ringMesh297.position.setY(incenter[1]);
        ringMesh297.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex181(), getVertex182());
        var relRadius = inradius/inradius297;

        ringMesh297.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A297 = new THREE.Vector3(1.,0.,0.);
        const B297 = new THREE.Vector3(0.,0.,0.37254901960784315);
        const C297 = new THREE.Vector3(0.,0.,0.36274509803921573);

        const normalVec297 = new THREE.Vector3();
        normalVec297.crossVectors(B297.sub(A297), C297.sub(A297));
        normalVec297.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal297 = new THREE.Vector3(0,0,1);

        const quaternionRotation297 = new THREE.Quaternion();
        quaternionRotation297.setFromUnitVectors(initialNormal297, normalVec297);

        ringMesh297.setRotationFromQuaternion(quaternionRotation297);

        return quaternionRotation297;
    }

    ringRoot.add(ringMesh297);
            
	var inradius298 = calulateInradius(getVertex113(), getVertex154(), getVertex155());
	var incenter298 = calulateIncenter(getVertex113(), getVertex154(), getVertex155());
	var ringGeometry298 = new THREE.RingGeometry((inradius298 - 0.005),inradius298, 32);
	const ringMaterial298 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh298 = new THREE.Mesh(ringGeometry298, ringMaterial298);

	function setCircleRotation298(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.63725490196078427],[0.,0.,0.62745098039215685]);

        ringMesh298.position.setX(incenter[0]);
        ringMesh298.position.setY(incenter[1]);
        ringMesh298.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex154(), getVertex155());
        var relRadius = inradius/inradius298;

        ringMesh298.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A298 = new THREE.Vector3(1.,0.,1.);
        const B298 = new THREE.Vector3(0.,0.,0.63725490196078427);
        const C298 = new THREE.Vector3(0.,0.,0.62745098039215685);

        const normalVec298 = new THREE.Vector3();
        normalVec298.crossVectors(B298.sub(A298), C298.sub(A298));
        normalVec298.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal298 = new THREE.Vector3(0,0,1);

        const quaternionRotation298 = new THREE.Quaternion();
        quaternionRotation298.setFromUnitVectors(initialNormal298, normalVec298);

        ringMesh298.setRotationFromQuaternion(quaternionRotation298);

        return quaternionRotation298;
    }

    ringRoot.add(ringMesh298);
            
	var inradius299 = calulateInradius(getVertex112(), getVertex180(), getVertex181());
	var incenter299 = calulateIncenter(getVertex112(), getVertex180(), getVertex181());
	var ringGeometry299 = new THREE.RingGeometry((inradius299 - 0.005),inradius299, 32);
	const ringMaterial299 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh299 = new THREE.Mesh(ringGeometry299, ringMaterial299);

	function setCircleRotation299(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.38235294117647056],[0.,0.,0.37254901960784315]);

        ringMesh299.position.setX(incenter[0]);
        ringMesh299.position.setY(incenter[1]);
        ringMesh299.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex180(), getVertex181());
        var relRadius = inradius/inradius299;

        ringMesh299.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A299 = new THREE.Vector3(1.,0.,0.);
        const B299 = new THREE.Vector3(0.,0.,0.38235294117647056);
        const C299 = new THREE.Vector3(0.,0.,0.37254901960784315);

        const normalVec299 = new THREE.Vector3();
        normalVec299.crossVectors(B299.sub(A299), C299.sub(A299));
        normalVec299.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal299 = new THREE.Vector3(0,0,1);

        const quaternionRotation299 = new THREE.Quaternion();
        quaternionRotation299.setFromUnitVectors(initialNormal299, normalVec299);

        ringMesh299.setRotationFromQuaternion(quaternionRotation299);

        return quaternionRotation299;
    }

    ringRoot.add(ringMesh299);
            
	var inradius300 = calulateInradius(getVertex113(), getVertex155(), getVertex156());
	var incenter300 = calulateIncenter(getVertex113(), getVertex155(), getVertex156());
	var ringGeometry300 = new THREE.RingGeometry((inradius300 - 0.005),inradius300, 32);
	const ringMaterial300 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh300 = new THREE.Mesh(ringGeometry300, ringMaterial300);

	function setCircleRotation300(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.62745098039215685],[0.,0.,0.61764705882352944]);

        ringMesh300.position.setX(incenter[0]);
        ringMesh300.position.setY(incenter[1]);
        ringMesh300.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex155(), getVertex156());
        var relRadius = inradius/inradius300;

        ringMesh300.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A300 = new THREE.Vector3(1.,0.,1.);
        const B300 = new THREE.Vector3(0.,0.,0.62745098039215685);
        const C300 = new THREE.Vector3(0.,0.,0.61764705882352944);

        const normalVec300 = new THREE.Vector3();
        normalVec300.crossVectors(B300.sub(A300), C300.sub(A300));
        normalVec300.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal300 = new THREE.Vector3(0,0,1);

        const quaternionRotation300 = new THREE.Quaternion();
        quaternionRotation300.setFromUnitVectors(initialNormal300, normalVec300);

        ringMesh300.setRotationFromQuaternion(quaternionRotation300);

        return quaternionRotation300;
    }

    ringRoot.add(ringMesh300);
            
	var inradius301 = calulateInradius(getVertex112(), getVertex179(), getVertex180());
	var incenter301 = calulateIncenter(getVertex112(), getVertex179(), getVertex180());
	var ringGeometry301 = new THREE.RingGeometry((inradius301 - 0.005),inradius301, 32);
	const ringMaterial301 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh301 = new THREE.Mesh(ringGeometry301, ringMaterial301);

	function setCircleRotation301(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.39215686274509809],[0.,0.,0.38235294117647056]);

        ringMesh301.position.setX(incenter[0]);
        ringMesh301.position.setY(incenter[1]);
        ringMesh301.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex179(), getVertex180());
        var relRadius = inradius/inradius301;

        ringMesh301.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A301 = new THREE.Vector3(1.,0.,0.);
        const B301 = new THREE.Vector3(0.,0.,0.39215686274509809);
        const C301 = new THREE.Vector3(0.,0.,0.38235294117647056);

        const normalVec301 = new THREE.Vector3();
        normalVec301.crossVectors(B301.sub(A301), C301.sub(A301));
        normalVec301.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal301 = new THREE.Vector3(0,0,1);

        const quaternionRotation301 = new THREE.Quaternion();
        quaternionRotation301.setFromUnitVectors(initialNormal301, normalVec301);

        ringMesh301.setRotationFromQuaternion(quaternionRotation301);

        return quaternionRotation301;
    }

    ringRoot.add(ringMesh301);
            
	var inradius302 = calulateInradius(getVertex113(), getVertex156(), getVertex157());
	var incenter302 = calulateIncenter(getVertex113(), getVertex156(), getVertex157());
	var ringGeometry302 = new THREE.RingGeometry((inradius302 - 0.005),inradius302, 32);
	const ringMaterial302 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh302 = new THREE.Mesh(ringGeometry302, ringMaterial302);

	function setCircleRotation302(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.61764705882352944],[0.,0.,0.60784313725490202]);

        ringMesh302.position.setX(incenter[0]);
        ringMesh302.position.setY(incenter[1]);
        ringMesh302.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex156(), getVertex157());
        var relRadius = inradius/inradius302;

        ringMesh302.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A302 = new THREE.Vector3(1.,0.,1.);
        const B302 = new THREE.Vector3(0.,0.,0.61764705882352944);
        const C302 = new THREE.Vector3(0.,0.,0.60784313725490202);

        const normalVec302 = new THREE.Vector3();
        normalVec302.crossVectors(B302.sub(A302), C302.sub(A302));
        normalVec302.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal302 = new THREE.Vector3(0,0,1);

        const quaternionRotation302 = new THREE.Quaternion();
        quaternionRotation302.setFromUnitVectors(initialNormal302, normalVec302);

        ringMesh302.setRotationFromQuaternion(quaternionRotation302);

        return quaternionRotation302;
    }

    ringRoot.add(ringMesh302);
            
	var inradius303 = calulateInradius(getVertex112(), getVertex178(), getVertex179());
	var incenter303 = calulateIncenter(getVertex112(), getVertex178(), getVertex179());
	var ringGeometry303 = new THREE.RingGeometry((inradius303 - 0.005),inradius303, 32);
	const ringMaterial303 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh303 = new THREE.Mesh(ringGeometry303, ringMaterial303);

	function setCircleRotation303(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.40196078431372551],[0.,0.,0.39215686274509809]);

        ringMesh303.position.setX(incenter[0]);
        ringMesh303.position.setY(incenter[1]);
        ringMesh303.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex178(), getVertex179());
        var relRadius = inradius/inradius303;

        ringMesh303.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A303 = new THREE.Vector3(1.,0.,0.);
        const B303 = new THREE.Vector3(0.,0.,0.40196078431372551);
        const C303 = new THREE.Vector3(0.,0.,0.39215686274509809);

        const normalVec303 = new THREE.Vector3();
        normalVec303.crossVectors(B303.sub(A303), C303.sub(A303));
        normalVec303.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal303 = new THREE.Vector3(0,0,1);

        const quaternionRotation303 = new THREE.Quaternion();
        quaternionRotation303.setFromUnitVectors(initialNormal303, normalVec303);

        ringMesh303.setRotationFromQuaternion(quaternionRotation303);

        return quaternionRotation303;
    }

    ringRoot.add(ringMesh303);
            
	var inradius304 = calulateInradius(getVertex113(), getVertex157(), getVertex158());
	var incenter304 = calulateIncenter(getVertex113(), getVertex157(), getVertex158());
	var ringGeometry304 = new THREE.RingGeometry((inradius304 - 0.005),inradius304, 32);
	const ringMaterial304 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh304 = new THREE.Mesh(ringGeometry304, ringMaterial304);

	function setCircleRotation304(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.60784313725490202],[0.,0.,0.59803921568627449]);

        ringMesh304.position.setX(incenter[0]);
        ringMesh304.position.setY(incenter[1]);
        ringMesh304.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex157(), getVertex158());
        var relRadius = inradius/inradius304;

        ringMesh304.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A304 = new THREE.Vector3(1.,0.,1.);
        const B304 = new THREE.Vector3(0.,0.,0.60784313725490202);
        const C304 = new THREE.Vector3(0.,0.,0.59803921568627449);

        const normalVec304 = new THREE.Vector3();
        normalVec304.crossVectors(B304.sub(A304), C304.sub(A304));
        normalVec304.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal304 = new THREE.Vector3(0,0,1);

        const quaternionRotation304 = new THREE.Quaternion();
        quaternionRotation304.setFromUnitVectors(initialNormal304, normalVec304);

        ringMesh304.setRotationFromQuaternion(quaternionRotation304);

        return quaternionRotation304;
    }

    ringRoot.add(ringMesh304);
            
	var inradius305 = calulateInradius(getVertex112(), getVertex177(), getVertex178());
	var incenter305 = calulateIncenter(getVertex112(), getVertex177(), getVertex178());
	var ringGeometry305 = new THREE.RingGeometry((inradius305 - 0.005),inradius305, 32);
	const ringMaterial305 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh305 = new THREE.Mesh(ringGeometry305, ringMaterial305);

	function setCircleRotation305(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.41176470588235292],[0.,0.,0.40196078431372551]);

        ringMesh305.position.setX(incenter[0]);
        ringMesh305.position.setY(incenter[1]);
        ringMesh305.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex177(), getVertex178());
        var relRadius = inradius/inradius305;

        ringMesh305.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A305 = new THREE.Vector3(1.,0.,0.);
        const B305 = new THREE.Vector3(0.,0.,0.41176470588235292);
        const C305 = new THREE.Vector3(0.,0.,0.40196078431372551);

        const normalVec305 = new THREE.Vector3();
        normalVec305.crossVectors(B305.sub(A305), C305.sub(A305));
        normalVec305.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal305 = new THREE.Vector3(0,0,1);

        const quaternionRotation305 = new THREE.Quaternion();
        quaternionRotation305.setFromUnitVectors(initialNormal305, normalVec305);

        ringMesh305.setRotationFromQuaternion(quaternionRotation305);

        return quaternionRotation305;
    }

    ringRoot.add(ringMesh305);
            
	var inradius306 = calulateInradius(getVertex113(), getVertex158(), getVertex159());
	var incenter306 = calulateIncenter(getVertex113(), getVertex158(), getVertex159());
	var ringGeometry306 = new THREE.RingGeometry((inradius306 - 0.005),inradius306, 32);
	const ringMaterial306 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh306 = new THREE.Mesh(ringGeometry306, ringMaterial306);

	function setCircleRotation306(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.59803921568627449],[0.,0.,0.58823529411764708]);

        ringMesh306.position.setX(incenter[0]);
        ringMesh306.position.setY(incenter[1]);
        ringMesh306.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex158(), getVertex159());
        var relRadius = inradius/inradius306;

        ringMesh306.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A306 = new THREE.Vector3(1.,0.,1.);
        const B306 = new THREE.Vector3(0.,0.,0.59803921568627449);
        const C306 = new THREE.Vector3(0.,0.,0.58823529411764708);

        const normalVec306 = new THREE.Vector3();
        normalVec306.crossVectors(B306.sub(A306), C306.sub(A306));
        normalVec306.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal306 = new THREE.Vector3(0,0,1);

        const quaternionRotation306 = new THREE.Quaternion();
        quaternionRotation306.setFromUnitVectors(initialNormal306, normalVec306);

        ringMesh306.setRotationFromQuaternion(quaternionRotation306);

        return quaternionRotation306;
    }

    ringRoot.add(ringMesh306);
            
	var inradius307 = calulateInradius(getVertex112(), getVertex176(), getVertex177());
	var incenter307 = calulateIncenter(getVertex112(), getVertex176(), getVertex177());
	var ringGeometry307 = new THREE.RingGeometry((inradius307 - 0.005),inradius307, 32);
	const ringMaterial307 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh307 = new THREE.Mesh(ringGeometry307, ringMaterial307);

	function setCircleRotation307(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.42156862745098045],[0.,0.,0.41176470588235292]);

        ringMesh307.position.setX(incenter[0]);
        ringMesh307.position.setY(incenter[1]);
        ringMesh307.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex176(), getVertex177());
        var relRadius = inradius/inradius307;

        ringMesh307.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A307 = new THREE.Vector3(1.,0.,0.);
        const B307 = new THREE.Vector3(0.,0.,0.42156862745098045);
        const C307 = new THREE.Vector3(0.,0.,0.41176470588235292);

        const normalVec307 = new THREE.Vector3();
        normalVec307.crossVectors(B307.sub(A307), C307.sub(A307));
        normalVec307.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal307 = new THREE.Vector3(0,0,1);

        const quaternionRotation307 = new THREE.Quaternion();
        quaternionRotation307.setFromUnitVectors(initialNormal307, normalVec307);

        ringMesh307.setRotationFromQuaternion(quaternionRotation307);

        return quaternionRotation307;
    }

    ringRoot.add(ringMesh307);
            
	var inradius308 = calulateInradius(getVertex113(), getVertex159(), getVertex160());
	var incenter308 = calulateIncenter(getVertex113(), getVertex159(), getVertex160());
	var ringGeometry308 = new THREE.RingGeometry((inradius308 - 0.005),inradius308, 32);
	const ringMaterial308 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh308 = new THREE.Mesh(ringGeometry308, ringMaterial308);

	function setCircleRotation308(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.58823529411764708],[0.,0.,0.57843137254901955]);

        ringMesh308.position.setX(incenter[0]);
        ringMesh308.position.setY(incenter[1]);
        ringMesh308.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex159(), getVertex160());
        var relRadius = inradius/inradius308;

        ringMesh308.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A308 = new THREE.Vector3(1.,0.,1.);
        const B308 = new THREE.Vector3(0.,0.,0.58823529411764708);
        const C308 = new THREE.Vector3(0.,0.,0.57843137254901955);

        const normalVec308 = new THREE.Vector3();
        normalVec308.crossVectors(B308.sub(A308), C308.sub(A308));
        normalVec308.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal308 = new THREE.Vector3(0,0,1);

        const quaternionRotation308 = new THREE.Quaternion();
        quaternionRotation308.setFromUnitVectors(initialNormal308, normalVec308);

        ringMesh308.setRotationFromQuaternion(quaternionRotation308);

        return quaternionRotation308;
    }

    ringRoot.add(ringMesh308);
            
	var inradius309 = calulateInradius(getVertex112(), getVertex175(), getVertex176());
	var incenter309 = calulateIncenter(getVertex112(), getVertex175(), getVertex176());
	var ringGeometry309 = new THREE.RingGeometry((inradius309 - 0.005),inradius309, 32);
	const ringMaterial309 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh309 = new THREE.Mesh(ringGeometry309, ringMaterial309);

	function setCircleRotation309(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.43137254901960786],[0.,0.,0.42156862745098045]);

        ringMesh309.position.setX(incenter[0]);
        ringMesh309.position.setY(incenter[1]);
        ringMesh309.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex175(), getVertex176());
        var relRadius = inradius/inradius309;

        ringMesh309.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A309 = new THREE.Vector3(1.,0.,0.);
        const B309 = new THREE.Vector3(0.,0.,0.43137254901960786);
        const C309 = new THREE.Vector3(0.,0.,0.42156862745098045);

        const normalVec309 = new THREE.Vector3();
        normalVec309.crossVectors(B309.sub(A309), C309.sub(A309));
        normalVec309.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal309 = new THREE.Vector3(0,0,1);

        const quaternionRotation309 = new THREE.Quaternion();
        quaternionRotation309.setFromUnitVectors(initialNormal309, normalVec309);

        ringMesh309.setRotationFromQuaternion(quaternionRotation309);

        return quaternionRotation309;
    }

    ringRoot.add(ringMesh309);
            
	var inradius310 = calulateInradius(getVertex113(), getVertex160(), getVertex161());
	var incenter310 = calulateIncenter(getVertex113(), getVertex160(), getVertex161());
	var ringGeometry310 = new THREE.RingGeometry((inradius310 - 0.005),inradius310, 32);
	const ringMaterial310 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh310 = new THREE.Mesh(ringGeometry310, ringMaterial310);

	function setCircleRotation310(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.57843137254901955],[0.,0.,0.56862745098039214]);

        ringMesh310.position.setX(incenter[0]);
        ringMesh310.position.setY(incenter[1]);
        ringMesh310.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex160(), getVertex161());
        var relRadius = inradius/inradius310;

        ringMesh310.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A310 = new THREE.Vector3(1.,0.,1.);
        const B310 = new THREE.Vector3(0.,0.,0.57843137254901955);
        const C310 = new THREE.Vector3(0.,0.,0.56862745098039214);

        const normalVec310 = new THREE.Vector3();
        normalVec310.crossVectors(B310.sub(A310), C310.sub(A310));
        normalVec310.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal310 = new THREE.Vector3(0,0,1);

        const quaternionRotation310 = new THREE.Quaternion();
        quaternionRotation310.setFromUnitVectors(initialNormal310, normalVec310);

        ringMesh310.setRotationFromQuaternion(quaternionRotation310);

        return quaternionRotation310;
    }

    ringRoot.add(ringMesh310);
            
	var inradius311 = calulateInradius(getVertex112(), getVertex174(), getVertex175());
	var incenter311 = calulateIncenter(getVertex112(), getVertex174(), getVertex175());
	var ringGeometry311 = new THREE.RingGeometry((inradius311 - 0.005),inradius311, 32);
	const ringMaterial311 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh311 = new THREE.Mesh(ringGeometry311, ringMaterial311);

	function setCircleRotation311(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.44117647058823528],[0.,0.,0.43137254901960786]);

        ringMesh311.position.setX(incenter[0]);
        ringMesh311.position.setY(incenter[1]);
        ringMesh311.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex174(), getVertex175());
        var relRadius = inradius/inradius311;

        ringMesh311.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A311 = new THREE.Vector3(1.,0.,0.);
        const B311 = new THREE.Vector3(0.,0.,0.44117647058823528);
        const C311 = new THREE.Vector3(0.,0.,0.43137254901960786);

        const normalVec311 = new THREE.Vector3();
        normalVec311.crossVectors(B311.sub(A311), C311.sub(A311));
        normalVec311.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal311 = new THREE.Vector3(0,0,1);

        const quaternionRotation311 = new THREE.Quaternion();
        quaternionRotation311.setFromUnitVectors(initialNormal311, normalVec311);

        ringMesh311.setRotationFromQuaternion(quaternionRotation311);

        return quaternionRotation311;
    }

    ringRoot.add(ringMesh311);
            
	var inradius312 = calulateInradius(getVertex113(), getVertex161(), getVertex162());
	var incenter312 = calulateIncenter(getVertex113(), getVertex161(), getVertex162());
	var ringGeometry312 = new THREE.RingGeometry((inradius312 - 0.005),inradius312, 32);
	const ringMaterial312 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh312 = new THREE.Mesh(ringGeometry312, ringMaterial312);

	function setCircleRotation312(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.56862745098039214],[0.,0.,0.55882352941176472]);

        ringMesh312.position.setX(incenter[0]);
        ringMesh312.position.setY(incenter[1]);
        ringMesh312.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex161(), getVertex162());
        var relRadius = inradius/inradius312;

        ringMesh312.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A312 = new THREE.Vector3(1.,0.,1.);
        const B312 = new THREE.Vector3(0.,0.,0.56862745098039214);
        const C312 = new THREE.Vector3(0.,0.,0.55882352941176472);

        const normalVec312 = new THREE.Vector3();
        normalVec312.crossVectors(B312.sub(A312), C312.sub(A312));
        normalVec312.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal312 = new THREE.Vector3(0,0,1);

        const quaternionRotation312 = new THREE.Quaternion();
        quaternionRotation312.setFromUnitVectors(initialNormal312, normalVec312);

        ringMesh312.setRotationFromQuaternion(quaternionRotation312);

        return quaternionRotation312;
    }

    ringRoot.add(ringMesh312);
            
	var inradius313 = calulateInradius(getVertex112(), getVertex173(), getVertex174());
	var incenter313 = calulateIncenter(getVertex112(), getVertex173(), getVertex174());
	var ringGeometry313 = new THREE.RingGeometry((inradius313 - 0.005),inradius313, 32);
	const ringMaterial313 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh313 = new THREE.Mesh(ringGeometry313, ringMaterial313);

	function setCircleRotation313(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.4509803921568627],[0.,0.,0.44117647058823528]);

        ringMesh313.position.setX(incenter[0]);
        ringMesh313.position.setY(incenter[1]);
        ringMesh313.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex173(), getVertex174());
        var relRadius = inradius/inradius313;

        ringMesh313.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A313 = new THREE.Vector3(1.,0.,0.);
        const B313 = new THREE.Vector3(0.,0.,0.4509803921568627);
        const C313 = new THREE.Vector3(0.,0.,0.44117647058823528);

        const normalVec313 = new THREE.Vector3();
        normalVec313.crossVectors(B313.sub(A313), C313.sub(A313));
        normalVec313.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal313 = new THREE.Vector3(0,0,1);

        const quaternionRotation313 = new THREE.Quaternion();
        quaternionRotation313.setFromUnitVectors(initialNormal313, normalVec313);

        ringMesh313.setRotationFromQuaternion(quaternionRotation313);

        return quaternionRotation313;
    }

    ringRoot.add(ringMesh313);
            
	var inradius314 = calulateInradius(getVertex113(), getVertex162(), getVertex163());
	var incenter314 = calulateIncenter(getVertex113(), getVertex162(), getVertex163());
	var ringGeometry314 = new THREE.RingGeometry((inradius314 - 0.005),inradius314, 32);
	const ringMaterial314 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh314 = new THREE.Mesh(ringGeometry314, ringMaterial314);

	function setCircleRotation314(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.55882352941176472],[0.,0.,0.5490196078431373]);

        ringMesh314.position.setX(incenter[0]);
        ringMesh314.position.setY(incenter[1]);
        ringMesh314.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex162(), getVertex163());
        var relRadius = inradius/inradius314;

        ringMesh314.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A314 = new THREE.Vector3(1.,0.,1.);
        const B314 = new THREE.Vector3(0.,0.,0.55882352941176472);
        const C314 = new THREE.Vector3(0.,0.,0.5490196078431373);

        const normalVec314 = new THREE.Vector3();
        normalVec314.crossVectors(B314.sub(A314), C314.sub(A314));
        normalVec314.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal314 = new THREE.Vector3(0,0,1);

        const quaternionRotation314 = new THREE.Quaternion();
        quaternionRotation314.setFromUnitVectors(initialNormal314, normalVec314);

        ringMesh314.setRotationFromQuaternion(quaternionRotation314);

        return quaternionRotation314;
    }

    ringRoot.add(ringMesh314);
            
	var inradius315 = calulateInradius(getVertex112(), getVertex172(), getVertex173());
	var incenter315 = calulateIncenter(getVertex112(), getVertex172(), getVertex173());
	var ringGeometry315 = new THREE.RingGeometry((inradius315 - 0.005),inradius315, 32);
	const ringMaterial315 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh315 = new THREE.Mesh(ringGeometry315, ringMaterial315);

	function setCircleRotation315(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.46078431372549022],[0.,0.,0.4509803921568627]);

        ringMesh315.position.setX(incenter[0]);
        ringMesh315.position.setY(incenter[1]);
        ringMesh315.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex172(), getVertex173());
        var relRadius = inradius/inradius315;

        ringMesh315.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A315 = new THREE.Vector3(1.,0.,0.);
        const B315 = new THREE.Vector3(0.,0.,0.46078431372549022);
        const C315 = new THREE.Vector3(0.,0.,0.4509803921568627);

        const normalVec315 = new THREE.Vector3();
        normalVec315.crossVectors(B315.sub(A315), C315.sub(A315));
        normalVec315.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal315 = new THREE.Vector3(0,0,1);

        const quaternionRotation315 = new THREE.Quaternion();
        quaternionRotation315.setFromUnitVectors(initialNormal315, normalVec315);

        ringMesh315.setRotationFromQuaternion(quaternionRotation315);

        return quaternionRotation315;
    }

    ringRoot.add(ringMesh315);
            
	var inradius316 = calulateInradius(getVertex113(), getVertex163(), getVertex164());
	var incenter316 = calulateIncenter(getVertex113(), getVertex163(), getVertex164());
	var ringGeometry316 = new THREE.RingGeometry((inradius316 - 0.005),inradius316, 32);
	const ringMaterial316 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh316 = new THREE.Mesh(ringGeometry316, ringMaterial316);

	function setCircleRotation316(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.5490196078431373],[0.,0.,0.53921568627450989]);

        ringMesh316.position.setX(incenter[0]);
        ringMesh316.position.setY(incenter[1]);
        ringMesh316.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex163(), getVertex164());
        var relRadius = inradius/inradius316;

        ringMesh316.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A316 = new THREE.Vector3(1.,0.,1.);
        const B316 = new THREE.Vector3(0.,0.,0.5490196078431373);
        const C316 = new THREE.Vector3(0.,0.,0.53921568627450989);

        const normalVec316 = new THREE.Vector3();
        normalVec316.crossVectors(B316.sub(A316), C316.sub(A316));
        normalVec316.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal316 = new THREE.Vector3(0,0,1);

        const quaternionRotation316 = new THREE.Quaternion();
        quaternionRotation316.setFromUnitVectors(initialNormal316, normalVec316);

        ringMesh316.setRotationFromQuaternion(quaternionRotation316);

        return quaternionRotation316;
    }

    ringRoot.add(ringMesh316);
            
	var inradius317 = calulateInradius(getVertex112(), getVertex171(), getVertex172());
	var incenter317 = calulateIncenter(getVertex112(), getVertex171(), getVertex172());
	var ringGeometry317 = new THREE.RingGeometry((inradius317 - 0.005),inradius317, 32);
	const ringMaterial317 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh317 = new THREE.Mesh(ringGeometry317, ringMaterial317);

	function setCircleRotation317(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.47058823529411764],[0.,0.,0.46078431372549022]);

        ringMesh317.position.setX(incenter[0]);
        ringMesh317.position.setY(incenter[1]);
        ringMesh317.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex171(), getVertex172());
        var relRadius = inradius/inradius317;

        ringMesh317.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A317 = new THREE.Vector3(1.,0.,0.);
        const B317 = new THREE.Vector3(0.,0.,0.47058823529411764);
        const C317 = new THREE.Vector3(0.,0.,0.46078431372549022);

        const normalVec317 = new THREE.Vector3();
        normalVec317.crossVectors(B317.sub(A317), C317.sub(A317));
        normalVec317.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal317 = new THREE.Vector3(0,0,1);

        const quaternionRotation317 = new THREE.Quaternion();
        quaternionRotation317.setFromUnitVectors(initialNormal317, normalVec317);

        ringMesh317.setRotationFromQuaternion(quaternionRotation317);

        return quaternionRotation317;
    }

    ringRoot.add(ringMesh317);
            
	var inradius318 = calulateInradius(getVertex113(), getVertex164(), getVertex165());
	var incenter318 = calulateIncenter(getVertex113(), getVertex164(), getVertex165());
	var ringGeometry318 = new THREE.RingGeometry((inradius318 - 0.005),inradius318, 32);
	const ringMaterial318 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh318 = new THREE.Mesh(ringGeometry318, ringMaterial318);

	function setCircleRotation318(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.53921568627450989],[0.,0.,0.52941176470588236]);

        ringMesh318.position.setX(incenter[0]);
        ringMesh318.position.setY(incenter[1]);
        ringMesh318.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex164(), getVertex165());
        var relRadius = inradius/inradius318;

        ringMesh318.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A318 = new THREE.Vector3(1.,0.,1.);
        const B318 = new THREE.Vector3(0.,0.,0.53921568627450989);
        const C318 = new THREE.Vector3(0.,0.,0.52941176470588236);

        const normalVec318 = new THREE.Vector3();
        normalVec318.crossVectors(B318.sub(A318), C318.sub(A318));
        normalVec318.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal318 = new THREE.Vector3(0,0,1);

        const quaternionRotation318 = new THREE.Quaternion();
        quaternionRotation318.setFromUnitVectors(initialNormal318, normalVec318);

        ringMesh318.setRotationFromQuaternion(quaternionRotation318);

        return quaternionRotation318;
    }

    ringRoot.add(ringMesh318);
            
	var inradius319 = calulateInradius(getVertex112(), getVertex170(), getVertex171());
	var incenter319 = calulateIncenter(getVertex112(), getVertex170(), getVertex171());
	var ringGeometry319 = new THREE.RingGeometry((inradius319 - 0.005),inradius319, 32);
	const ringMaterial319 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh319 = new THREE.Mesh(ringGeometry319, ringMaterial319);

	function setCircleRotation319(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.48039215686274506],[0.,0.,0.47058823529411764]);

        ringMesh319.position.setX(incenter[0]);
        ringMesh319.position.setY(incenter[1]);
        ringMesh319.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex170(), getVertex171());
        var relRadius = inradius/inradius319;

        ringMesh319.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A319 = new THREE.Vector3(1.,0.,0.);
        const B319 = new THREE.Vector3(0.,0.,0.48039215686274506);
        const C319 = new THREE.Vector3(0.,0.,0.47058823529411764);

        const normalVec319 = new THREE.Vector3();
        normalVec319.crossVectors(B319.sub(A319), C319.sub(A319));
        normalVec319.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal319 = new THREE.Vector3(0,0,1);

        const quaternionRotation319 = new THREE.Quaternion();
        quaternionRotation319.setFromUnitVectors(initialNormal319, normalVec319);

        ringMesh319.setRotationFromQuaternion(quaternionRotation319);

        return quaternionRotation319;
    }

    ringRoot.add(ringMesh319);
            
	var inradius320 = calulateInradius(getVertex113(), getVertex165(), getVertex166());
	var incenter320 = calulateIncenter(getVertex113(), getVertex165(), getVertex166());
	var ringGeometry320 = new THREE.RingGeometry((inradius320 - 0.005),inradius320, 32);
	const ringMaterial320 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh320 = new THREE.Mesh(ringGeometry320, ringMaterial320);

	function setCircleRotation320(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.52941176470588236],[0.,0.,0.51960784313725483]);

        ringMesh320.position.setX(incenter[0]);
        ringMesh320.position.setY(incenter[1]);
        ringMesh320.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex165(), getVertex166());
        var relRadius = inradius/inradius320;

        ringMesh320.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A320 = new THREE.Vector3(1.,0.,1.);
        const B320 = new THREE.Vector3(0.,0.,0.52941176470588236);
        const C320 = new THREE.Vector3(0.,0.,0.51960784313725483);

        const normalVec320 = new THREE.Vector3();
        normalVec320.crossVectors(B320.sub(A320), C320.sub(A320));
        normalVec320.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal320 = new THREE.Vector3(0,0,1);

        const quaternionRotation320 = new THREE.Quaternion();
        quaternionRotation320.setFromUnitVectors(initialNormal320, normalVec320);

        ringMesh320.setRotationFromQuaternion(quaternionRotation320);

        return quaternionRotation320;
    }

    ringRoot.add(ringMesh320);
            
	var inradius321 = calulateInradius(getVertex112(), getVertex169(), getVertex170());
	var incenter321 = calulateIncenter(getVertex112(), getVertex169(), getVertex170());
	var ringGeometry321 = new THREE.RingGeometry((inradius321 - 0.005),inradius321, 32);
	const ringMaterial321 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh321 = new THREE.Mesh(ringGeometry321, ringMaterial321);

	function setCircleRotation321(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.49019607843137258],[0.,0.,0.48039215686274506]);

        ringMesh321.position.setX(incenter[0]);
        ringMesh321.position.setY(incenter[1]);
        ringMesh321.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex169(), getVertex170());
        var relRadius = inradius/inradius321;

        ringMesh321.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A321 = new THREE.Vector3(1.,0.,0.);
        const B321 = new THREE.Vector3(0.,0.,0.49019607843137258);
        const C321 = new THREE.Vector3(0.,0.,0.48039215686274506);

        const normalVec321 = new THREE.Vector3();
        normalVec321.crossVectors(B321.sub(A321), C321.sub(A321));
        normalVec321.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal321 = new THREE.Vector3(0,0,1);

        const quaternionRotation321 = new THREE.Quaternion();
        quaternionRotation321.setFromUnitVectors(initialNormal321, normalVec321);

        ringMesh321.setRotationFromQuaternion(quaternionRotation321);

        return quaternionRotation321;
    }

    ringRoot.add(ringMesh321);
            
	var inradius322 = calulateInradius(getVertex113(), getVertex166(), getVertex167());
	var incenter322 = calulateIncenter(getVertex113(), getVertex166(), getVertex167());
	var ringGeometry322 = new THREE.RingGeometry((inradius322 - 0.005),inradius322, 32);
	const ringMaterial322 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh322 = new THREE.Mesh(ringGeometry322, ringMaterial322);

	function setCircleRotation322(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.51960784313725483],[0.,0.,0.50980392156862742]);

        ringMesh322.position.setX(incenter[0]);
        ringMesh322.position.setY(incenter[1]);
        ringMesh322.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex166(), getVertex167());
        var relRadius = inradius/inradius322;

        ringMesh322.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A322 = new THREE.Vector3(1.,0.,1.);
        const B322 = new THREE.Vector3(0.,0.,0.51960784313725483);
        const C322 = new THREE.Vector3(0.,0.,0.50980392156862742);

        const normalVec322 = new THREE.Vector3();
        normalVec322.crossVectors(B322.sub(A322), C322.sub(A322));
        normalVec322.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal322 = new THREE.Vector3(0,0,1);

        const quaternionRotation322 = new THREE.Quaternion();
        quaternionRotation322.setFromUnitVectors(initialNormal322, normalVec322);

        ringMesh322.setRotationFromQuaternion(quaternionRotation322);

        return quaternionRotation322;
    }

    ringRoot.add(ringMesh322);
            
	var inradius323 = calulateInradius(getVertex112(), getVertex168(), getVertex169());
	var incenter323 = calulateIncenter(getVertex112(), getVertex168(), getVertex169());
	var ringGeometry323 = new THREE.RingGeometry((inradius323 - 0.005),inradius323, 32);
	const ringMaterial323 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh323 = new THREE.Mesh(ringGeometry323, ringMaterial323);

	function setCircleRotation323(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.5],[0.,0.,0.49019607843137258]);

        ringMesh323.position.setX(incenter[0]);
        ringMesh323.position.setY(incenter[1]);
        ringMesh323.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex168(), getVertex169());
        var relRadius = inradius/inradius323;

        ringMesh323.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A323 = new THREE.Vector3(1.,0.,0.);
        const B323 = new THREE.Vector3(0.,0.,0.5);
        const C323 = new THREE.Vector3(0.,0.,0.49019607843137258);

        const normalVec323 = new THREE.Vector3();
        normalVec323.crossVectors(B323.sub(A323), C323.sub(A323));
        normalVec323.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal323 = new THREE.Vector3(0,0,1);

        const quaternionRotation323 = new THREE.Quaternion();
        quaternionRotation323.setFromUnitVectors(initialNormal323, normalVec323);

        ringMesh323.setRotationFromQuaternion(quaternionRotation323);

        return quaternionRotation323;
    }

    ringRoot.add(ringMesh323);
            
	var inradius324 = calulateInradius(getVertex113(), getVertex167(), getVertex168());
	var incenter324 = calulateIncenter(getVertex113(), getVertex167(), getVertex168());
	var ringGeometry324 = new THREE.RingGeometry((inradius324 - 0.005),inradius324, 32);
	const ringMaterial324 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh324 = new THREE.Mesh(ringGeometry324, ringMaterial324);

	function setCircleRotation324(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.50980392156862742],[0.,0.,0.5]);

        ringMesh324.position.setX(incenter[0]);
        ringMesh324.position.setY(incenter[1]);
        ringMesh324.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex113(), getVertex167(), getVertex168());
        var relRadius = inradius/inradius324;

        ringMesh324.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A324 = new THREE.Vector3(1.,0.,1.);
        const B324 = new THREE.Vector3(0.,0.,0.50980392156862742);
        const C324 = new THREE.Vector3(0.,0.,0.5);

        const normalVec324 = new THREE.Vector3();
        normalVec324.crossVectors(B324.sub(A324), C324.sub(A324));
        normalVec324.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal324 = new THREE.Vector3(0,0,1);

        const quaternionRotation324 = new THREE.Quaternion();
        quaternionRotation324.setFromUnitVectors(initialNormal324, normalVec324);

        ringMesh324.setRotationFromQuaternion(quaternionRotation324);

        return quaternionRotation324;
    }

    ringRoot.add(ringMesh324);
            
	var inradius325 = calulateInradius(getVertex112(), getVertex113(), getVertex168());
	var incenter325 = calulateIncenter(getVertex112(), getVertex113(), getVertex168());
	var ringGeometry325 = new THREE.RingGeometry((inradius325 - 0.005),inradius325, 32);
	const ringMaterial325 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh325 = new THREE.Mesh(ringGeometry325, ringMaterial325);

	function setCircleRotation325(){

        //translate ring to incenter
        var incenter = calulateIncenter([1.,0.,0.],[ 1.,0.,1.],[0.,0.,0.5]);

        ringMesh325.position.setX(incenter[0]);
        ringMesh325.position.setY(incenter[1]);
        ringMesh325.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex112(), getVertex113(), getVertex168());
        var relRadius = inradius/inradius325;

        ringMesh325.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A325 = new THREE.Vector3(1.,0.,0.);
        const B325 = new THREE.Vector3(1.,0.,1.);
        const C325 = new THREE.Vector3(0.,0.,0.5);

        const normalVec325 = new THREE.Vector3();
        normalVec325.crossVectors(B325.sub(A325), C325.sub(A325));
        normalVec325.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal325 = new THREE.Vector3(0,0,1);

        const quaternionRotation325 = new THREE.Quaternion();
        quaternionRotation325.setFromUnitVectors(initialNormal325, normalVec325);

        ringMesh325.setRotationFromQuaternion(quaternionRotation325);

        return quaternionRotation325;
    }

    ringRoot.add(ringMesh325);
            
	var inradius326 = calulateInradius(getVertex115(), getVertex116(), getVertex218());
	var incenter326 = calulateIncenter(getVertex115(), getVertex116(), getVertex218());
	var ringGeometry326 = new THREE.RingGeometry((inradius326 - 0.005),inradius326, 32);
	const ringMaterial326 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh326 = new THREE.Mesh(ringGeometry326, ringMaterial326);

	function setCircleRotation326(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,0.,0.],[ 0.,1.,0.],[0.,0.,0.0098039215686274161]);

        ringMesh326.position.setX(incenter[0]);
        ringMesh326.position.setY(incenter[1]);
        ringMesh326.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex115(), getVertex116(), getVertex218());
        var relRadius = inradius/inradius326;

        ringMesh326.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A326 = new THREE.Vector3(0.,0.,0.);
        const B326 = new THREE.Vector3(0.,1.,0.);
        const C326 = new THREE.Vector3(0.,0.,0.0098039215686274161);

        const normalVec326 = new THREE.Vector3();
        normalVec326.crossVectors(B326.sub(A326), C326.sub(A326));
        normalVec326.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal326 = new THREE.Vector3(0,0,1);

        const quaternionRotation326 = new THREE.Quaternion();
        quaternionRotation326.setFromUnitVectors(initialNormal326, normalVec326);

        ringMesh326.setRotationFromQuaternion(quaternionRotation326);

        return quaternionRotation326;
    }

    ringRoot.add(ringMesh326);
            
	var inradius327 = calulateInradius(getVertex114(), getVertex117(), getVertex118());
	var incenter327 = calulateIncenter(getVertex114(), getVertex117(), getVertex118());
	var ringGeometry327 = new THREE.RingGeometry((inradius327 - 0.005),inradius327, 32);
	const ringMaterial327 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh327 = new THREE.Mesh(ringGeometry327, ringMaterial327);

	function setCircleRotation327(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,0.,1.],[ 0.,1.,1.],[0.,0.,0.99019607843137258]);

        ringMesh327.position.setX(incenter[0]);
        ringMesh327.position.setY(incenter[1]);
        ringMesh327.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex114(), getVertex117(), getVertex118());
        var relRadius = inradius/inradius327;

        ringMesh327.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A327 = new THREE.Vector3(0.,0.,1.);
        const B327 = new THREE.Vector3(0.,1.,1.);
        const C327 = new THREE.Vector3(0.,0.,0.99019607843137258);

        const normalVec327 = new THREE.Vector3();
        normalVec327.crossVectors(B327.sub(A327), C327.sub(A327));
        normalVec327.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal327 = new THREE.Vector3(0,0,1);

        const quaternionRotation327 = new THREE.Quaternion();
        quaternionRotation327.setFromUnitVectors(initialNormal327, normalVec327);

        ringMesh327.setRotationFromQuaternion(quaternionRotation327);

        return quaternionRotation327;
    }

    ringRoot.add(ringMesh327);
            
	var inradius328 = calulateInradius(getVertex116(), getVertex217(), getVertex218());
	var incenter328 = calulateIncenter(getVertex116(), getVertex217(), getVertex218());
	var ringGeometry328 = new THREE.RingGeometry((inradius328 - 0.005),inradius328, 32);
	const ringMaterial328 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh328 = new THREE.Mesh(ringGeometry328, ringMaterial328);

	function setCircleRotation328(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.019607843137254943],[0.,0.,0.0098039215686274161]);

        ringMesh328.position.setX(incenter[0]);
        ringMesh328.position.setY(incenter[1]);
        ringMesh328.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex217(), getVertex218());
        var relRadius = inradius/inradius328;

        ringMesh328.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A328 = new THREE.Vector3(0.,1.,0.);
        const B328 = new THREE.Vector3(0.,0.,0.019607843137254943);
        const C328 = new THREE.Vector3(0.,0.,0.0098039215686274161);

        const normalVec328 = new THREE.Vector3();
        normalVec328.crossVectors(B328.sub(A328), C328.sub(A328));
        normalVec328.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal328 = new THREE.Vector3(0,0,1);

        const quaternionRotation328 = new THREE.Quaternion();
        quaternionRotation328.setFromUnitVectors(initialNormal328, normalVec328);

        ringMesh328.setRotationFromQuaternion(quaternionRotation328);

        return quaternionRotation328;
    }

    ringRoot.add(ringMesh328);
            
	var inradius329 = calulateInradius(getVertex117(), getVertex118(), getVertex119());
	var incenter329 = calulateIncenter(getVertex117(), getVertex118(), getVertex119());
	var ringGeometry329 = new THREE.RingGeometry((inradius329 - 0.005),inradius329, 32);
	const ringMaterial329 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh329 = new THREE.Mesh(ringGeometry329, ringMaterial329);

	function setCircleRotation329(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.99019607843137258],[0.,0.,0.98039215686274506]);

        ringMesh329.position.setX(incenter[0]);
        ringMesh329.position.setY(incenter[1]);
        ringMesh329.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex118(), getVertex119());
        var relRadius = inradius/inradius329;

        ringMesh329.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A329 = new THREE.Vector3(0.,1.,1.);
        const B329 = new THREE.Vector3(0.,0.,0.99019607843137258);
        const C329 = new THREE.Vector3(0.,0.,0.98039215686274506);

        const normalVec329 = new THREE.Vector3();
        normalVec329.crossVectors(B329.sub(A329), C329.sub(A329));
        normalVec329.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal329 = new THREE.Vector3(0,0,1);

        const quaternionRotation329 = new THREE.Quaternion();
        quaternionRotation329.setFromUnitVectors(initialNormal329, normalVec329);

        ringMesh329.setRotationFromQuaternion(quaternionRotation329);

        return quaternionRotation329;
    }

    ringRoot.add(ringMesh329);
            
	var inradius330 = calulateInradius(getVertex116(), getVertex216(), getVertex217());
	var incenter330 = calulateIncenter(getVertex116(), getVertex216(), getVertex217());
	var ringGeometry330 = new THREE.RingGeometry((inradius330 - 0.005),inradius330, 32);
	const ringMaterial330 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh330 = new THREE.Mesh(ringGeometry330, ringMaterial330);

	function setCircleRotation330(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.029411764705882359],[0.,0.,0.019607843137254943]);

        ringMesh330.position.setX(incenter[0]);
        ringMesh330.position.setY(incenter[1]);
        ringMesh330.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex216(), getVertex217());
        var relRadius = inradius/inradius330;

        ringMesh330.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A330 = new THREE.Vector3(0.,1.,0.);
        const B330 = new THREE.Vector3(0.,0.,0.029411764705882359);
        const C330 = new THREE.Vector3(0.,0.,0.019607843137254943);

        const normalVec330 = new THREE.Vector3();
        normalVec330.crossVectors(B330.sub(A330), C330.sub(A330));
        normalVec330.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal330 = new THREE.Vector3(0,0,1);

        const quaternionRotation330 = new THREE.Quaternion();
        quaternionRotation330.setFromUnitVectors(initialNormal330, normalVec330);

        ringMesh330.setRotationFromQuaternion(quaternionRotation330);

        return quaternionRotation330;
    }

    ringRoot.add(ringMesh330);
            
	var inradius331 = calulateInradius(getVertex117(), getVertex119(), getVertex120());
	var incenter331 = calulateIncenter(getVertex117(), getVertex119(), getVertex120());
	var ringGeometry331 = new THREE.RingGeometry((inradius331 - 0.005),inradius331, 32);
	const ringMaterial331 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh331 = new THREE.Mesh(ringGeometry331, ringMaterial331);

	function setCircleRotation331(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.98039215686274506],[0.,0.,0.97058823529411764]);

        ringMesh331.position.setX(incenter[0]);
        ringMesh331.position.setY(incenter[1]);
        ringMesh331.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex119(), getVertex120());
        var relRadius = inradius/inradius331;

        ringMesh331.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A331 = new THREE.Vector3(0.,1.,1.);
        const B331 = new THREE.Vector3(0.,0.,0.98039215686274506);
        const C331 = new THREE.Vector3(0.,0.,0.97058823529411764);

        const normalVec331 = new THREE.Vector3();
        normalVec331.crossVectors(B331.sub(A331), C331.sub(A331));
        normalVec331.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal331 = new THREE.Vector3(0,0,1);

        const quaternionRotation331 = new THREE.Quaternion();
        quaternionRotation331.setFromUnitVectors(initialNormal331, normalVec331);

        ringMesh331.setRotationFromQuaternion(quaternionRotation331);

        return quaternionRotation331;
    }

    ringRoot.add(ringMesh331);
            
	var inradius332 = calulateInradius(getVertex116(), getVertex215(), getVertex216());
	var incenter332 = calulateIncenter(getVertex116(), getVertex215(), getVertex216());
	var ringGeometry332 = new THREE.RingGeometry((inradius332 - 0.005),inradius332, 32);
	const ringMaterial332 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh332 = new THREE.Mesh(ringGeometry332, ringMaterial332);

	function setCircleRotation332(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.039215686274509776],[0.,0.,0.029411764705882359]);

        ringMesh332.position.setX(incenter[0]);
        ringMesh332.position.setY(incenter[1]);
        ringMesh332.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex215(), getVertex216());
        var relRadius = inradius/inradius332;

        ringMesh332.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A332 = new THREE.Vector3(0.,1.,0.);
        const B332 = new THREE.Vector3(0.,0.,0.039215686274509776);
        const C332 = new THREE.Vector3(0.,0.,0.029411764705882359);

        const normalVec332 = new THREE.Vector3();
        normalVec332.crossVectors(B332.sub(A332), C332.sub(A332));
        normalVec332.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal332 = new THREE.Vector3(0,0,1);

        const quaternionRotation332 = new THREE.Quaternion();
        quaternionRotation332.setFromUnitVectors(initialNormal332, normalVec332);

        ringMesh332.setRotationFromQuaternion(quaternionRotation332);

        return quaternionRotation332;
    }

    ringRoot.add(ringMesh332);
            
	var inradius333 = calulateInradius(getVertex117(), getVertex120(), getVertex121());
	var incenter333 = calulateIncenter(getVertex117(), getVertex120(), getVertex121());
	var ringGeometry333 = new THREE.RingGeometry((inradius333 - 0.005),inradius333, 32);
	const ringMaterial333 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh333 = new THREE.Mesh(ringGeometry333, ringMaterial333);

	function setCircleRotation333(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.97058823529411764],[0.,0.,0.96078431372549022]);

        ringMesh333.position.setX(incenter[0]);
        ringMesh333.position.setY(incenter[1]);
        ringMesh333.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex120(), getVertex121());
        var relRadius = inradius/inradius333;

        ringMesh333.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A333 = new THREE.Vector3(0.,1.,1.);
        const B333 = new THREE.Vector3(0.,0.,0.97058823529411764);
        const C333 = new THREE.Vector3(0.,0.,0.96078431372549022);

        const normalVec333 = new THREE.Vector3();
        normalVec333.crossVectors(B333.sub(A333), C333.sub(A333));
        normalVec333.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal333 = new THREE.Vector3(0,0,1);

        const quaternionRotation333 = new THREE.Quaternion();
        quaternionRotation333.setFromUnitVectors(initialNormal333, normalVec333);

        ringMesh333.setRotationFromQuaternion(quaternionRotation333);

        return quaternionRotation333;
    }

    ringRoot.add(ringMesh333);
            
	var inradius334 = calulateInradius(getVertex116(), getVertex214(), getVertex215());
	var incenter334 = calulateIncenter(getVertex116(), getVertex214(), getVertex215());
	var ringGeometry334 = new THREE.RingGeometry((inradius334 - 0.005),inradius334, 32);
	const ringMaterial334 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh334 = new THREE.Mesh(ringGeometry334, ringMaterial334);

	function setCircleRotation334(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.049019607843137303],[0.,0.,0.039215686274509776]);

        ringMesh334.position.setX(incenter[0]);
        ringMesh334.position.setY(incenter[1]);
        ringMesh334.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex214(), getVertex215());
        var relRadius = inradius/inradius334;

        ringMesh334.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A334 = new THREE.Vector3(0.,1.,0.);
        const B334 = new THREE.Vector3(0.,0.,0.049019607843137303);
        const C334 = new THREE.Vector3(0.,0.,0.039215686274509776);

        const normalVec334 = new THREE.Vector3();
        normalVec334.crossVectors(B334.sub(A334), C334.sub(A334));
        normalVec334.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal334 = new THREE.Vector3(0,0,1);

        const quaternionRotation334 = new THREE.Quaternion();
        quaternionRotation334.setFromUnitVectors(initialNormal334, normalVec334);

        ringMesh334.setRotationFromQuaternion(quaternionRotation334);

        return quaternionRotation334;
    }

    ringRoot.add(ringMesh334);
            
	var inradius335 = calulateInradius(getVertex117(), getVertex121(), getVertex122());
	var incenter335 = calulateIncenter(getVertex117(), getVertex121(), getVertex122());
	var ringGeometry335 = new THREE.RingGeometry((inradius335 - 0.005),inradius335, 32);
	const ringMaterial335 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh335 = new THREE.Mesh(ringGeometry335, ringMaterial335);

	function setCircleRotation335(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.96078431372549022],[0.,0.,0.9509803921568627]);

        ringMesh335.position.setX(incenter[0]);
        ringMesh335.position.setY(incenter[1]);
        ringMesh335.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex121(), getVertex122());
        var relRadius = inradius/inradius335;

        ringMesh335.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A335 = new THREE.Vector3(0.,1.,1.);
        const B335 = new THREE.Vector3(0.,0.,0.96078431372549022);
        const C335 = new THREE.Vector3(0.,0.,0.9509803921568627);

        const normalVec335 = new THREE.Vector3();
        normalVec335.crossVectors(B335.sub(A335), C335.sub(A335));
        normalVec335.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal335 = new THREE.Vector3(0,0,1);

        const quaternionRotation335 = new THREE.Quaternion();
        quaternionRotation335.setFromUnitVectors(initialNormal335, normalVec335);

        ringMesh335.setRotationFromQuaternion(quaternionRotation335);

        return quaternionRotation335;
    }

    ringRoot.add(ringMesh335);
            
	var inradius336 = calulateInradius(getVertex116(), getVertex213(), getVertex214());
	var incenter336 = calulateIncenter(getVertex116(), getVertex213(), getVertex214());
	var ringGeometry336 = new THREE.RingGeometry((inradius336 - 0.005),inradius336, 32);
	const ringMaterial336 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh336 = new THREE.Mesh(ringGeometry336, ringMaterial336);

	function setCircleRotation336(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.058823529411764719],[0.,0.,0.049019607843137303]);

        ringMesh336.position.setX(incenter[0]);
        ringMesh336.position.setY(incenter[1]);
        ringMesh336.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex213(), getVertex214());
        var relRadius = inradius/inradius336;

        ringMesh336.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A336 = new THREE.Vector3(0.,1.,0.);
        const B336 = new THREE.Vector3(0.,0.,0.058823529411764719);
        const C336 = new THREE.Vector3(0.,0.,0.049019607843137303);

        const normalVec336 = new THREE.Vector3();
        normalVec336.crossVectors(B336.sub(A336), C336.sub(A336));
        normalVec336.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal336 = new THREE.Vector3(0,0,1);

        const quaternionRotation336 = new THREE.Quaternion();
        quaternionRotation336.setFromUnitVectors(initialNormal336, normalVec336);

        ringMesh336.setRotationFromQuaternion(quaternionRotation336);

        return quaternionRotation336;
    }

    ringRoot.add(ringMesh336);
            
	var inradius337 = calulateInradius(getVertex117(), getVertex122(), getVertex123());
	var incenter337 = calulateIncenter(getVertex117(), getVertex122(), getVertex123());
	var ringGeometry337 = new THREE.RingGeometry((inradius337 - 0.005),inradius337, 32);
	const ringMaterial337 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh337 = new THREE.Mesh(ringGeometry337, ringMaterial337);

	function setCircleRotation337(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.9509803921568627],[0.,0.,0.94117647058823528]);

        ringMesh337.position.setX(incenter[0]);
        ringMesh337.position.setY(incenter[1]);
        ringMesh337.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex122(), getVertex123());
        var relRadius = inradius/inradius337;

        ringMesh337.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A337 = new THREE.Vector3(0.,1.,1.);
        const B337 = new THREE.Vector3(0.,0.,0.9509803921568627);
        const C337 = new THREE.Vector3(0.,0.,0.94117647058823528);

        const normalVec337 = new THREE.Vector3();
        normalVec337.crossVectors(B337.sub(A337), C337.sub(A337));
        normalVec337.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal337 = new THREE.Vector3(0,0,1);

        const quaternionRotation337 = new THREE.Quaternion();
        quaternionRotation337.setFromUnitVectors(initialNormal337, normalVec337);

        ringMesh337.setRotationFromQuaternion(quaternionRotation337);

        return quaternionRotation337;
    }

    ringRoot.add(ringMesh337);
            
	var inradius338 = calulateInradius(getVertex116(), getVertex212(), getVertex213());
	var incenter338 = calulateIncenter(getVertex116(), getVertex212(), getVertex213());
	var ringGeometry338 = new THREE.RingGeometry((inradius338 - 0.005),inradius338, 32);
	const ringMaterial338 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh338 = new THREE.Mesh(ringGeometry338, ringMaterial338);

	function setCircleRotation338(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.068627450980392135],[0.,0.,0.058823529411764719]);

        ringMesh338.position.setX(incenter[0]);
        ringMesh338.position.setY(incenter[1]);
        ringMesh338.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex212(), getVertex213());
        var relRadius = inradius/inradius338;

        ringMesh338.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A338 = new THREE.Vector3(0.,1.,0.);
        const B338 = new THREE.Vector3(0.,0.,0.068627450980392135);
        const C338 = new THREE.Vector3(0.,0.,0.058823529411764719);

        const normalVec338 = new THREE.Vector3();
        normalVec338.crossVectors(B338.sub(A338), C338.sub(A338));
        normalVec338.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal338 = new THREE.Vector3(0,0,1);

        const quaternionRotation338 = new THREE.Quaternion();
        quaternionRotation338.setFromUnitVectors(initialNormal338, normalVec338);

        ringMesh338.setRotationFromQuaternion(quaternionRotation338);

        return quaternionRotation338;
    }

    ringRoot.add(ringMesh338);
            
	var inradius339 = calulateInradius(getVertex117(), getVertex123(), getVertex124());
	var incenter339 = calulateIncenter(getVertex117(), getVertex123(), getVertex124());
	var ringGeometry339 = new THREE.RingGeometry((inradius339 - 0.005),inradius339, 32);
	const ringMaterial339 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh339 = new THREE.Mesh(ringGeometry339, ringMaterial339);

	function setCircleRotation339(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.94117647058823528],[0.,0.,0.93137254901960786]);

        ringMesh339.position.setX(incenter[0]);
        ringMesh339.position.setY(incenter[1]);
        ringMesh339.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex123(), getVertex124());
        var relRadius = inradius/inradius339;

        ringMesh339.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A339 = new THREE.Vector3(0.,1.,1.);
        const B339 = new THREE.Vector3(0.,0.,0.94117647058823528);
        const C339 = new THREE.Vector3(0.,0.,0.93137254901960786);

        const normalVec339 = new THREE.Vector3();
        normalVec339.crossVectors(B339.sub(A339), C339.sub(A339));
        normalVec339.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal339 = new THREE.Vector3(0,0,1);

        const quaternionRotation339 = new THREE.Quaternion();
        quaternionRotation339.setFromUnitVectors(initialNormal339, normalVec339);

        ringMesh339.setRotationFromQuaternion(quaternionRotation339);

        return quaternionRotation339;
    }

    ringRoot.add(ringMesh339);
            
	var inradius340 = calulateInradius(getVertex116(), getVertex211(), getVertex212());
	var incenter340 = calulateIncenter(getVertex116(), getVertex211(), getVertex212());
	var ringGeometry340 = new THREE.RingGeometry((inradius340 - 0.005),inradius340, 32);
	const ringMaterial340 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh340 = new THREE.Mesh(ringGeometry340, ringMaterial340);

	function setCircleRotation340(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.078431372549019662],[0.,0.,0.068627450980392135]);

        ringMesh340.position.setX(incenter[0]);
        ringMesh340.position.setY(incenter[1]);
        ringMesh340.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex211(), getVertex212());
        var relRadius = inradius/inradius340;

        ringMesh340.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A340 = new THREE.Vector3(0.,1.,0.);
        const B340 = new THREE.Vector3(0.,0.,0.078431372549019662);
        const C340 = new THREE.Vector3(0.,0.,0.068627450980392135);

        const normalVec340 = new THREE.Vector3();
        normalVec340.crossVectors(B340.sub(A340), C340.sub(A340));
        normalVec340.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal340 = new THREE.Vector3(0,0,1);

        const quaternionRotation340 = new THREE.Quaternion();
        quaternionRotation340.setFromUnitVectors(initialNormal340, normalVec340);

        ringMesh340.setRotationFromQuaternion(quaternionRotation340);

        return quaternionRotation340;
    }

    ringRoot.add(ringMesh340);
            
	var inradius341 = calulateInradius(getVertex117(), getVertex124(), getVertex125());
	var incenter341 = calulateIncenter(getVertex117(), getVertex124(), getVertex125());
	var ringGeometry341 = new THREE.RingGeometry((inradius341 - 0.005),inradius341, 32);
	const ringMaterial341 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh341 = new THREE.Mesh(ringGeometry341, ringMaterial341);

	function setCircleRotation341(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.93137254901960786],[0.,0.,0.92156862745098045]);

        ringMesh341.position.setX(incenter[0]);
        ringMesh341.position.setY(incenter[1]);
        ringMesh341.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex124(), getVertex125());
        var relRadius = inradius/inradius341;

        ringMesh341.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A341 = new THREE.Vector3(0.,1.,1.);
        const B341 = new THREE.Vector3(0.,0.,0.93137254901960786);
        const C341 = new THREE.Vector3(0.,0.,0.92156862745098045);

        const normalVec341 = new THREE.Vector3();
        normalVec341.crossVectors(B341.sub(A341), C341.sub(A341));
        normalVec341.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal341 = new THREE.Vector3(0,0,1);

        const quaternionRotation341 = new THREE.Quaternion();
        quaternionRotation341.setFromUnitVectors(initialNormal341, normalVec341);

        ringMesh341.setRotationFromQuaternion(quaternionRotation341);

        return quaternionRotation341;
    }

    ringRoot.add(ringMesh341);
            
	var inradius342 = calulateInradius(getVertex116(), getVertex210(), getVertex211());
	var incenter342 = calulateIncenter(getVertex116(), getVertex210(), getVertex211());
	var ringGeometry342 = new THREE.RingGeometry((inradius342 - 0.005),inradius342, 32);
	const ringMaterial342 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh342 = new THREE.Mesh(ringGeometry342, ringMaterial342);

	function setCircleRotation342(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.088235294117647078],[0.,0.,0.078431372549019662]);

        ringMesh342.position.setX(incenter[0]);
        ringMesh342.position.setY(incenter[1]);
        ringMesh342.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex210(), getVertex211());
        var relRadius = inradius/inradius342;

        ringMesh342.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A342 = new THREE.Vector3(0.,1.,0.);
        const B342 = new THREE.Vector3(0.,0.,0.088235294117647078);
        const C342 = new THREE.Vector3(0.,0.,0.078431372549019662);

        const normalVec342 = new THREE.Vector3();
        normalVec342.crossVectors(B342.sub(A342), C342.sub(A342));
        normalVec342.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal342 = new THREE.Vector3(0,0,1);

        const quaternionRotation342 = new THREE.Quaternion();
        quaternionRotation342.setFromUnitVectors(initialNormal342, normalVec342);

        ringMesh342.setRotationFromQuaternion(quaternionRotation342);

        return quaternionRotation342;
    }

    ringRoot.add(ringMesh342);
            
	var inradius343 = calulateInradius(getVertex117(), getVertex125(), getVertex126());
	var incenter343 = calulateIncenter(getVertex117(), getVertex125(), getVertex126());
	var ringGeometry343 = new THREE.RingGeometry((inradius343 - 0.005),inradius343, 32);
	const ringMaterial343 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh343 = new THREE.Mesh(ringGeometry343, ringMaterial343);

	function setCircleRotation343(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.92156862745098045],[0.,0.,0.91176470588235292]);

        ringMesh343.position.setX(incenter[0]);
        ringMesh343.position.setY(incenter[1]);
        ringMesh343.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex125(), getVertex126());
        var relRadius = inradius/inradius343;

        ringMesh343.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A343 = new THREE.Vector3(0.,1.,1.);
        const B343 = new THREE.Vector3(0.,0.,0.92156862745098045);
        const C343 = new THREE.Vector3(0.,0.,0.91176470588235292);

        const normalVec343 = new THREE.Vector3();
        normalVec343.crossVectors(B343.sub(A343), C343.sub(A343));
        normalVec343.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal343 = new THREE.Vector3(0,0,1);

        const quaternionRotation343 = new THREE.Quaternion();
        quaternionRotation343.setFromUnitVectors(initialNormal343, normalVec343);

        ringMesh343.setRotationFromQuaternion(quaternionRotation343);

        return quaternionRotation343;
    }

    ringRoot.add(ringMesh343);
            
	var inradius344 = calulateInradius(getVertex116(), getVertex209(), getVertex210());
	var incenter344 = calulateIncenter(getVertex116(), getVertex209(), getVertex210());
	var ringGeometry344 = new THREE.RingGeometry((inradius344 - 0.005),inradius344, 32);
	const ringMaterial344 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh344 = new THREE.Mesh(ringGeometry344, ringMaterial344);

	function setCircleRotation344(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.098039215686274495],[0.,0.,0.088235294117647078]);

        ringMesh344.position.setX(incenter[0]);
        ringMesh344.position.setY(incenter[1]);
        ringMesh344.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex209(), getVertex210());
        var relRadius = inradius/inradius344;

        ringMesh344.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A344 = new THREE.Vector3(0.,1.,0.);
        const B344 = new THREE.Vector3(0.,0.,0.098039215686274495);
        const C344 = new THREE.Vector3(0.,0.,0.088235294117647078);

        const normalVec344 = new THREE.Vector3();
        normalVec344.crossVectors(B344.sub(A344), C344.sub(A344));
        normalVec344.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal344 = new THREE.Vector3(0,0,1);

        const quaternionRotation344 = new THREE.Quaternion();
        quaternionRotation344.setFromUnitVectors(initialNormal344, normalVec344);

        ringMesh344.setRotationFromQuaternion(quaternionRotation344);

        return quaternionRotation344;
    }

    ringRoot.add(ringMesh344);
            
	var inradius345 = calulateInradius(getVertex117(), getVertex126(), getVertex127());
	var incenter345 = calulateIncenter(getVertex117(), getVertex126(), getVertex127());
	var ringGeometry345 = new THREE.RingGeometry((inradius345 - 0.005),inradius345, 32);
	const ringMaterial345 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh345 = new THREE.Mesh(ringGeometry345, ringMaterial345);

	function setCircleRotation345(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.91176470588235292],[0.,0.,0.90196078431372551]);

        ringMesh345.position.setX(incenter[0]);
        ringMesh345.position.setY(incenter[1]);
        ringMesh345.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex126(), getVertex127());
        var relRadius = inradius/inradius345;

        ringMesh345.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A345 = new THREE.Vector3(0.,1.,1.);
        const B345 = new THREE.Vector3(0.,0.,0.91176470588235292);
        const C345 = new THREE.Vector3(0.,0.,0.90196078431372551);

        const normalVec345 = new THREE.Vector3();
        normalVec345.crossVectors(B345.sub(A345), C345.sub(A345));
        normalVec345.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal345 = new THREE.Vector3(0,0,1);

        const quaternionRotation345 = new THREE.Quaternion();
        quaternionRotation345.setFromUnitVectors(initialNormal345, normalVec345);

        ringMesh345.setRotationFromQuaternion(quaternionRotation345);

        return quaternionRotation345;
    }

    ringRoot.add(ringMesh345);
            
	var inradius346 = calulateInradius(getVertex116(), getVertex208(), getVertex209());
	var incenter346 = calulateIncenter(getVertex116(), getVertex208(), getVertex209());
	var ringGeometry346 = new THREE.RingGeometry((inradius346 - 0.005),inradius346, 32);
	const ringMaterial346 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh346 = new THREE.Mesh(ringGeometry346, ringMaterial346);

	function setCircleRotation346(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.10784313725490202],[0.,0.,0.098039215686274495]);

        ringMesh346.position.setX(incenter[0]);
        ringMesh346.position.setY(incenter[1]);
        ringMesh346.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex208(), getVertex209());
        var relRadius = inradius/inradius346;

        ringMesh346.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A346 = new THREE.Vector3(0.,1.,0.);
        const B346 = new THREE.Vector3(0.,0.,0.10784313725490202);
        const C346 = new THREE.Vector3(0.,0.,0.098039215686274495);

        const normalVec346 = new THREE.Vector3();
        normalVec346.crossVectors(B346.sub(A346), C346.sub(A346));
        normalVec346.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal346 = new THREE.Vector3(0,0,1);

        const quaternionRotation346 = new THREE.Quaternion();
        quaternionRotation346.setFromUnitVectors(initialNormal346, normalVec346);

        ringMesh346.setRotationFromQuaternion(quaternionRotation346);

        return quaternionRotation346;
    }

    ringRoot.add(ringMesh346);
            
	var inradius347 = calulateInradius(getVertex117(), getVertex127(), getVertex128());
	var incenter347 = calulateIncenter(getVertex117(), getVertex127(), getVertex128());
	var ringGeometry347 = new THREE.RingGeometry((inradius347 - 0.005),inradius347, 32);
	const ringMaterial347 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh347 = new THREE.Mesh(ringGeometry347, ringMaterial347);

	function setCircleRotation347(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.90196078431372551],[0.,0.,0.89215686274509798]);

        ringMesh347.position.setX(incenter[0]);
        ringMesh347.position.setY(incenter[1]);
        ringMesh347.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex127(), getVertex128());
        var relRadius = inradius/inradius347;

        ringMesh347.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A347 = new THREE.Vector3(0.,1.,1.);
        const B347 = new THREE.Vector3(0.,0.,0.90196078431372551);
        const C347 = new THREE.Vector3(0.,0.,0.89215686274509798);

        const normalVec347 = new THREE.Vector3();
        normalVec347.crossVectors(B347.sub(A347), C347.sub(A347));
        normalVec347.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal347 = new THREE.Vector3(0,0,1);

        const quaternionRotation347 = new THREE.Quaternion();
        quaternionRotation347.setFromUnitVectors(initialNormal347, normalVec347);

        ringMesh347.setRotationFromQuaternion(quaternionRotation347);

        return quaternionRotation347;
    }

    ringRoot.add(ringMesh347);
            
	var inradius348 = calulateInradius(getVertex116(), getVertex207(), getVertex208());
	var incenter348 = calulateIncenter(getVertex116(), getVertex207(), getVertex208());
	var ringGeometry348 = new THREE.RingGeometry((inradius348 - 0.005),inradius348, 32);
	const ringMaterial348 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh348 = new THREE.Mesh(ringGeometry348, ringMaterial348);

	function setCircleRotation348(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.11764705882352944],[0.,0.,0.10784313725490202]);

        ringMesh348.position.setX(incenter[0]);
        ringMesh348.position.setY(incenter[1]);
        ringMesh348.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex207(), getVertex208());
        var relRadius = inradius/inradius348;

        ringMesh348.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A348 = new THREE.Vector3(0.,1.,0.);
        const B348 = new THREE.Vector3(0.,0.,0.11764705882352944);
        const C348 = new THREE.Vector3(0.,0.,0.10784313725490202);

        const normalVec348 = new THREE.Vector3();
        normalVec348.crossVectors(B348.sub(A348), C348.sub(A348));
        normalVec348.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal348 = new THREE.Vector3(0,0,1);

        const quaternionRotation348 = new THREE.Quaternion();
        quaternionRotation348.setFromUnitVectors(initialNormal348, normalVec348);

        ringMesh348.setRotationFromQuaternion(quaternionRotation348);

        return quaternionRotation348;
    }

    ringRoot.add(ringMesh348);
            
	var inradius349 = calulateInradius(getVertex117(), getVertex128(), getVertex129());
	var incenter349 = calulateIncenter(getVertex117(), getVertex128(), getVertex129());
	var ringGeometry349 = new THREE.RingGeometry((inradius349 - 0.005),inradius349, 32);
	const ringMaterial349 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh349 = new THREE.Mesh(ringGeometry349, ringMaterial349);

	function setCircleRotation349(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.89215686274509798],[0.,0.,0.88235294117647056]);

        ringMesh349.position.setX(incenter[0]);
        ringMesh349.position.setY(incenter[1]);
        ringMesh349.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex128(), getVertex129());
        var relRadius = inradius/inradius349;

        ringMesh349.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A349 = new THREE.Vector3(0.,1.,1.);
        const B349 = new THREE.Vector3(0.,0.,0.89215686274509798);
        const C349 = new THREE.Vector3(0.,0.,0.88235294117647056);

        const normalVec349 = new THREE.Vector3();
        normalVec349.crossVectors(B349.sub(A349), C349.sub(A349));
        normalVec349.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal349 = new THREE.Vector3(0,0,1);

        const quaternionRotation349 = new THREE.Quaternion();
        quaternionRotation349.setFromUnitVectors(initialNormal349, normalVec349);

        ringMesh349.setRotationFromQuaternion(quaternionRotation349);

        return quaternionRotation349;
    }

    ringRoot.add(ringMesh349);
            
	var inradius350 = calulateInradius(getVertex116(), getVertex206(), getVertex207());
	var incenter350 = calulateIncenter(getVertex116(), getVertex206(), getVertex207());
	var ringGeometry350 = new THREE.RingGeometry((inradius350 - 0.005),inradius350, 32);
	const ringMaterial350 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh350 = new THREE.Mesh(ringGeometry350, ringMaterial350);

	function setCircleRotation350(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.12745098039215685],[0.,0.,0.11764705882352944]);

        ringMesh350.position.setX(incenter[0]);
        ringMesh350.position.setY(incenter[1]);
        ringMesh350.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex206(), getVertex207());
        var relRadius = inradius/inradius350;

        ringMesh350.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A350 = new THREE.Vector3(0.,1.,0.);
        const B350 = new THREE.Vector3(0.,0.,0.12745098039215685);
        const C350 = new THREE.Vector3(0.,0.,0.11764705882352944);

        const normalVec350 = new THREE.Vector3();
        normalVec350.crossVectors(B350.sub(A350), C350.sub(A350));
        normalVec350.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal350 = new THREE.Vector3(0,0,1);

        const quaternionRotation350 = new THREE.Quaternion();
        quaternionRotation350.setFromUnitVectors(initialNormal350, normalVec350);

        ringMesh350.setRotationFromQuaternion(quaternionRotation350);

        return quaternionRotation350;
    }

    ringRoot.add(ringMesh350);
            
	var inradius351 = calulateInradius(getVertex117(), getVertex129(), getVertex130());
	var incenter351 = calulateIncenter(getVertex117(), getVertex129(), getVertex130());
	var ringGeometry351 = new THREE.RingGeometry((inradius351 - 0.005),inradius351, 32);
	const ringMaterial351 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh351 = new THREE.Mesh(ringGeometry351, ringMaterial351);

	function setCircleRotation351(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.88235294117647056],[0.,0.,0.87254901960784315]);

        ringMesh351.position.setX(incenter[0]);
        ringMesh351.position.setY(incenter[1]);
        ringMesh351.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex129(), getVertex130());
        var relRadius = inradius/inradius351;

        ringMesh351.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A351 = new THREE.Vector3(0.,1.,1.);
        const B351 = new THREE.Vector3(0.,0.,0.88235294117647056);
        const C351 = new THREE.Vector3(0.,0.,0.87254901960784315);

        const normalVec351 = new THREE.Vector3();
        normalVec351.crossVectors(B351.sub(A351), C351.sub(A351));
        normalVec351.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal351 = new THREE.Vector3(0,0,1);

        const quaternionRotation351 = new THREE.Quaternion();
        quaternionRotation351.setFromUnitVectors(initialNormal351, normalVec351);

        ringMesh351.setRotationFromQuaternion(quaternionRotation351);

        return quaternionRotation351;
    }

    ringRoot.add(ringMesh351);
            
	var inradius352 = calulateInradius(getVertex116(), getVertex205(), getVertex206());
	var incenter352 = calulateIncenter(getVertex116(), getVertex205(), getVertex206());
	var ringGeometry352 = new THREE.RingGeometry((inradius352 - 0.005),inradius352, 32);
	const ringMaterial352 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh352 = new THREE.Mesh(ringGeometry352, ringMaterial352);

	function setCircleRotation352(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.13725490196078427],[0.,0.,0.12745098039215685]);

        ringMesh352.position.setX(incenter[0]);
        ringMesh352.position.setY(incenter[1]);
        ringMesh352.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex205(), getVertex206());
        var relRadius = inradius/inradius352;

        ringMesh352.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A352 = new THREE.Vector3(0.,1.,0.);
        const B352 = new THREE.Vector3(0.,0.,0.13725490196078427);
        const C352 = new THREE.Vector3(0.,0.,0.12745098039215685);

        const normalVec352 = new THREE.Vector3();
        normalVec352.crossVectors(B352.sub(A352), C352.sub(A352));
        normalVec352.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal352 = new THREE.Vector3(0,0,1);

        const quaternionRotation352 = new THREE.Quaternion();
        quaternionRotation352.setFromUnitVectors(initialNormal352, normalVec352);

        ringMesh352.setRotationFromQuaternion(quaternionRotation352);

        return quaternionRotation352;
    }

    ringRoot.add(ringMesh352);
            
	var inradius353 = calulateInradius(getVertex117(), getVertex130(), getVertex131());
	var incenter353 = calulateIncenter(getVertex117(), getVertex130(), getVertex131());
	var ringGeometry353 = new THREE.RingGeometry((inradius353 - 0.005),inradius353, 32);
	const ringMaterial353 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh353 = new THREE.Mesh(ringGeometry353, ringMaterial353);

	function setCircleRotation353(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.87254901960784315],[0.,0.,0.86274509803921573]);

        ringMesh353.position.setX(incenter[0]);
        ringMesh353.position.setY(incenter[1]);
        ringMesh353.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex130(), getVertex131());
        var relRadius = inradius/inradius353;

        ringMesh353.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A353 = new THREE.Vector3(0.,1.,1.);
        const B353 = new THREE.Vector3(0.,0.,0.87254901960784315);
        const C353 = new THREE.Vector3(0.,0.,0.86274509803921573);

        const normalVec353 = new THREE.Vector3();
        normalVec353.crossVectors(B353.sub(A353), C353.sub(A353));
        normalVec353.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal353 = new THREE.Vector3(0,0,1);

        const quaternionRotation353 = new THREE.Quaternion();
        quaternionRotation353.setFromUnitVectors(initialNormal353, normalVec353);

        ringMesh353.setRotationFromQuaternion(quaternionRotation353);

        return quaternionRotation353;
    }

    ringRoot.add(ringMesh353);
            
	var inradius354 = calulateInradius(getVertex116(), getVertex204(), getVertex205());
	var incenter354 = calulateIncenter(getVertex116(), getVertex204(), getVertex205());
	var ringGeometry354 = new THREE.RingGeometry((inradius354 - 0.005),inradius354, 32);
	const ringMaterial354 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh354 = new THREE.Mesh(ringGeometry354, ringMaterial354);

	function setCircleRotation354(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.1470588235294118],[0.,0.,0.13725490196078427]);

        ringMesh354.position.setX(incenter[0]);
        ringMesh354.position.setY(incenter[1]);
        ringMesh354.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex204(), getVertex205());
        var relRadius = inradius/inradius354;

        ringMesh354.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A354 = new THREE.Vector3(0.,1.,0.);
        const B354 = new THREE.Vector3(0.,0.,0.1470588235294118);
        const C354 = new THREE.Vector3(0.,0.,0.13725490196078427);

        const normalVec354 = new THREE.Vector3();
        normalVec354.crossVectors(B354.sub(A354), C354.sub(A354));
        normalVec354.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal354 = new THREE.Vector3(0,0,1);

        const quaternionRotation354 = new THREE.Quaternion();
        quaternionRotation354.setFromUnitVectors(initialNormal354, normalVec354);

        ringMesh354.setRotationFromQuaternion(quaternionRotation354);

        return quaternionRotation354;
    }

    ringRoot.add(ringMesh354);
            
	var inradius355 = calulateInradius(getVertex117(), getVertex131(), getVertex132());
	var incenter355 = calulateIncenter(getVertex117(), getVertex131(), getVertex132());
	var ringGeometry355 = new THREE.RingGeometry((inradius355 - 0.005),inradius355, 32);
	const ringMaterial355 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh355 = new THREE.Mesh(ringGeometry355, ringMaterial355);

	function setCircleRotation355(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.86274509803921573],[0.,0.,0.8529411764705882]);

        ringMesh355.position.setX(incenter[0]);
        ringMesh355.position.setY(incenter[1]);
        ringMesh355.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex131(), getVertex132());
        var relRadius = inradius/inradius355;

        ringMesh355.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A355 = new THREE.Vector3(0.,1.,1.);
        const B355 = new THREE.Vector3(0.,0.,0.86274509803921573);
        const C355 = new THREE.Vector3(0.,0.,0.8529411764705882);

        const normalVec355 = new THREE.Vector3();
        normalVec355.crossVectors(B355.sub(A355), C355.sub(A355));
        normalVec355.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal355 = new THREE.Vector3(0,0,1);

        const quaternionRotation355 = new THREE.Quaternion();
        quaternionRotation355.setFromUnitVectors(initialNormal355, normalVec355);

        ringMesh355.setRotationFromQuaternion(quaternionRotation355);

        return quaternionRotation355;
    }

    ringRoot.add(ringMesh355);
            
	var inradius356 = calulateInradius(getVertex116(), getVertex203(), getVertex204());
	var incenter356 = calulateIncenter(getVertex116(), getVertex203(), getVertex204());
	var ringGeometry356 = new THREE.RingGeometry((inradius356 - 0.005),inradius356, 32);
	const ringMaterial356 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh356 = new THREE.Mesh(ringGeometry356, ringMaterial356);

	function setCircleRotation356(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.15686274509803921],[0.,0.,0.1470588235294118]);

        ringMesh356.position.setX(incenter[0]);
        ringMesh356.position.setY(incenter[1]);
        ringMesh356.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex203(), getVertex204());
        var relRadius = inradius/inradius356;

        ringMesh356.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A356 = new THREE.Vector3(0.,1.,0.);
        const B356 = new THREE.Vector3(0.,0.,0.15686274509803921);
        const C356 = new THREE.Vector3(0.,0.,0.1470588235294118);

        const normalVec356 = new THREE.Vector3();
        normalVec356.crossVectors(B356.sub(A356), C356.sub(A356));
        normalVec356.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal356 = new THREE.Vector3(0,0,1);

        const quaternionRotation356 = new THREE.Quaternion();
        quaternionRotation356.setFromUnitVectors(initialNormal356, normalVec356);

        ringMesh356.setRotationFromQuaternion(quaternionRotation356);

        return quaternionRotation356;
    }

    ringRoot.add(ringMesh356);
            
	var inradius357 = calulateInradius(getVertex117(), getVertex132(), getVertex133());
	var incenter357 = calulateIncenter(getVertex117(), getVertex132(), getVertex133());
	var ringGeometry357 = new THREE.RingGeometry((inradius357 - 0.005),inradius357, 32);
	const ringMaterial357 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh357 = new THREE.Mesh(ringGeometry357, ringMaterial357);

	function setCircleRotation357(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.8529411764705882],[0.,0.,0.84313725490196079]);

        ringMesh357.position.setX(incenter[0]);
        ringMesh357.position.setY(incenter[1]);
        ringMesh357.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex132(), getVertex133());
        var relRadius = inradius/inradius357;

        ringMesh357.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A357 = new THREE.Vector3(0.,1.,1.);
        const B357 = new THREE.Vector3(0.,0.,0.8529411764705882);
        const C357 = new THREE.Vector3(0.,0.,0.84313725490196079);

        const normalVec357 = new THREE.Vector3();
        normalVec357.crossVectors(B357.sub(A357), C357.sub(A357));
        normalVec357.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal357 = new THREE.Vector3(0,0,1);

        const quaternionRotation357 = new THREE.Quaternion();
        quaternionRotation357.setFromUnitVectors(initialNormal357, normalVec357);

        ringMesh357.setRotationFromQuaternion(quaternionRotation357);

        return quaternionRotation357;
    }

    ringRoot.add(ringMesh357);
            
	var inradius358 = calulateInradius(getVertex116(), getVertex202(), getVertex203());
	var incenter358 = calulateIncenter(getVertex116(), getVertex202(), getVertex203());
	var ringGeometry358 = new THREE.RingGeometry((inradius358 - 0.005),inradius358, 32);
	const ringMaterial358 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh358 = new THREE.Mesh(ringGeometry358, ringMaterial358);

	function setCircleRotation358(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.16666666666666663],[0.,0.,0.15686274509803921]);

        ringMesh358.position.setX(incenter[0]);
        ringMesh358.position.setY(incenter[1]);
        ringMesh358.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex202(), getVertex203());
        var relRadius = inradius/inradius358;

        ringMesh358.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A358 = new THREE.Vector3(0.,1.,0.);
        const B358 = new THREE.Vector3(0.,0.,0.16666666666666663);
        const C358 = new THREE.Vector3(0.,0.,0.15686274509803921);

        const normalVec358 = new THREE.Vector3();
        normalVec358.crossVectors(B358.sub(A358), C358.sub(A358));
        normalVec358.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal358 = new THREE.Vector3(0,0,1);

        const quaternionRotation358 = new THREE.Quaternion();
        quaternionRotation358.setFromUnitVectors(initialNormal358, normalVec358);

        ringMesh358.setRotationFromQuaternion(quaternionRotation358);

        return quaternionRotation358;
    }

    ringRoot.add(ringMesh358);
            
	var inradius359 = calulateInradius(getVertex117(), getVertex133(), getVertex134());
	var incenter359 = calulateIncenter(getVertex117(), getVertex133(), getVertex134());
	var ringGeometry359 = new THREE.RingGeometry((inradius359 - 0.005),inradius359, 32);
	const ringMaterial359 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh359 = new THREE.Mesh(ringGeometry359, ringMaterial359);

	function setCircleRotation359(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.84313725490196079],[0.,0.,0.83333333333333337]);

        ringMesh359.position.setX(incenter[0]);
        ringMesh359.position.setY(incenter[1]);
        ringMesh359.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex133(), getVertex134());
        var relRadius = inradius/inradius359;

        ringMesh359.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A359 = new THREE.Vector3(0.,1.,1.);
        const B359 = new THREE.Vector3(0.,0.,0.84313725490196079);
        const C359 = new THREE.Vector3(0.,0.,0.83333333333333337);

        const normalVec359 = new THREE.Vector3();
        normalVec359.crossVectors(B359.sub(A359), C359.sub(A359));
        normalVec359.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal359 = new THREE.Vector3(0,0,1);

        const quaternionRotation359 = new THREE.Quaternion();
        quaternionRotation359.setFromUnitVectors(initialNormal359, normalVec359);

        ringMesh359.setRotationFromQuaternion(quaternionRotation359);

        return quaternionRotation359;
    }

    ringRoot.add(ringMesh359);
            
	var inradius360 = calulateInradius(getVertex116(), getVertex201(), getVertex202());
	var incenter360 = calulateIncenter(getVertex116(), getVertex201(), getVertex202());
	var ringGeometry360 = new THREE.RingGeometry((inradius360 - 0.005),inradius360, 32);
	const ringMaterial360 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh360 = new THREE.Mesh(ringGeometry360, ringMaterial360);

	function setCircleRotation360(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.17647058823529416],[0.,0.,0.16666666666666663]);

        ringMesh360.position.setX(incenter[0]);
        ringMesh360.position.setY(incenter[1]);
        ringMesh360.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex201(), getVertex202());
        var relRadius = inradius/inradius360;

        ringMesh360.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A360 = new THREE.Vector3(0.,1.,0.);
        const B360 = new THREE.Vector3(0.,0.,0.17647058823529416);
        const C360 = new THREE.Vector3(0.,0.,0.16666666666666663);

        const normalVec360 = new THREE.Vector3();
        normalVec360.crossVectors(B360.sub(A360), C360.sub(A360));
        normalVec360.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal360 = new THREE.Vector3(0,0,1);

        const quaternionRotation360 = new THREE.Quaternion();
        quaternionRotation360.setFromUnitVectors(initialNormal360, normalVec360);

        ringMesh360.setRotationFromQuaternion(quaternionRotation360);

        return quaternionRotation360;
    }

    ringRoot.add(ringMesh360);
            
	var inradius361 = calulateInradius(getVertex117(), getVertex134(), getVertex135());
	var incenter361 = calulateIncenter(getVertex117(), getVertex134(), getVertex135());
	var ringGeometry361 = new THREE.RingGeometry((inradius361 - 0.005),inradius361, 32);
	const ringMaterial361 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh361 = new THREE.Mesh(ringGeometry361, ringMaterial361);

	function setCircleRotation361(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.83333333333333337],[0.,0.,0.82352941176470584]);

        ringMesh361.position.setX(incenter[0]);
        ringMesh361.position.setY(incenter[1]);
        ringMesh361.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex134(), getVertex135());
        var relRadius = inradius/inradius361;

        ringMesh361.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A361 = new THREE.Vector3(0.,1.,1.);
        const B361 = new THREE.Vector3(0.,0.,0.83333333333333337);
        const C361 = new THREE.Vector3(0.,0.,0.82352941176470584);

        const normalVec361 = new THREE.Vector3();
        normalVec361.crossVectors(B361.sub(A361), C361.sub(A361));
        normalVec361.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal361 = new THREE.Vector3(0,0,1);

        const quaternionRotation361 = new THREE.Quaternion();
        quaternionRotation361.setFromUnitVectors(initialNormal361, normalVec361);

        ringMesh361.setRotationFromQuaternion(quaternionRotation361);

        return quaternionRotation361;
    }

    ringRoot.add(ringMesh361);
            
	var inradius362 = calulateInradius(getVertex116(), getVertex200(), getVertex201());
	var incenter362 = calulateIncenter(getVertex116(), getVertex200(), getVertex201());
	var ringGeometry362 = new THREE.RingGeometry((inradius362 - 0.005),inradius362, 32);
	const ringMaterial362 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh362 = new THREE.Mesh(ringGeometry362, ringMaterial362);

	function setCircleRotation362(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.18627450980392157],[0.,0.,0.17647058823529416]);

        ringMesh362.position.setX(incenter[0]);
        ringMesh362.position.setY(incenter[1]);
        ringMesh362.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex200(), getVertex201());
        var relRadius = inradius/inradius362;

        ringMesh362.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A362 = new THREE.Vector3(0.,1.,0.);
        const B362 = new THREE.Vector3(0.,0.,0.18627450980392157);
        const C362 = new THREE.Vector3(0.,0.,0.17647058823529416);

        const normalVec362 = new THREE.Vector3();
        normalVec362.crossVectors(B362.sub(A362), C362.sub(A362));
        normalVec362.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal362 = new THREE.Vector3(0,0,1);

        const quaternionRotation362 = new THREE.Quaternion();
        quaternionRotation362.setFromUnitVectors(initialNormal362, normalVec362);

        ringMesh362.setRotationFromQuaternion(quaternionRotation362);

        return quaternionRotation362;
    }

    ringRoot.add(ringMesh362);
            
	var inradius363 = calulateInradius(getVertex117(), getVertex135(), getVertex136());
	var incenter363 = calulateIncenter(getVertex117(), getVertex135(), getVertex136());
	var ringGeometry363 = new THREE.RingGeometry((inradius363 - 0.005),inradius363, 32);
	const ringMaterial363 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh363 = new THREE.Mesh(ringGeometry363, ringMaterial363);

	function setCircleRotation363(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.82352941176470584],[0.,0.,0.81372549019607843]);

        ringMesh363.position.setX(incenter[0]);
        ringMesh363.position.setY(incenter[1]);
        ringMesh363.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex135(), getVertex136());
        var relRadius = inradius/inradius363;

        ringMesh363.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A363 = new THREE.Vector3(0.,1.,1.);
        const B363 = new THREE.Vector3(0.,0.,0.82352941176470584);
        const C363 = new THREE.Vector3(0.,0.,0.81372549019607843);

        const normalVec363 = new THREE.Vector3();
        normalVec363.crossVectors(B363.sub(A363), C363.sub(A363));
        normalVec363.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal363 = new THREE.Vector3(0,0,1);

        const quaternionRotation363 = new THREE.Quaternion();
        quaternionRotation363.setFromUnitVectors(initialNormal363, normalVec363);

        ringMesh363.setRotationFromQuaternion(quaternionRotation363);

        return quaternionRotation363;
    }

    ringRoot.add(ringMesh363);
            
	var inradius364 = calulateInradius(getVertex116(), getVertex199(), getVertex200());
	var incenter364 = calulateIncenter(getVertex116(), getVertex199(), getVertex200());
	var ringGeometry364 = new THREE.RingGeometry((inradius364 - 0.005),inradius364, 32);
	const ringMaterial364 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh364 = new THREE.Mesh(ringGeometry364, ringMaterial364);

	function setCircleRotation364(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.19607843137254899],[0.,0.,0.18627450980392157]);

        ringMesh364.position.setX(incenter[0]);
        ringMesh364.position.setY(incenter[1]);
        ringMesh364.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex199(), getVertex200());
        var relRadius = inradius/inradius364;

        ringMesh364.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A364 = new THREE.Vector3(0.,1.,0.);
        const B364 = new THREE.Vector3(0.,0.,0.19607843137254899);
        const C364 = new THREE.Vector3(0.,0.,0.18627450980392157);

        const normalVec364 = new THREE.Vector3();
        normalVec364.crossVectors(B364.sub(A364), C364.sub(A364));
        normalVec364.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal364 = new THREE.Vector3(0,0,1);

        const quaternionRotation364 = new THREE.Quaternion();
        quaternionRotation364.setFromUnitVectors(initialNormal364, normalVec364);

        ringMesh364.setRotationFromQuaternion(quaternionRotation364);

        return quaternionRotation364;
    }

    ringRoot.add(ringMesh364);
            
	var inradius365 = calulateInradius(getVertex117(), getVertex136(), getVertex137());
	var incenter365 = calulateIncenter(getVertex117(), getVertex136(), getVertex137());
	var ringGeometry365 = new THREE.RingGeometry((inradius365 - 0.005),inradius365, 32);
	const ringMaterial365 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh365 = new THREE.Mesh(ringGeometry365, ringMaterial365);

	function setCircleRotation365(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.81372549019607843],[0.,0.,0.80392156862745101]);

        ringMesh365.position.setX(incenter[0]);
        ringMesh365.position.setY(incenter[1]);
        ringMesh365.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex136(), getVertex137());
        var relRadius = inradius/inradius365;

        ringMesh365.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A365 = new THREE.Vector3(0.,1.,1.);
        const B365 = new THREE.Vector3(0.,0.,0.81372549019607843);
        const C365 = new THREE.Vector3(0.,0.,0.80392156862745101);

        const normalVec365 = new THREE.Vector3();
        normalVec365.crossVectors(B365.sub(A365), C365.sub(A365));
        normalVec365.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal365 = new THREE.Vector3(0,0,1);

        const quaternionRotation365 = new THREE.Quaternion();
        quaternionRotation365.setFromUnitVectors(initialNormal365, normalVec365);

        ringMesh365.setRotationFromQuaternion(quaternionRotation365);

        return quaternionRotation365;
    }

    ringRoot.add(ringMesh365);
            
	var inradius366 = calulateInradius(getVertex116(), getVertex198(), getVertex199());
	var incenter366 = calulateIncenter(getVertex116(), getVertex198(), getVertex199());
	var ringGeometry366 = new THREE.RingGeometry((inradius366 - 0.005),inradius366, 32);
	const ringMaterial366 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh366 = new THREE.Mesh(ringGeometry366, ringMaterial366);

	function setCircleRotation366(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.20588235294117652],[0.,0.,0.19607843137254899]);

        ringMesh366.position.setX(incenter[0]);
        ringMesh366.position.setY(incenter[1]);
        ringMesh366.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex198(), getVertex199());
        var relRadius = inradius/inradius366;

        ringMesh366.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A366 = new THREE.Vector3(0.,1.,0.);
        const B366 = new THREE.Vector3(0.,0.,0.20588235294117652);
        const C366 = new THREE.Vector3(0.,0.,0.19607843137254899);

        const normalVec366 = new THREE.Vector3();
        normalVec366.crossVectors(B366.sub(A366), C366.sub(A366));
        normalVec366.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal366 = new THREE.Vector3(0,0,1);

        const quaternionRotation366 = new THREE.Quaternion();
        quaternionRotation366.setFromUnitVectors(initialNormal366, normalVec366);

        ringMesh366.setRotationFromQuaternion(quaternionRotation366);

        return quaternionRotation366;
    }

    ringRoot.add(ringMesh366);
            
	var inradius367 = calulateInradius(getVertex117(), getVertex137(), getVertex138());
	var incenter367 = calulateIncenter(getVertex117(), getVertex137(), getVertex138());
	var ringGeometry367 = new THREE.RingGeometry((inradius367 - 0.005),inradius367, 32);
	const ringMaterial367 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh367 = new THREE.Mesh(ringGeometry367, ringMaterial367);

	function setCircleRotation367(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.80392156862745101],[0.,0.,0.79411764705882359]);

        ringMesh367.position.setX(incenter[0]);
        ringMesh367.position.setY(incenter[1]);
        ringMesh367.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex137(), getVertex138());
        var relRadius = inradius/inradius367;

        ringMesh367.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A367 = new THREE.Vector3(0.,1.,1.);
        const B367 = new THREE.Vector3(0.,0.,0.80392156862745101);
        const C367 = new THREE.Vector3(0.,0.,0.79411764705882359);

        const normalVec367 = new THREE.Vector3();
        normalVec367.crossVectors(B367.sub(A367), C367.sub(A367));
        normalVec367.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal367 = new THREE.Vector3(0,0,1);

        const quaternionRotation367 = new THREE.Quaternion();
        quaternionRotation367.setFromUnitVectors(initialNormal367, normalVec367);

        ringMesh367.setRotationFromQuaternion(quaternionRotation367);

        return quaternionRotation367;
    }

    ringRoot.add(ringMesh367);
            
	var inradius368 = calulateInradius(getVertex116(), getVertex197(), getVertex198());
	var incenter368 = calulateIncenter(getVertex116(), getVertex197(), getVertex198());
	var ringGeometry368 = new THREE.RingGeometry((inradius368 - 0.005),inradius368, 32);
	const ringMaterial368 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh368 = new THREE.Mesh(ringGeometry368, ringMaterial368);

	function setCircleRotation368(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.21568627450980393],[0.,0.,0.20588235294117652]);

        ringMesh368.position.setX(incenter[0]);
        ringMesh368.position.setY(incenter[1]);
        ringMesh368.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex197(), getVertex198());
        var relRadius = inradius/inradius368;

        ringMesh368.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A368 = new THREE.Vector3(0.,1.,0.);
        const B368 = new THREE.Vector3(0.,0.,0.21568627450980393);
        const C368 = new THREE.Vector3(0.,0.,0.20588235294117652);

        const normalVec368 = new THREE.Vector3();
        normalVec368.crossVectors(B368.sub(A368), C368.sub(A368));
        normalVec368.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal368 = new THREE.Vector3(0,0,1);

        const quaternionRotation368 = new THREE.Quaternion();
        quaternionRotation368.setFromUnitVectors(initialNormal368, normalVec368);

        ringMesh368.setRotationFromQuaternion(quaternionRotation368);

        return quaternionRotation368;
    }

    ringRoot.add(ringMesh368);
            
	var inradius369 = calulateInradius(getVertex117(), getVertex138(), getVertex139());
	var incenter369 = calulateIncenter(getVertex117(), getVertex138(), getVertex139());
	var ringGeometry369 = new THREE.RingGeometry((inradius369 - 0.005),inradius369, 32);
	const ringMaterial369 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh369 = new THREE.Mesh(ringGeometry369, ringMaterial369);

	function setCircleRotation369(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.79411764705882359],[0.,0.,0.78431372549019607]);

        ringMesh369.position.setX(incenter[0]);
        ringMesh369.position.setY(incenter[1]);
        ringMesh369.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex138(), getVertex139());
        var relRadius = inradius/inradius369;

        ringMesh369.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A369 = new THREE.Vector3(0.,1.,1.);
        const B369 = new THREE.Vector3(0.,0.,0.79411764705882359);
        const C369 = new THREE.Vector3(0.,0.,0.78431372549019607);

        const normalVec369 = new THREE.Vector3();
        normalVec369.crossVectors(B369.sub(A369), C369.sub(A369));
        normalVec369.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal369 = new THREE.Vector3(0,0,1);

        const quaternionRotation369 = new THREE.Quaternion();
        quaternionRotation369.setFromUnitVectors(initialNormal369, normalVec369);

        ringMesh369.setRotationFromQuaternion(quaternionRotation369);

        return quaternionRotation369;
    }

    ringRoot.add(ringMesh369);
            
	var inradius370 = calulateInradius(getVertex116(), getVertex196(), getVertex197());
	var incenter370 = calulateIncenter(getVertex116(), getVertex196(), getVertex197());
	var ringGeometry370 = new THREE.RingGeometry((inradius370 - 0.005),inradius370, 32);
	const ringMaterial370 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh370 = new THREE.Mesh(ringGeometry370, ringMaterial370);

	function setCircleRotation370(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.22549019607843135],[0.,0.,0.21568627450980393]);

        ringMesh370.position.setX(incenter[0]);
        ringMesh370.position.setY(incenter[1]);
        ringMesh370.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex196(), getVertex197());
        var relRadius = inradius/inradius370;

        ringMesh370.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A370 = new THREE.Vector3(0.,1.,0.);
        const B370 = new THREE.Vector3(0.,0.,0.22549019607843135);
        const C370 = new THREE.Vector3(0.,0.,0.21568627450980393);

        const normalVec370 = new THREE.Vector3();
        normalVec370.crossVectors(B370.sub(A370), C370.sub(A370));
        normalVec370.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal370 = new THREE.Vector3(0,0,1);

        const quaternionRotation370 = new THREE.Quaternion();
        quaternionRotation370.setFromUnitVectors(initialNormal370, normalVec370);

        ringMesh370.setRotationFromQuaternion(quaternionRotation370);

        return quaternionRotation370;
    }

    ringRoot.add(ringMesh370);
            
	var inradius371 = calulateInradius(getVertex117(), getVertex139(), getVertex140());
	var incenter371 = calulateIncenter(getVertex117(), getVertex139(), getVertex140());
	var ringGeometry371 = new THREE.RingGeometry((inradius371 - 0.005),inradius371, 32);
	const ringMaterial371 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh371 = new THREE.Mesh(ringGeometry371, ringMaterial371);

	function setCircleRotation371(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.78431372549019607],[0.,0.,0.77450980392156865]);

        ringMesh371.position.setX(incenter[0]);
        ringMesh371.position.setY(incenter[1]);
        ringMesh371.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex139(), getVertex140());
        var relRadius = inradius/inradius371;

        ringMesh371.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A371 = new THREE.Vector3(0.,1.,1.);
        const B371 = new THREE.Vector3(0.,0.,0.78431372549019607);
        const C371 = new THREE.Vector3(0.,0.,0.77450980392156865);

        const normalVec371 = new THREE.Vector3();
        normalVec371.crossVectors(B371.sub(A371), C371.sub(A371));
        normalVec371.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal371 = new THREE.Vector3(0,0,1);

        const quaternionRotation371 = new THREE.Quaternion();
        quaternionRotation371.setFromUnitVectors(initialNormal371, normalVec371);

        ringMesh371.setRotationFromQuaternion(quaternionRotation371);

        return quaternionRotation371;
    }

    ringRoot.add(ringMesh371);
            
	var inradius372 = calulateInradius(getVertex116(), getVertex195(), getVertex196());
	var incenter372 = calulateIncenter(getVertex116(), getVertex195(), getVertex196());
	var ringGeometry372 = new THREE.RingGeometry((inradius372 - 0.005),inradius372, 32);
	const ringMaterial372 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh372 = new THREE.Mesh(ringGeometry372, ringMaterial372);

	function setCircleRotation372(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.23529411764705888],[0.,0.,0.22549019607843135]);

        ringMesh372.position.setX(incenter[0]);
        ringMesh372.position.setY(incenter[1]);
        ringMesh372.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex195(), getVertex196());
        var relRadius = inradius/inradius372;

        ringMesh372.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A372 = new THREE.Vector3(0.,1.,0.);
        const B372 = new THREE.Vector3(0.,0.,0.23529411764705888);
        const C372 = new THREE.Vector3(0.,0.,0.22549019607843135);

        const normalVec372 = new THREE.Vector3();
        normalVec372.crossVectors(B372.sub(A372), C372.sub(A372));
        normalVec372.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal372 = new THREE.Vector3(0,0,1);

        const quaternionRotation372 = new THREE.Quaternion();
        quaternionRotation372.setFromUnitVectors(initialNormal372, normalVec372);

        ringMesh372.setRotationFromQuaternion(quaternionRotation372);

        return quaternionRotation372;
    }

    ringRoot.add(ringMesh372);
            
	var inradius373 = calulateInradius(getVertex117(), getVertex140(), getVertex141());
	var incenter373 = calulateIncenter(getVertex117(), getVertex140(), getVertex141());
	var ringGeometry373 = new THREE.RingGeometry((inradius373 - 0.005),inradius373, 32);
	const ringMaterial373 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh373 = new THREE.Mesh(ringGeometry373, ringMaterial373);

	function setCircleRotation373(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.77450980392156865],[0.,0.,0.76470588235294112]);

        ringMesh373.position.setX(incenter[0]);
        ringMesh373.position.setY(incenter[1]);
        ringMesh373.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex140(), getVertex141());
        var relRadius = inradius/inradius373;

        ringMesh373.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A373 = new THREE.Vector3(0.,1.,1.);
        const B373 = new THREE.Vector3(0.,0.,0.77450980392156865);
        const C373 = new THREE.Vector3(0.,0.,0.76470588235294112);

        const normalVec373 = new THREE.Vector3();
        normalVec373.crossVectors(B373.sub(A373), C373.sub(A373));
        normalVec373.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal373 = new THREE.Vector3(0,0,1);

        const quaternionRotation373 = new THREE.Quaternion();
        quaternionRotation373.setFromUnitVectors(initialNormal373, normalVec373);

        ringMesh373.setRotationFromQuaternion(quaternionRotation373);

        return quaternionRotation373;
    }

    ringRoot.add(ringMesh373);
            
	var inradius374 = calulateInradius(getVertex116(), getVertex194(), getVertex195());
	var incenter374 = calulateIncenter(getVertex116(), getVertex194(), getVertex195());
	var ringGeometry374 = new THREE.RingGeometry((inradius374 - 0.005),inradius374, 32);
	const ringMaterial374 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh374 = new THREE.Mesh(ringGeometry374, ringMaterial374);

	function setCircleRotation374(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.24509803921568629],[0.,0.,0.23529411764705888]);

        ringMesh374.position.setX(incenter[0]);
        ringMesh374.position.setY(incenter[1]);
        ringMesh374.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex194(), getVertex195());
        var relRadius = inradius/inradius374;

        ringMesh374.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A374 = new THREE.Vector3(0.,1.,0.);
        const B374 = new THREE.Vector3(0.,0.,0.24509803921568629);
        const C374 = new THREE.Vector3(0.,0.,0.23529411764705888);

        const normalVec374 = new THREE.Vector3();
        normalVec374.crossVectors(B374.sub(A374), C374.sub(A374));
        normalVec374.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal374 = new THREE.Vector3(0,0,1);

        const quaternionRotation374 = new THREE.Quaternion();
        quaternionRotation374.setFromUnitVectors(initialNormal374, normalVec374);

        ringMesh374.setRotationFromQuaternion(quaternionRotation374);

        return quaternionRotation374;
    }

    ringRoot.add(ringMesh374);
            
	var inradius375 = calulateInradius(getVertex117(), getVertex141(), getVertex142());
	var incenter375 = calulateIncenter(getVertex117(), getVertex141(), getVertex142());
	var ringGeometry375 = new THREE.RingGeometry((inradius375 - 0.005),inradius375, 32);
	const ringMaterial375 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh375 = new THREE.Mesh(ringGeometry375, ringMaterial375);

	function setCircleRotation375(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.76470588235294112],[0.,0.,0.75490196078431371]);

        ringMesh375.position.setX(incenter[0]);
        ringMesh375.position.setY(incenter[1]);
        ringMesh375.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex141(), getVertex142());
        var relRadius = inradius/inradius375;

        ringMesh375.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A375 = new THREE.Vector3(0.,1.,1.);
        const B375 = new THREE.Vector3(0.,0.,0.76470588235294112);
        const C375 = new THREE.Vector3(0.,0.,0.75490196078431371);

        const normalVec375 = new THREE.Vector3();
        normalVec375.crossVectors(B375.sub(A375), C375.sub(A375));
        normalVec375.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal375 = new THREE.Vector3(0,0,1);

        const quaternionRotation375 = new THREE.Quaternion();
        quaternionRotation375.setFromUnitVectors(initialNormal375, normalVec375);

        ringMesh375.setRotationFromQuaternion(quaternionRotation375);

        return quaternionRotation375;
    }

    ringRoot.add(ringMesh375);
            
	var inradius376 = calulateInradius(getVertex116(), getVertex193(), getVertex194());
	var incenter376 = calulateIncenter(getVertex116(), getVertex193(), getVertex194());
	var ringGeometry376 = new THREE.RingGeometry((inradius376 - 0.005),inradius376, 32);
	const ringMaterial376 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh376 = new THREE.Mesh(ringGeometry376, ringMaterial376);

	function setCircleRotation376(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.25490196078431371],[0.,0.,0.24509803921568629]);

        ringMesh376.position.setX(incenter[0]);
        ringMesh376.position.setY(incenter[1]);
        ringMesh376.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex193(), getVertex194());
        var relRadius = inradius/inradius376;

        ringMesh376.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A376 = new THREE.Vector3(0.,1.,0.);
        const B376 = new THREE.Vector3(0.,0.,0.25490196078431371);
        const C376 = new THREE.Vector3(0.,0.,0.24509803921568629);

        const normalVec376 = new THREE.Vector3();
        normalVec376.crossVectors(B376.sub(A376), C376.sub(A376));
        normalVec376.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal376 = new THREE.Vector3(0,0,1);

        const quaternionRotation376 = new THREE.Quaternion();
        quaternionRotation376.setFromUnitVectors(initialNormal376, normalVec376);

        ringMesh376.setRotationFromQuaternion(quaternionRotation376);

        return quaternionRotation376;
    }

    ringRoot.add(ringMesh376);
            
	var inradius377 = calulateInradius(getVertex117(), getVertex142(), getVertex143());
	var incenter377 = calulateIncenter(getVertex117(), getVertex142(), getVertex143());
	var ringGeometry377 = new THREE.RingGeometry((inradius377 - 0.005),inradius377, 32);
	const ringMaterial377 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh377 = new THREE.Mesh(ringGeometry377, ringMaterial377);

	function setCircleRotation377(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.75490196078431371],[0.,0.,0.74509803921568629]);

        ringMesh377.position.setX(incenter[0]);
        ringMesh377.position.setY(incenter[1]);
        ringMesh377.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex142(), getVertex143());
        var relRadius = inradius/inradius377;

        ringMesh377.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A377 = new THREE.Vector3(0.,1.,1.);
        const B377 = new THREE.Vector3(0.,0.,0.75490196078431371);
        const C377 = new THREE.Vector3(0.,0.,0.74509803921568629);

        const normalVec377 = new THREE.Vector3();
        normalVec377.crossVectors(B377.sub(A377), C377.sub(A377));
        normalVec377.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal377 = new THREE.Vector3(0,0,1);

        const quaternionRotation377 = new THREE.Quaternion();
        quaternionRotation377.setFromUnitVectors(initialNormal377, normalVec377);

        ringMesh377.setRotationFromQuaternion(quaternionRotation377);

        return quaternionRotation377;
    }

    ringRoot.add(ringMesh377);
            
	var inradius378 = calulateInradius(getVertex116(), getVertex192(), getVertex193());
	var incenter378 = calulateIncenter(getVertex116(), getVertex192(), getVertex193());
	var ringGeometry378 = new THREE.RingGeometry((inradius378 - 0.005),inradius378, 32);
	const ringMaterial378 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh378 = new THREE.Mesh(ringGeometry378, ringMaterial378);

	function setCircleRotation378(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.26470588235294124],[0.,0.,0.25490196078431371]);

        ringMesh378.position.setX(incenter[0]);
        ringMesh378.position.setY(incenter[1]);
        ringMesh378.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex192(), getVertex193());
        var relRadius = inradius/inradius378;

        ringMesh378.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A378 = new THREE.Vector3(0.,1.,0.);
        const B378 = new THREE.Vector3(0.,0.,0.26470588235294124);
        const C378 = new THREE.Vector3(0.,0.,0.25490196078431371);

        const normalVec378 = new THREE.Vector3();
        normalVec378.crossVectors(B378.sub(A378), C378.sub(A378));
        normalVec378.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal378 = new THREE.Vector3(0,0,1);

        const quaternionRotation378 = new THREE.Quaternion();
        quaternionRotation378.setFromUnitVectors(initialNormal378, normalVec378);

        ringMesh378.setRotationFromQuaternion(quaternionRotation378);

        return quaternionRotation378;
    }

    ringRoot.add(ringMesh378);
            
	var inradius379 = calulateInradius(getVertex117(), getVertex143(), getVertex144());
	var incenter379 = calulateIncenter(getVertex117(), getVertex143(), getVertex144());
	var ringGeometry379 = new THREE.RingGeometry((inradius379 - 0.005),inradius379, 32);
	const ringMaterial379 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh379 = new THREE.Mesh(ringGeometry379, ringMaterial379);

	function setCircleRotation379(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.74509803921568629],[0.,0.,0.73529411764705888]);

        ringMesh379.position.setX(incenter[0]);
        ringMesh379.position.setY(incenter[1]);
        ringMesh379.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex143(), getVertex144());
        var relRadius = inradius/inradius379;

        ringMesh379.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A379 = new THREE.Vector3(0.,1.,1.);
        const B379 = new THREE.Vector3(0.,0.,0.74509803921568629);
        const C379 = new THREE.Vector3(0.,0.,0.73529411764705888);

        const normalVec379 = new THREE.Vector3();
        normalVec379.crossVectors(B379.sub(A379), C379.sub(A379));
        normalVec379.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal379 = new THREE.Vector3(0,0,1);

        const quaternionRotation379 = new THREE.Quaternion();
        quaternionRotation379.setFromUnitVectors(initialNormal379, normalVec379);

        ringMesh379.setRotationFromQuaternion(quaternionRotation379);

        return quaternionRotation379;
    }

    ringRoot.add(ringMesh379);
            
	var inradius380 = calulateInradius(getVertex116(), getVertex191(), getVertex192());
	var incenter380 = calulateIncenter(getVertex116(), getVertex191(), getVertex192());
	var ringGeometry380 = new THREE.RingGeometry((inradius380 - 0.005),inradius380, 32);
	const ringMaterial380 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh380 = new THREE.Mesh(ringGeometry380, ringMaterial380);

	function setCircleRotation380(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.27450980392156865],[0.,0.,0.26470588235294124]);

        ringMesh380.position.setX(incenter[0]);
        ringMesh380.position.setY(incenter[1]);
        ringMesh380.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex191(), getVertex192());
        var relRadius = inradius/inradius380;

        ringMesh380.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A380 = new THREE.Vector3(0.,1.,0.);
        const B380 = new THREE.Vector3(0.,0.,0.27450980392156865);
        const C380 = new THREE.Vector3(0.,0.,0.26470588235294124);

        const normalVec380 = new THREE.Vector3();
        normalVec380.crossVectors(B380.sub(A380), C380.sub(A380));
        normalVec380.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal380 = new THREE.Vector3(0,0,1);

        const quaternionRotation380 = new THREE.Quaternion();
        quaternionRotation380.setFromUnitVectors(initialNormal380, normalVec380);

        ringMesh380.setRotationFromQuaternion(quaternionRotation380);

        return quaternionRotation380;
    }

    ringRoot.add(ringMesh380);
            
	var inradius381 = calulateInradius(getVertex117(), getVertex144(), getVertex145());
	var incenter381 = calulateIncenter(getVertex117(), getVertex144(), getVertex145());
	var ringGeometry381 = new THREE.RingGeometry((inradius381 - 0.005),inradius381, 32);
	const ringMaterial381 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh381 = new THREE.Mesh(ringGeometry381, ringMaterial381);

	function setCircleRotation381(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.73529411764705888],[0.,0.,0.72549019607843135]);

        ringMesh381.position.setX(incenter[0]);
        ringMesh381.position.setY(incenter[1]);
        ringMesh381.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex144(), getVertex145());
        var relRadius = inradius/inradius381;

        ringMesh381.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A381 = new THREE.Vector3(0.,1.,1.);
        const B381 = new THREE.Vector3(0.,0.,0.73529411764705888);
        const C381 = new THREE.Vector3(0.,0.,0.72549019607843135);

        const normalVec381 = new THREE.Vector3();
        normalVec381.crossVectors(B381.sub(A381), C381.sub(A381));
        normalVec381.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal381 = new THREE.Vector3(0,0,1);

        const quaternionRotation381 = new THREE.Quaternion();
        quaternionRotation381.setFromUnitVectors(initialNormal381, normalVec381);

        ringMesh381.setRotationFromQuaternion(quaternionRotation381);

        return quaternionRotation381;
    }

    ringRoot.add(ringMesh381);
            
	var inradius382 = calulateInradius(getVertex116(), getVertex190(), getVertex191());
	var incenter382 = calulateIncenter(getVertex116(), getVertex190(), getVertex191());
	var ringGeometry382 = new THREE.RingGeometry((inradius382 - 0.005),inradius382, 32);
	const ringMaterial382 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh382 = new THREE.Mesh(ringGeometry382, ringMaterial382);

	function setCircleRotation382(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.28431372549019607],[0.,0.,0.27450980392156865]);

        ringMesh382.position.setX(incenter[0]);
        ringMesh382.position.setY(incenter[1]);
        ringMesh382.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex190(), getVertex191());
        var relRadius = inradius/inradius382;

        ringMesh382.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A382 = new THREE.Vector3(0.,1.,0.);
        const B382 = new THREE.Vector3(0.,0.,0.28431372549019607);
        const C382 = new THREE.Vector3(0.,0.,0.27450980392156865);

        const normalVec382 = new THREE.Vector3();
        normalVec382.crossVectors(B382.sub(A382), C382.sub(A382));
        normalVec382.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal382 = new THREE.Vector3(0,0,1);

        const quaternionRotation382 = new THREE.Quaternion();
        quaternionRotation382.setFromUnitVectors(initialNormal382, normalVec382);

        ringMesh382.setRotationFromQuaternion(quaternionRotation382);

        return quaternionRotation382;
    }

    ringRoot.add(ringMesh382);
            
	var inradius383 = calulateInradius(getVertex117(), getVertex145(), getVertex146());
	var incenter383 = calulateIncenter(getVertex117(), getVertex145(), getVertex146());
	var ringGeometry383 = new THREE.RingGeometry((inradius383 - 0.005),inradius383, 32);
	const ringMaterial383 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh383 = new THREE.Mesh(ringGeometry383, ringMaterial383);

	function setCircleRotation383(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.72549019607843135],[0.,0.,0.71568627450980393]);

        ringMesh383.position.setX(incenter[0]);
        ringMesh383.position.setY(incenter[1]);
        ringMesh383.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex145(), getVertex146());
        var relRadius = inradius/inradius383;

        ringMesh383.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A383 = new THREE.Vector3(0.,1.,1.);
        const B383 = new THREE.Vector3(0.,0.,0.72549019607843135);
        const C383 = new THREE.Vector3(0.,0.,0.71568627450980393);

        const normalVec383 = new THREE.Vector3();
        normalVec383.crossVectors(B383.sub(A383), C383.sub(A383));
        normalVec383.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal383 = new THREE.Vector3(0,0,1);

        const quaternionRotation383 = new THREE.Quaternion();
        quaternionRotation383.setFromUnitVectors(initialNormal383, normalVec383);

        ringMesh383.setRotationFromQuaternion(quaternionRotation383);

        return quaternionRotation383;
    }

    ringRoot.add(ringMesh383);
            
	var inradius384 = calulateInradius(getVertex116(), getVertex189(), getVertex190());
	var incenter384 = calulateIncenter(getVertex116(), getVertex189(), getVertex190());
	var ringGeometry384 = new THREE.RingGeometry((inradius384 - 0.005),inradius384, 32);
	const ringMaterial384 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh384 = new THREE.Mesh(ringGeometry384, ringMaterial384);

	function setCircleRotation384(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.29411764705882359],[0.,0.,0.28431372549019607]);

        ringMesh384.position.setX(incenter[0]);
        ringMesh384.position.setY(incenter[1]);
        ringMesh384.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex189(), getVertex190());
        var relRadius = inradius/inradius384;

        ringMesh384.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A384 = new THREE.Vector3(0.,1.,0.);
        const B384 = new THREE.Vector3(0.,0.,0.29411764705882359);
        const C384 = new THREE.Vector3(0.,0.,0.28431372549019607);

        const normalVec384 = new THREE.Vector3();
        normalVec384.crossVectors(B384.sub(A384), C384.sub(A384));
        normalVec384.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal384 = new THREE.Vector3(0,0,1);

        const quaternionRotation384 = new THREE.Quaternion();
        quaternionRotation384.setFromUnitVectors(initialNormal384, normalVec384);

        ringMesh384.setRotationFromQuaternion(quaternionRotation384);

        return quaternionRotation384;
    }

    ringRoot.add(ringMesh384);
            
	var inradius385 = calulateInradius(getVertex117(), getVertex146(), getVertex147());
	var incenter385 = calulateIncenter(getVertex117(), getVertex146(), getVertex147());
	var ringGeometry385 = new THREE.RingGeometry((inradius385 - 0.005),inradius385, 32);
	const ringMaterial385 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh385 = new THREE.Mesh(ringGeometry385, ringMaterial385);

	function setCircleRotation385(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.71568627450980393],[0.,0.,0.70588235294117641]);

        ringMesh385.position.setX(incenter[0]);
        ringMesh385.position.setY(incenter[1]);
        ringMesh385.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex146(), getVertex147());
        var relRadius = inradius/inradius385;

        ringMesh385.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A385 = new THREE.Vector3(0.,1.,1.);
        const B385 = new THREE.Vector3(0.,0.,0.71568627450980393);
        const C385 = new THREE.Vector3(0.,0.,0.70588235294117641);

        const normalVec385 = new THREE.Vector3();
        normalVec385.crossVectors(B385.sub(A385), C385.sub(A385));
        normalVec385.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal385 = new THREE.Vector3(0,0,1);

        const quaternionRotation385 = new THREE.Quaternion();
        quaternionRotation385.setFromUnitVectors(initialNormal385, normalVec385);

        ringMesh385.setRotationFromQuaternion(quaternionRotation385);

        return quaternionRotation385;
    }

    ringRoot.add(ringMesh385);
            
	var inradius386 = calulateInradius(getVertex116(), getVertex188(), getVertex189());
	var incenter386 = calulateIncenter(getVertex116(), getVertex188(), getVertex189());
	var ringGeometry386 = new THREE.RingGeometry((inradius386 - 0.005),inradius386, 32);
	const ringMaterial386 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh386 = new THREE.Mesh(ringGeometry386, ringMaterial386);

	function setCircleRotation386(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.30392156862745101],[0.,0.,0.29411764705882359]);

        ringMesh386.position.setX(incenter[0]);
        ringMesh386.position.setY(incenter[1]);
        ringMesh386.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex188(), getVertex189());
        var relRadius = inradius/inradius386;

        ringMesh386.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A386 = new THREE.Vector3(0.,1.,0.);
        const B386 = new THREE.Vector3(0.,0.,0.30392156862745101);
        const C386 = new THREE.Vector3(0.,0.,0.29411764705882359);

        const normalVec386 = new THREE.Vector3();
        normalVec386.crossVectors(B386.sub(A386), C386.sub(A386));
        normalVec386.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal386 = new THREE.Vector3(0,0,1);

        const quaternionRotation386 = new THREE.Quaternion();
        quaternionRotation386.setFromUnitVectors(initialNormal386, normalVec386);

        ringMesh386.setRotationFromQuaternion(quaternionRotation386);

        return quaternionRotation386;
    }

    ringRoot.add(ringMesh386);
            
	var inradius387 = calulateInradius(getVertex117(), getVertex147(), getVertex148());
	var incenter387 = calulateIncenter(getVertex117(), getVertex147(), getVertex148());
	var ringGeometry387 = new THREE.RingGeometry((inradius387 - 0.005),inradius387, 32);
	const ringMaterial387 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh387 = new THREE.Mesh(ringGeometry387, ringMaterial387);

	function setCircleRotation387(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.70588235294117641],[0.,0.,0.69607843137254899]);

        ringMesh387.position.setX(incenter[0]);
        ringMesh387.position.setY(incenter[1]);
        ringMesh387.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex147(), getVertex148());
        var relRadius = inradius/inradius387;

        ringMesh387.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A387 = new THREE.Vector3(0.,1.,1.);
        const B387 = new THREE.Vector3(0.,0.,0.70588235294117641);
        const C387 = new THREE.Vector3(0.,0.,0.69607843137254899);

        const normalVec387 = new THREE.Vector3();
        normalVec387.crossVectors(B387.sub(A387), C387.sub(A387));
        normalVec387.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal387 = new THREE.Vector3(0,0,1);

        const quaternionRotation387 = new THREE.Quaternion();
        quaternionRotation387.setFromUnitVectors(initialNormal387, normalVec387);

        ringMesh387.setRotationFromQuaternion(quaternionRotation387);

        return quaternionRotation387;
    }

    ringRoot.add(ringMesh387);
            
	var inradius388 = calulateInradius(getVertex116(), getVertex187(), getVertex188());
	var incenter388 = calulateIncenter(getVertex116(), getVertex187(), getVertex188());
	var ringGeometry388 = new THREE.RingGeometry((inradius388 - 0.005),inradius388, 32);
	const ringMaterial388 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh388 = new THREE.Mesh(ringGeometry388, ringMaterial388);

	function setCircleRotation388(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.31372549019607843],[0.,0.,0.30392156862745101]);

        ringMesh388.position.setX(incenter[0]);
        ringMesh388.position.setY(incenter[1]);
        ringMesh388.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex187(), getVertex188());
        var relRadius = inradius/inradius388;

        ringMesh388.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A388 = new THREE.Vector3(0.,1.,0.);
        const B388 = new THREE.Vector3(0.,0.,0.31372549019607843);
        const C388 = new THREE.Vector3(0.,0.,0.30392156862745101);

        const normalVec388 = new THREE.Vector3();
        normalVec388.crossVectors(B388.sub(A388), C388.sub(A388));
        normalVec388.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal388 = new THREE.Vector3(0,0,1);

        const quaternionRotation388 = new THREE.Quaternion();
        quaternionRotation388.setFromUnitVectors(initialNormal388, normalVec388);

        ringMesh388.setRotationFromQuaternion(quaternionRotation388);

        return quaternionRotation388;
    }

    ringRoot.add(ringMesh388);
            
	var inradius389 = calulateInradius(getVertex117(), getVertex148(), getVertex149());
	var incenter389 = calulateIncenter(getVertex117(), getVertex148(), getVertex149());
	var ringGeometry389 = new THREE.RingGeometry((inradius389 - 0.005),inradius389, 32);
	const ringMaterial389 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh389 = new THREE.Mesh(ringGeometry389, ringMaterial389);

	function setCircleRotation389(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.69607843137254899],[0.,0.,0.68627450980392157]);

        ringMesh389.position.setX(incenter[0]);
        ringMesh389.position.setY(incenter[1]);
        ringMesh389.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex148(), getVertex149());
        var relRadius = inradius/inradius389;

        ringMesh389.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A389 = new THREE.Vector3(0.,1.,1.);
        const B389 = new THREE.Vector3(0.,0.,0.69607843137254899);
        const C389 = new THREE.Vector3(0.,0.,0.68627450980392157);

        const normalVec389 = new THREE.Vector3();
        normalVec389.crossVectors(B389.sub(A389), C389.sub(A389));
        normalVec389.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal389 = new THREE.Vector3(0,0,1);

        const quaternionRotation389 = new THREE.Quaternion();
        quaternionRotation389.setFromUnitVectors(initialNormal389, normalVec389);

        ringMesh389.setRotationFromQuaternion(quaternionRotation389);

        return quaternionRotation389;
    }

    ringRoot.add(ringMesh389);
            
	var inradius390 = calulateInradius(getVertex116(), getVertex186(), getVertex187());
	var incenter390 = calulateIncenter(getVertex116(), getVertex186(), getVertex187());
	var ringGeometry390 = new THREE.RingGeometry((inradius390 - 0.005),inradius390, 32);
	const ringMaterial390 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh390 = new THREE.Mesh(ringGeometry390, ringMaterial390);

	function setCircleRotation390(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.32352941176470584],[0.,0.,0.31372549019607843]);

        ringMesh390.position.setX(incenter[0]);
        ringMesh390.position.setY(incenter[1]);
        ringMesh390.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex186(), getVertex187());
        var relRadius = inradius/inradius390;

        ringMesh390.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A390 = new THREE.Vector3(0.,1.,0.);
        const B390 = new THREE.Vector3(0.,0.,0.32352941176470584);
        const C390 = new THREE.Vector3(0.,0.,0.31372549019607843);

        const normalVec390 = new THREE.Vector3();
        normalVec390.crossVectors(B390.sub(A390), C390.sub(A390));
        normalVec390.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal390 = new THREE.Vector3(0,0,1);

        const quaternionRotation390 = new THREE.Quaternion();
        quaternionRotation390.setFromUnitVectors(initialNormal390, normalVec390);

        ringMesh390.setRotationFromQuaternion(quaternionRotation390);

        return quaternionRotation390;
    }

    ringRoot.add(ringMesh390);
            
	var inradius391 = calulateInradius(getVertex117(), getVertex149(), getVertex150());
	var incenter391 = calulateIncenter(getVertex117(), getVertex149(), getVertex150());
	var ringGeometry391 = new THREE.RingGeometry((inradius391 - 0.005),inradius391, 32);
	const ringMaterial391 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh391 = new THREE.Mesh(ringGeometry391, ringMaterial391);

	function setCircleRotation391(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.68627450980392157],[0.,0.,0.67647058823529416]);

        ringMesh391.position.setX(incenter[0]);
        ringMesh391.position.setY(incenter[1]);
        ringMesh391.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex149(), getVertex150());
        var relRadius = inradius/inradius391;

        ringMesh391.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A391 = new THREE.Vector3(0.,1.,1.);
        const B391 = new THREE.Vector3(0.,0.,0.68627450980392157);
        const C391 = new THREE.Vector3(0.,0.,0.67647058823529416);

        const normalVec391 = new THREE.Vector3();
        normalVec391.crossVectors(B391.sub(A391), C391.sub(A391));
        normalVec391.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal391 = new THREE.Vector3(0,0,1);

        const quaternionRotation391 = new THREE.Quaternion();
        quaternionRotation391.setFromUnitVectors(initialNormal391, normalVec391);

        ringMesh391.setRotationFromQuaternion(quaternionRotation391);

        return quaternionRotation391;
    }

    ringRoot.add(ringMesh391);
            
	var inradius392 = calulateInradius(getVertex116(), getVertex185(), getVertex186());
	var incenter392 = calulateIncenter(getVertex116(), getVertex185(), getVertex186());
	var ringGeometry392 = new THREE.RingGeometry((inradius392 - 0.005),inradius392, 32);
	const ringMaterial392 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh392 = new THREE.Mesh(ringGeometry392, ringMaterial392);

	function setCircleRotation392(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.33333333333333337],[0.,0.,0.32352941176470584]);

        ringMesh392.position.setX(incenter[0]);
        ringMesh392.position.setY(incenter[1]);
        ringMesh392.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex185(), getVertex186());
        var relRadius = inradius/inradius392;

        ringMesh392.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A392 = new THREE.Vector3(0.,1.,0.);
        const B392 = new THREE.Vector3(0.,0.,0.33333333333333337);
        const C392 = new THREE.Vector3(0.,0.,0.32352941176470584);

        const normalVec392 = new THREE.Vector3();
        normalVec392.crossVectors(B392.sub(A392), C392.sub(A392));
        normalVec392.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal392 = new THREE.Vector3(0,0,1);

        const quaternionRotation392 = new THREE.Quaternion();
        quaternionRotation392.setFromUnitVectors(initialNormal392, normalVec392);

        ringMesh392.setRotationFromQuaternion(quaternionRotation392);

        return quaternionRotation392;
    }

    ringRoot.add(ringMesh392);
            
	var inradius393 = calulateInradius(getVertex117(), getVertex150(), getVertex151());
	var incenter393 = calulateIncenter(getVertex117(), getVertex150(), getVertex151());
	var ringGeometry393 = new THREE.RingGeometry((inradius393 - 0.005),inradius393, 32);
	const ringMaterial393 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh393 = new THREE.Mesh(ringGeometry393, ringMaterial393);

	function setCircleRotation393(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.67647058823529416],[0.,0.,0.66666666666666674]);

        ringMesh393.position.setX(incenter[0]);
        ringMesh393.position.setY(incenter[1]);
        ringMesh393.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex150(), getVertex151());
        var relRadius = inradius/inradius393;

        ringMesh393.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A393 = new THREE.Vector3(0.,1.,1.);
        const B393 = new THREE.Vector3(0.,0.,0.67647058823529416);
        const C393 = new THREE.Vector3(0.,0.,0.66666666666666674);

        const normalVec393 = new THREE.Vector3();
        normalVec393.crossVectors(B393.sub(A393), C393.sub(A393));
        normalVec393.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal393 = new THREE.Vector3(0,0,1);

        const quaternionRotation393 = new THREE.Quaternion();
        quaternionRotation393.setFromUnitVectors(initialNormal393, normalVec393);

        ringMesh393.setRotationFromQuaternion(quaternionRotation393);

        return quaternionRotation393;
    }

    ringRoot.add(ringMesh393);
            
	var inradius394 = calulateInradius(getVertex116(), getVertex184(), getVertex185());
	var incenter394 = calulateIncenter(getVertex116(), getVertex184(), getVertex185());
	var ringGeometry394 = new THREE.RingGeometry((inradius394 - 0.005),inradius394, 32);
	const ringMaterial394 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh394 = new THREE.Mesh(ringGeometry394, ringMaterial394);

	function setCircleRotation394(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.34313725490196079],[0.,0.,0.33333333333333337]);

        ringMesh394.position.setX(incenter[0]);
        ringMesh394.position.setY(incenter[1]);
        ringMesh394.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex184(), getVertex185());
        var relRadius = inradius/inradius394;

        ringMesh394.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A394 = new THREE.Vector3(0.,1.,0.);
        const B394 = new THREE.Vector3(0.,0.,0.34313725490196079);
        const C394 = new THREE.Vector3(0.,0.,0.33333333333333337);

        const normalVec394 = new THREE.Vector3();
        normalVec394.crossVectors(B394.sub(A394), C394.sub(A394));
        normalVec394.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal394 = new THREE.Vector3(0,0,1);

        const quaternionRotation394 = new THREE.Quaternion();
        quaternionRotation394.setFromUnitVectors(initialNormal394, normalVec394);

        ringMesh394.setRotationFromQuaternion(quaternionRotation394);

        return quaternionRotation394;
    }

    ringRoot.add(ringMesh394);
            
	var inradius395 = calulateInradius(getVertex117(), getVertex151(), getVertex152());
	var incenter395 = calulateIncenter(getVertex117(), getVertex151(), getVertex152());
	var ringGeometry395 = new THREE.RingGeometry((inradius395 - 0.005),inradius395, 32);
	const ringMaterial395 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh395 = new THREE.Mesh(ringGeometry395, ringMaterial395);

	function setCircleRotation395(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.66666666666666674],[0.,0.,0.65686274509803921]);

        ringMesh395.position.setX(incenter[0]);
        ringMesh395.position.setY(incenter[1]);
        ringMesh395.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex151(), getVertex152());
        var relRadius = inradius/inradius395;

        ringMesh395.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A395 = new THREE.Vector3(0.,1.,1.);
        const B395 = new THREE.Vector3(0.,0.,0.66666666666666674);
        const C395 = new THREE.Vector3(0.,0.,0.65686274509803921);

        const normalVec395 = new THREE.Vector3();
        normalVec395.crossVectors(B395.sub(A395), C395.sub(A395));
        normalVec395.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal395 = new THREE.Vector3(0,0,1);

        const quaternionRotation395 = new THREE.Quaternion();
        quaternionRotation395.setFromUnitVectors(initialNormal395, normalVec395);

        ringMesh395.setRotationFromQuaternion(quaternionRotation395);

        return quaternionRotation395;
    }

    ringRoot.add(ringMesh395);
            
	var inradius396 = calulateInradius(getVertex116(), getVertex183(), getVertex184());
	var incenter396 = calulateIncenter(getVertex116(), getVertex183(), getVertex184());
	var ringGeometry396 = new THREE.RingGeometry((inradius396 - 0.005),inradius396, 32);
	const ringMaterial396 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh396 = new THREE.Mesh(ringGeometry396, ringMaterial396);

	function setCircleRotation396(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.3529411764705882],[0.,0.,0.34313725490196079]);

        ringMesh396.position.setX(incenter[0]);
        ringMesh396.position.setY(incenter[1]);
        ringMesh396.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex183(), getVertex184());
        var relRadius = inradius/inradius396;

        ringMesh396.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A396 = new THREE.Vector3(0.,1.,0.);
        const B396 = new THREE.Vector3(0.,0.,0.3529411764705882);
        const C396 = new THREE.Vector3(0.,0.,0.34313725490196079);

        const normalVec396 = new THREE.Vector3();
        normalVec396.crossVectors(B396.sub(A396), C396.sub(A396));
        normalVec396.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal396 = new THREE.Vector3(0,0,1);

        const quaternionRotation396 = new THREE.Quaternion();
        quaternionRotation396.setFromUnitVectors(initialNormal396, normalVec396);

        ringMesh396.setRotationFromQuaternion(quaternionRotation396);

        return quaternionRotation396;
    }

    ringRoot.add(ringMesh396);
            
	var inradius397 = calulateInradius(getVertex117(), getVertex152(), getVertex153());
	var incenter397 = calulateIncenter(getVertex117(), getVertex152(), getVertex153());
	var ringGeometry397 = new THREE.RingGeometry((inradius397 - 0.005),inradius397, 32);
	const ringMaterial397 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh397 = new THREE.Mesh(ringGeometry397, ringMaterial397);

	function setCircleRotation397(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.65686274509803921],[0.,0.,0.6470588235294118]);

        ringMesh397.position.setX(incenter[0]);
        ringMesh397.position.setY(incenter[1]);
        ringMesh397.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex152(), getVertex153());
        var relRadius = inradius/inradius397;

        ringMesh397.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A397 = new THREE.Vector3(0.,1.,1.);
        const B397 = new THREE.Vector3(0.,0.,0.65686274509803921);
        const C397 = new THREE.Vector3(0.,0.,0.6470588235294118);

        const normalVec397 = new THREE.Vector3();
        normalVec397.crossVectors(B397.sub(A397), C397.sub(A397));
        normalVec397.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal397 = new THREE.Vector3(0,0,1);

        const quaternionRotation397 = new THREE.Quaternion();
        quaternionRotation397.setFromUnitVectors(initialNormal397, normalVec397);

        ringMesh397.setRotationFromQuaternion(quaternionRotation397);

        return quaternionRotation397;
    }

    ringRoot.add(ringMesh397);
            
	var inradius398 = calulateInradius(getVertex116(), getVertex182(), getVertex183());
	var incenter398 = calulateIncenter(getVertex116(), getVertex182(), getVertex183());
	var ringGeometry398 = new THREE.RingGeometry((inradius398 - 0.005),inradius398, 32);
	const ringMaterial398 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh398 = new THREE.Mesh(ringGeometry398, ringMaterial398);

	function setCircleRotation398(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.36274509803921573],[0.,0.,0.3529411764705882]);

        ringMesh398.position.setX(incenter[0]);
        ringMesh398.position.setY(incenter[1]);
        ringMesh398.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex182(), getVertex183());
        var relRadius = inradius/inradius398;

        ringMesh398.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A398 = new THREE.Vector3(0.,1.,0.);
        const B398 = new THREE.Vector3(0.,0.,0.36274509803921573);
        const C398 = new THREE.Vector3(0.,0.,0.3529411764705882);

        const normalVec398 = new THREE.Vector3();
        normalVec398.crossVectors(B398.sub(A398), C398.sub(A398));
        normalVec398.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal398 = new THREE.Vector3(0,0,1);

        const quaternionRotation398 = new THREE.Quaternion();
        quaternionRotation398.setFromUnitVectors(initialNormal398, normalVec398);

        ringMesh398.setRotationFromQuaternion(quaternionRotation398);

        return quaternionRotation398;
    }

    ringRoot.add(ringMesh398);
            
	var inradius399 = calulateInradius(getVertex117(), getVertex153(), getVertex154());
	var incenter399 = calulateIncenter(getVertex117(), getVertex153(), getVertex154());
	var ringGeometry399 = new THREE.RingGeometry((inradius399 - 0.005),inradius399, 32);
	const ringMaterial399 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh399 = new THREE.Mesh(ringGeometry399, ringMaterial399);

	function setCircleRotation399(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.6470588235294118],[0.,0.,0.63725490196078427]);

        ringMesh399.position.setX(incenter[0]);
        ringMesh399.position.setY(incenter[1]);
        ringMesh399.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex153(), getVertex154());
        var relRadius = inradius/inradius399;

        ringMesh399.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A399 = new THREE.Vector3(0.,1.,1.);
        const B399 = new THREE.Vector3(0.,0.,0.6470588235294118);
        const C399 = new THREE.Vector3(0.,0.,0.63725490196078427);

        const normalVec399 = new THREE.Vector3();
        normalVec399.crossVectors(B399.sub(A399), C399.sub(A399));
        normalVec399.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal399 = new THREE.Vector3(0,0,1);

        const quaternionRotation399 = new THREE.Quaternion();
        quaternionRotation399.setFromUnitVectors(initialNormal399, normalVec399);

        ringMesh399.setRotationFromQuaternion(quaternionRotation399);

        return quaternionRotation399;
    }

    ringRoot.add(ringMesh399);
            
	var inradius400 = calulateInradius(getVertex116(), getVertex181(), getVertex182());
	var incenter400 = calulateIncenter(getVertex116(), getVertex181(), getVertex182());
	var ringGeometry400 = new THREE.RingGeometry((inradius400 - 0.005),inradius400, 32);
	const ringMaterial400 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh400 = new THREE.Mesh(ringGeometry400, ringMaterial400);

	function setCircleRotation400(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.37254901960784315],[0.,0.,0.36274509803921573]);

        ringMesh400.position.setX(incenter[0]);
        ringMesh400.position.setY(incenter[1]);
        ringMesh400.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex181(), getVertex182());
        var relRadius = inradius/inradius400;

        ringMesh400.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A400 = new THREE.Vector3(0.,1.,0.);
        const B400 = new THREE.Vector3(0.,0.,0.37254901960784315);
        const C400 = new THREE.Vector3(0.,0.,0.36274509803921573);

        const normalVec400 = new THREE.Vector3();
        normalVec400.crossVectors(B400.sub(A400), C400.sub(A400));
        normalVec400.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal400 = new THREE.Vector3(0,0,1);

        const quaternionRotation400 = new THREE.Quaternion();
        quaternionRotation400.setFromUnitVectors(initialNormal400, normalVec400);

        ringMesh400.setRotationFromQuaternion(quaternionRotation400);

        return quaternionRotation400;
    }

    ringRoot.add(ringMesh400);
            
	var inradius401 = calulateInradius(getVertex117(), getVertex154(), getVertex155());
	var incenter401 = calulateIncenter(getVertex117(), getVertex154(), getVertex155());
	var ringGeometry401 = new THREE.RingGeometry((inradius401 - 0.005),inradius401, 32);
	const ringMaterial401 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh401 = new THREE.Mesh(ringGeometry401, ringMaterial401);

	function setCircleRotation401(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.63725490196078427],[0.,0.,0.62745098039215685]);

        ringMesh401.position.setX(incenter[0]);
        ringMesh401.position.setY(incenter[1]);
        ringMesh401.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex154(), getVertex155());
        var relRadius = inradius/inradius401;

        ringMesh401.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A401 = new THREE.Vector3(0.,1.,1.);
        const B401 = new THREE.Vector3(0.,0.,0.63725490196078427);
        const C401 = new THREE.Vector3(0.,0.,0.62745098039215685);

        const normalVec401 = new THREE.Vector3();
        normalVec401.crossVectors(B401.sub(A401), C401.sub(A401));
        normalVec401.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal401 = new THREE.Vector3(0,0,1);

        const quaternionRotation401 = new THREE.Quaternion();
        quaternionRotation401.setFromUnitVectors(initialNormal401, normalVec401);

        ringMesh401.setRotationFromQuaternion(quaternionRotation401);

        return quaternionRotation401;
    }

    ringRoot.add(ringMesh401);
            
	var inradius402 = calulateInradius(getVertex116(), getVertex180(), getVertex181());
	var incenter402 = calulateIncenter(getVertex116(), getVertex180(), getVertex181());
	var ringGeometry402 = new THREE.RingGeometry((inradius402 - 0.005),inradius402, 32);
	const ringMaterial402 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh402 = new THREE.Mesh(ringGeometry402, ringMaterial402);

	function setCircleRotation402(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.38235294117647056],[0.,0.,0.37254901960784315]);

        ringMesh402.position.setX(incenter[0]);
        ringMesh402.position.setY(incenter[1]);
        ringMesh402.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex180(), getVertex181());
        var relRadius = inradius/inradius402;

        ringMesh402.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A402 = new THREE.Vector3(0.,1.,0.);
        const B402 = new THREE.Vector3(0.,0.,0.38235294117647056);
        const C402 = new THREE.Vector3(0.,0.,0.37254901960784315);

        const normalVec402 = new THREE.Vector3();
        normalVec402.crossVectors(B402.sub(A402), C402.sub(A402));
        normalVec402.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal402 = new THREE.Vector3(0,0,1);

        const quaternionRotation402 = new THREE.Quaternion();
        quaternionRotation402.setFromUnitVectors(initialNormal402, normalVec402);

        ringMesh402.setRotationFromQuaternion(quaternionRotation402);

        return quaternionRotation402;
    }

    ringRoot.add(ringMesh402);
            
	var inradius403 = calulateInradius(getVertex117(), getVertex155(), getVertex156());
	var incenter403 = calulateIncenter(getVertex117(), getVertex155(), getVertex156());
	var ringGeometry403 = new THREE.RingGeometry((inradius403 - 0.005),inradius403, 32);
	const ringMaterial403 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh403 = new THREE.Mesh(ringGeometry403, ringMaterial403);

	function setCircleRotation403(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.62745098039215685],[0.,0.,0.61764705882352944]);

        ringMesh403.position.setX(incenter[0]);
        ringMesh403.position.setY(incenter[1]);
        ringMesh403.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex155(), getVertex156());
        var relRadius = inradius/inradius403;

        ringMesh403.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A403 = new THREE.Vector3(0.,1.,1.);
        const B403 = new THREE.Vector3(0.,0.,0.62745098039215685);
        const C403 = new THREE.Vector3(0.,0.,0.61764705882352944);

        const normalVec403 = new THREE.Vector3();
        normalVec403.crossVectors(B403.sub(A403), C403.sub(A403));
        normalVec403.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal403 = new THREE.Vector3(0,0,1);

        const quaternionRotation403 = new THREE.Quaternion();
        quaternionRotation403.setFromUnitVectors(initialNormal403, normalVec403);

        ringMesh403.setRotationFromQuaternion(quaternionRotation403);

        return quaternionRotation403;
    }

    ringRoot.add(ringMesh403);
            
	var inradius404 = calulateInradius(getVertex116(), getVertex179(), getVertex180());
	var incenter404 = calulateIncenter(getVertex116(), getVertex179(), getVertex180());
	var ringGeometry404 = new THREE.RingGeometry((inradius404 - 0.005),inradius404, 32);
	const ringMaterial404 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh404 = new THREE.Mesh(ringGeometry404, ringMaterial404);

	function setCircleRotation404(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.39215686274509809],[0.,0.,0.38235294117647056]);

        ringMesh404.position.setX(incenter[0]);
        ringMesh404.position.setY(incenter[1]);
        ringMesh404.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex179(), getVertex180());
        var relRadius = inradius/inradius404;

        ringMesh404.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A404 = new THREE.Vector3(0.,1.,0.);
        const B404 = new THREE.Vector3(0.,0.,0.39215686274509809);
        const C404 = new THREE.Vector3(0.,0.,0.38235294117647056);

        const normalVec404 = new THREE.Vector3();
        normalVec404.crossVectors(B404.sub(A404), C404.sub(A404));
        normalVec404.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal404 = new THREE.Vector3(0,0,1);

        const quaternionRotation404 = new THREE.Quaternion();
        quaternionRotation404.setFromUnitVectors(initialNormal404, normalVec404);

        ringMesh404.setRotationFromQuaternion(quaternionRotation404);

        return quaternionRotation404;
    }

    ringRoot.add(ringMesh404);
            
	var inradius405 = calulateInradius(getVertex117(), getVertex156(), getVertex157());
	var incenter405 = calulateIncenter(getVertex117(), getVertex156(), getVertex157());
	var ringGeometry405 = new THREE.RingGeometry((inradius405 - 0.005),inradius405, 32);
	const ringMaterial405 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh405 = new THREE.Mesh(ringGeometry405, ringMaterial405);

	function setCircleRotation405(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.61764705882352944],[0.,0.,0.60784313725490202]);

        ringMesh405.position.setX(incenter[0]);
        ringMesh405.position.setY(incenter[1]);
        ringMesh405.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex156(), getVertex157());
        var relRadius = inradius/inradius405;

        ringMesh405.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A405 = new THREE.Vector3(0.,1.,1.);
        const B405 = new THREE.Vector3(0.,0.,0.61764705882352944);
        const C405 = new THREE.Vector3(0.,0.,0.60784313725490202);

        const normalVec405 = new THREE.Vector3();
        normalVec405.crossVectors(B405.sub(A405), C405.sub(A405));
        normalVec405.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal405 = new THREE.Vector3(0,0,1);

        const quaternionRotation405 = new THREE.Quaternion();
        quaternionRotation405.setFromUnitVectors(initialNormal405, normalVec405);

        ringMesh405.setRotationFromQuaternion(quaternionRotation405);

        return quaternionRotation405;
    }

    ringRoot.add(ringMesh405);
            
	var inradius406 = calulateInradius(getVertex116(), getVertex178(), getVertex179());
	var incenter406 = calulateIncenter(getVertex116(), getVertex178(), getVertex179());
	var ringGeometry406 = new THREE.RingGeometry((inradius406 - 0.005),inradius406, 32);
	const ringMaterial406 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh406 = new THREE.Mesh(ringGeometry406, ringMaterial406);

	function setCircleRotation406(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.40196078431372551],[0.,0.,0.39215686274509809]);

        ringMesh406.position.setX(incenter[0]);
        ringMesh406.position.setY(incenter[1]);
        ringMesh406.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex178(), getVertex179());
        var relRadius = inradius/inradius406;

        ringMesh406.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A406 = new THREE.Vector3(0.,1.,0.);
        const B406 = new THREE.Vector3(0.,0.,0.40196078431372551);
        const C406 = new THREE.Vector3(0.,0.,0.39215686274509809);

        const normalVec406 = new THREE.Vector3();
        normalVec406.crossVectors(B406.sub(A406), C406.sub(A406));
        normalVec406.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal406 = new THREE.Vector3(0,0,1);

        const quaternionRotation406 = new THREE.Quaternion();
        quaternionRotation406.setFromUnitVectors(initialNormal406, normalVec406);

        ringMesh406.setRotationFromQuaternion(quaternionRotation406);

        return quaternionRotation406;
    }

    ringRoot.add(ringMesh406);
            
	var inradius407 = calulateInradius(getVertex117(), getVertex157(), getVertex158());
	var incenter407 = calulateIncenter(getVertex117(), getVertex157(), getVertex158());
	var ringGeometry407 = new THREE.RingGeometry((inradius407 - 0.005),inradius407, 32);
	const ringMaterial407 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh407 = new THREE.Mesh(ringGeometry407, ringMaterial407);

	function setCircleRotation407(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.60784313725490202],[0.,0.,0.59803921568627449]);

        ringMesh407.position.setX(incenter[0]);
        ringMesh407.position.setY(incenter[1]);
        ringMesh407.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex157(), getVertex158());
        var relRadius = inradius/inradius407;

        ringMesh407.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A407 = new THREE.Vector3(0.,1.,1.);
        const B407 = new THREE.Vector3(0.,0.,0.60784313725490202);
        const C407 = new THREE.Vector3(0.,0.,0.59803921568627449);

        const normalVec407 = new THREE.Vector3();
        normalVec407.crossVectors(B407.sub(A407), C407.sub(A407));
        normalVec407.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal407 = new THREE.Vector3(0,0,1);

        const quaternionRotation407 = new THREE.Quaternion();
        quaternionRotation407.setFromUnitVectors(initialNormal407, normalVec407);

        ringMesh407.setRotationFromQuaternion(quaternionRotation407);

        return quaternionRotation407;
    }

    ringRoot.add(ringMesh407);
            
	var inradius408 = calulateInradius(getVertex116(), getVertex177(), getVertex178());
	var incenter408 = calulateIncenter(getVertex116(), getVertex177(), getVertex178());
	var ringGeometry408 = new THREE.RingGeometry((inradius408 - 0.005),inradius408, 32);
	const ringMaterial408 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh408 = new THREE.Mesh(ringGeometry408, ringMaterial408);

	function setCircleRotation408(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.41176470588235292],[0.,0.,0.40196078431372551]);

        ringMesh408.position.setX(incenter[0]);
        ringMesh408.position.setY(incenter[1]);
        ringMesh408.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex177(), getVertex178());
        var relRadius = inradius/inradius408;

        ringMesh408.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A408 = new THREE.Vector3(0.,1.,0.);
        const B408 = new THREE.Vector3(0.,0.,0.41176470588235292);
        const C408 = new THREE.Vector3(0.,0.,0.40196078431372551);

        const normalVec408 = new THREE.Vector3();
        normalVec408.crossVectors(B408.sub(A408), C408.sub(A408));
        normalVec408.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal408 = new THREE.Vector3(0,0,1);

        const quaternionRotation408 = new THREE.Quaternion();
        quaternionRotation408.setFromUnitVectors(initialNormal408, normalVec408);

        ringMesh408.setRotationFromQuaternion(quaternionRotation408);

        return quaternionRotation408;
    }

    ringRoot.add(ringMesh408);
            
	var inradius409 = calulateInradius(getVertex117(), getVertex158(), getVertex159());
	var incenter409 = calulateIncenter(getVertex117(), getVertex158(), getVertex159());
	var ringGeometry409 = new THREE.RingGeometry((inradius409 - 0.005),inradius409, 32);
	const ringMaterial409 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh409 = new THREE.Mesh(ringGeometry409, ringMaterial409);

	function setCircleRotation409(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.59803921568627449],[0.,0.,0.58823529411764708]);

        ringMesh409.position.setX(incenter[0]);
        ringMesh409.position.setY(incenter[1]);
        ringMesh409.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex158(), getVertex159());
        var relRadius = inradius/inradius409;

        ringMesh409.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A409 = new THREE.Vector3(0.,1.,1.);
        const B409 = new THREE.Vector3(0.,0.,0.59803921568627449);
        const C409 = new THREE.Vector3(0.,0.,0.58823529411764708);

        const normalVec409 = new THREE.Vector3();
        normalVec409.crossVectors(B409.sub(A409), C409.sub(A409));
        normalVec409.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal409 = new THREE.Vector3(0,0,1);

        const quaternionRotation409 = new THREE.Quaternion();
        quaternionRotation409.setFromUnitVectors(initialNormal409, normalVec409);

        ringMesh409.setRotationFromQuaternion(quaternionRotation409);

        return quaternionRotation409;
    }

    ringRoot.add(ringMesh409);
            
	var inradius410 = calulateInradius(getVertex116(), getVertex176(), getVertex177());
	var incenter410 = calulateIncenter(getVertex116(), getVertex176(), getVertex177());
	var ringGeometry410 = new THREE.RingGeometry((inradius410 - 0.005),inradius410, 32);
	const ringMaterial410 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh410 = new THREE.Mesh(ringGeometry410, ringMaterial410);

	function setCircleRotation410(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.42156862745098045],[0.,0.,0.41176470588235292]);

        ringMesh410.position.setX(incenter[0]);
        ringMesh410.position.setY(incenter[1]);
        ringMesh410.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex176(), getVertex177());
        var relRadius = inradius/inradius410;

        ringMesh410.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A410 = new THREE.Vector3(0.,1.,0.);
        const B410 = new THREE.Vector3(0.,0.,0.42156862745098045);
        const C410 = new THREE.Vector3(0.,0.,0.41176470588235292);

        const normalVec410 = new THREE.Vector3();
        normalVec410.crossVectors(B410.sub(A410), C410.sub(A410));
        normalVec410.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal410 = new THREE.Vector3(0,0,1);

        const quaternionRotation410 = new THREE.Quaternion();
        quaternionRotation410.setFromUnitVectors(initialNormal410, normalVec410);

        ringMesh410.setRotationFromQuaternion(quaternionRotation410);

        return quaternionRotation410;
    }

    ringRoot.add(ringMesh410);
            
	var inradius411 = calulateInradius(getVertex117(), getVertex159(), getVertex160());
	var incenter411 = calulateIncenter(getVertex117(), getVertex159(), getVertex160());
	var ringGeometry411 = new THREE.RingGeometry((inradius411 - 0.005),inradius411, 32);
	const ringMaterial411 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh411 = new THREE.Mesh(ringGeometry411, ringMaterial411);

	function setCircleRotation411(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.58823529411764708],[0.,0.,0.57843137254901955]);

        ringMesh411.position.setX(incenter[0]);
        ringMesh411.position.setY(incenter[1]);
        ringMesh411.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex159(), getVertex160());
        var relRadius = inradius/inradius411;

        ringMesh411.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A411 = new THREE.Vector3(0.,1.,1.);
        const B411 = new THREE.Vector3(0.,0.,0.58823529411764708);
        const C411 = new THREE.Vector3(0.,0.,0.57843137254901955);

        const normalVec411 = new THREE.Vector3();
        normalVec411.crossVectors(B411.sub(A411), C411.sub(A411));
        normalVec411.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal411 = new THREE.Vector3(0,0,1);

        const quaternionRotation411 = new THREE.Quaternion();
        quaternionRotation411.setFromUnitVectors(initialNormal411, normalVec411);

        ringMesh411.setRotationFromQuaternion(quaternionRotation411);

        return quaternionRotation411;
    }

    ringRoot.add(ringMesh411);
            
	var inradius412 = calulateInradius(getVertex116(), getVertex175(), getVertex176());
	var incenter412 = calulateIncenter(getVertex116(), getVertex175(), getVertex176());
	var ringGeometry412 = new THREE.RingGeometry((inradius412 - 0.005),inradius412, 32);
	const ringMaterial412 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh412 = new THREE.Mesh(ringGeometry412, ringMaterial412);

	function setCircleRotation412(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.43137254901960786],[0.,0.,0.42156862745098045]);

        ringMesh412.position.setX(incenter[0]);
        ringMesh412.position.setY(incenter[1]);
        ringMesh412.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex175(), getVertex176());
        var relRadius = inradius/inradius412;

        ringMesh412.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A412 = new THREE.Vector3(0.,1.,0.);
        const B412 = new THREE.Vector3(0.,0.,0.43137254901960786);
        const C412 = new THREE.Vector3(0.,0.,0.42156862745098045);

        const normalVec412 = new THREE.Vector3();
        normalVec412.crossVectors(B412.sub(A412), C412.sub(A412));
        normalVec412.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal412 = new THREE.Vector3(0,0,1);

        const quaternionRotation412 = new THREE.Quaternion();
        quaternionRotation412.setFromUnitVectors(initialNormal412, normalVec412);

        ringMesh412.setRotationFromQuaternion(quaternionRotation412);

        return quaternionRotation412;
    }

    ringRoot.add(ringMesh412);
            
	var inradius413 = calulateInradius(getVertex117(), getVertex160(), getVertex161());
	var incenter413 = calulateIncenter(getVertex117(), getVertex160(), getVertex161());
	var ringGeometry413 = new THREE.RingGeometry((inradius413 - 0.005),inradius413, 32);
	const ringMaterial413 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh413 = new THREE.Mesh(ringGeometry413, ringMaterial413);

	function setCircleRotation413(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.57843137254901955],[0.,0.,0.56862745098039214]);

        ringMesh413.position.setX(incenter[0]);
        ringMesh413.position.setY(incenter[1]);
        ringMesh413.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex160(), getVertex161());
        var relRadius = inradius/inradius413;

        ringMesh413.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A413 = new THREE.Vector3(0.,1.,1.);
        const B413 = new THREE.Vector3(0.,0.,0.57843137254901955);
        const C413 = new THREE.Vector3(0.,0.,0.56862745098039214);

        const normalVec413 = new THREE.Vector3();
        normalVec413.crossVectors(B413.sub(A413), C413.sub(A413));
        normalVec413.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal413 = new THREE.Vector3(0,0,1);

        const quaternionRotation413 = new THREE.Quaternion();
        quaternionRotation413.setFromUnitVectors(initialNormal413, normalVec413);

        ringMesh413.setRotationFromQuaternion(quaternionRotation413);

        return quaternionRotation413;
    }

    ringRoot.add(ringMesh413);
            
	var inradius414 = calulateInradius(getVertex116(), getVertex174(), getVertex175());
	var incenter414 = calulateIncenter(getVertex116(), getVertex174(), getVertex175());
	var ringGeometry414 = new THREE.RingGeometry((inradius414 - 0.005),inradius414, 32);
	const ringMaterial414 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh414 = new THREE.Mesh(ringGeometry414, ringMaterial414);

	function setCircleRotation414(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.44117647058823528],[0.,0.,0.43137254901960786]);

        ringMesh414.position.setX(incenter[0]);
        ringMesh414.position.setY(incenter[1]);
        ringMesh414.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex174(), getVertex175());
        var relRadius = inradius/inradius414;

        ringMesh414.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A414 = new THREE.Vector3(0.,1.,0.);
        const B414 = new THREE.Vector3(0.,0.,0.44117647058823528);
        const C414 = new THREE.Vector3(0.,0.,0.43137254901960786);

        const normalVec414 = new THREE.Vector3();
        normalVec414.crossVectors(B414.sub(A414), C414.sub(A414));
        normalVec414.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal414 = new THREE.Vector3(0,0,1);

        const quaternionRotation414 = new THREE.Quaternion();
        quaternionRotation414.setFromUnitVectors(initialNormal414, normalVec414);

        ringMesh414.setRotationFromQuaternion(quaternionRotation414);

        return quaternionRotation414;
    }

    ringRoot.add(ringMesh414);
            
	var inradius415 = calulateInradius(getVertex117(), getVertex161(), getVertex162());
	var incenter415 = calulateIncenter(getVertex117(), getVertex161(), getVertex162());
	var ringGeometry415 = new THREE.RingGeometry((inradius415 - 0.005),inradius415, 32);
	const ringMaterial415 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh415 = new THREE.Mesh(ringGeometry415, ringMaterial415);

	function setCircleRotation415(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.56862745098039214],[0.,0.,0.55882352941176472]);

        ringMesh415.position.setX(incenter[0]);
        ringMesh415.position.setY(incenter[1]);
        ringMesh415.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex161(), getVertex162());
        var relRadius = inradius/inradius415;

        ringMesh415.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A415 = new THREE.Vector3(0.,1.,1.);
        const B415 = new THREE.Vector3(0.,0.,0.56862745098039214);
        const C415 = new THREE.Vector3(0.,0.,0.55882352941176472);

        const normalVec415 = new THREE.Vector3();
        normalVec415.crossVectors(B415.sub(A415), C415.sub(A415));
        normalVec415.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal415 = new THREE.Vector3(0,0,1);

        const quaternionRotation415 = new THREE.Quaternion();
        quaternionRotation415.setFromUnitVectors(initialNormal415, normalVec415);

        ringMesh415.setRotationFromQuaternion(quaternionRotation415);

        return quaternionRotation415;
    }

    ringRoot.add(ringMesh415);
            
	var inradius416 = calulateInradius(getVertex116(), getVertex173(), getVertex174());
	var incenter416 = calulateIncenter(getVertex116(), getVertex173(), getVertex174());
	var ringGeometry416 = new THREE.RingGeometry((inradius416 - 0.005),inradius416, 32);
	const ringMaterial416 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh416 = new THREE.Mesh(ringGeometry416, ringMaterial416);

	function setCircleRotation416(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.4509803921568627],[0.,0.,0.44117647058823528]);

        ringMesh416.position.setX(incenter[0]);
        ringMesh416.position.setY(incenter[1]);
        ringMesh416.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex173(), getVertex174());
        var relRadius = inradius/inradius416;

        ringMesh416.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A416 = new THREE.Vector3(0.,1.,0.);
        const B416 = new THREE.Vector3(0.,0.,0.4509803921568627);
        const C416 = new THREE.Vector3(0.,0.,0.44117647058823528);

        const normalVec416 = new THREE.Vector3();
        normalVec416.crossVectors(B416.sub(A416), C416.sub(A416));
        normalVec416.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal416 = new THREE.Vector3(0,0,1);

        const quaternionRotation416 = new THREE.Quaternion();
        quaternionRotation416.setFromUnitVectors(initialNormal416, normalVec416);

        ringMesh416.setRotationFromQuaternion(quaternionRotation416);

        return quaternionRotation416;
    }

    ringRoot.add(ringMesh416);
            
	var inradius417 = calulateInradius(getVertex117(), getVertex162(), getVertex163());
	var incenter417 = calulateIncenter(getVertex117(), getVertex162(), getVertex163());
	var ringGeometry417 = new THREE.RingGeometry((inradius417 - 0.005),inradius417, 32);
	const ringMaterial417 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh417 = new THREE.Mesh(ringGeometry417, ringMaterial417);

	function setCircleRotation417(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.55882352941176472],[0.,0.,0.5490196078431373]);

        ringMesh417.position.setX(incenter[0]);
        ringMesh417.position.setY(incenter[1]);
        ringMesh417.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex162(), getVertex163());
        var relRadius = inradius/inradius417;

        ringMesh417.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A417 = new THREE.Vector3(0.,1.,1.);
        const B417 = new THREE.Vector3(0.,0.,0.55882352941176472);
        const C417 = new THREE.Vector3(0.,0.,0.5490196078431373);

        const normalVec417 = new THREE.Vector3();
        normalVec417.crossVectors(B417.sub(A417), C417.sub(A417));
        normalVec417.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal417 = new THREE.Vector3(0,0,1);

        const quaternionRotation417 = new THREE.Quaternion();
        quaternionRotation417.setFromUnitVectors(initialNormal417, normalVec417);

        ringMesh417.setRotationFromQuaternion(quaternionRotation417);

        return quaternionRotation417;
    }

    ringRoot.add(ringMesh417);
            
	var inradius418 = calulateInradius(getVertex116(), getVertex172(), getVertex173());
	var incenter418 = calulateIncenter(getVertex116(), getVertex172(), getVertex173());
	var ringGeometry418 = new THREE.RingGeometry((inradius418 - 0.005),inradius418, 32);
	const ringMaterial418 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh418 = new THREE.Mesh(ringGeometry418, ringMaterial418);

	function setCircleRotation418(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.46078431372549022],[0.,0.,0.4509803921568627]);

        ringMesh418.position.setX(incenter[0]);
        ringMesh418.position.setY(incenter[1]);
        ringMesh418.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex172(), getVertex173());
        var relRadius = inradius/inradius418;

        ringMesh418.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A418 = new THREE.Vector3(0.,1.,0.);
        const B418 = new THREE.Vector3(0.,0.,0.46078431372549022);
        const C418 = new THREE.Vector3(0.,0.,0.4509803921568627);

        const normalVec418 = new THREE.Vector3();
        normalVec418.crossVectors(B418.sub(A418), C418.sub(A418));
        normalVec418.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal418 = new THREE.Vector3(0,0,1);

        const quaternionRotation418 = new THREE.Quaternion();
        quaternionRotation418.setFromUnitVectors(initialNormal418, normalVec418);

        ringMesh418.setRotationFromQuaternion(quaternionRotation418);

        return quaternionRotation418;
    }

    ringRoot.add(ringMesh418);
            
	var inradius419 = calulateInradius(getVertex117(), getVertex163(), getVertex164());
	var incenter419 = calulateIncenter(getVertex117(), getVertex163(), getVertex164());
	var ringGeometry419 = new THREE.RingGeometry((inradius419 - 0.005),inradius419, 32);
	const ringMaterial419 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh419 = new THREE.Mesh(ringGeometry419, ringMaterial419);

	function setCircleRotation419(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.5490196078431373],[0.,0.,0.53921568627450989]);

        ringMesh419.position.setX(incenter[0]);
        ringMesh419.position.setY(incenter[1]);
        ringMesh419.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex163(), getVertex164());
        var relRadius = inradius/inradius419;

        ringMesh419.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A419 = new THREE.Vector3(0.,1.,1.);
        const B419 = new THREE.Vector3(0.,0.,0.5490196078431373);
        const C419 = new THREE.Vector3(0.,0.,0.53921568627450989);

        const normalVec419 = new THREE.Vector3();
        normalVec419.crossVectors(B419.sub(A419), C419.sub(A419));
        normalVec419.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal419 = new THREE.Vector3(0,0,1);

        const quaternionRotation419 = new THREE.Quaternion();
        quaternionRotation419.setFromUnitVectors(initialNormal419, normalVec419);

        ringMesh419.setRotationFromQuaternion(quaternionRotation419);

        return quaternionRotation419;
    }

    ringRoot.add(ringMesh419);
            
	var inradius420 = calulateInradius(getVertex116(), getVertex171(), getVertex172());
	var incenter420 = calulateIncenter(getVertex116(), getVertex171(), getVertex172());
	var ringGeometry420 = new THREE.RingGeometry((inradius420 - 0.005),inradius420, 32);
	const ringMaterial420 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh420 = new THREE.Mesh(ringGeometry420, ringMaterial420);

	function setCircleRotation420(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.47058823529411764],[0.,0.,0.46078431372549022]);

        ringMesh420.position.setX(incenter[0]);
        ringMesh420.position.setY(incenter[1]);
        ringMesh420.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex171(), getVertex172());
        var relRadius = inradius/inradius420;

        ringMesh420.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A420 = new THREE.Vector3(0.,1.,0.);
        const B420 = new THREE.Vector3(0.,0.,0.47058823529411764);
        const C420 = new THREE.Vector3(0.,0.,0.46078431372549022);

        const normalVec420 = new THREE.Vector3();
        normalVec420.crossVectors(B420.sub(A420), C420.sub(A420));
        normalVec420.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal420 = new THREE.Vector3(0,0,1);

        const quaternionRotation420 = new THREE.Quaternion();
        quaternionRotation420.setFromUnitVectors(initialNormal420, normalVec420);

        ringMesh420.setRotationFromQuaternion(quaternionRotation420);

        return quaternionRotation420;
    }

    ringRoot.add(ringMesh420);
            
	var inradius421 = calulateInradius(getVertex117(), getVertex164(), getVertex165());
	var incenter421 = calulateIncenter(getVertex117(), getVertex164(), getVertex165());
	var ringGeometry421 = new THREE.RingGeometry((inradius421 - 0.005),inradius421, 32);
	const ringMaterial421 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh421 = new THREE.Mesh(ringGeometry421, ringMaterial421);

	function setCircleRotation421(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.53921568627450989],[0.,0.,0.52941176470588236]);

        ringMesh421.position.setX(incenter[0]);
        ringMesh421.position.setY(incenter[1]);
        ringMesh421.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex164(), getVertex165());
        var relRadius = inradius/inradius421;

        ringMesh421.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A421 = new THREE.Vector3(0.,1.,1.);
        const B421 = new THREE.Vector3(0.,0.,0.53921568627450989);
        const C421 = new THREE.Vector3(0.,0.,0.52941176470588236);

        const normalVec421 = new THREE.Vector3();
        normalVec421.crossVectors(B421.sub(A421), C421.sub(A421));
        normalVec421.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal421 = new THREE.Vector3(0,0,1);

        const quaternionRotation421 = new THREE.Quaternion();
        quaternionRotation421.setFromUnitVectors(initialNormal421, normalVec421);

        ringMesh421.setRotationFromQuaternion(quaternionRotation421);

        return quaternionRotation421;
    }

    ringRoot.add(ringMesh421);
            
	var inradius422 = calulateInradius(getVertex116(), getVertex170(), getVertex171());
	var incenter422 = calulateIncenter(getVertex116(), getVertex170(), getVertex171());
	var ringGeometry422 = new THREE.RingGeometry((inradius422 - 0.005),inradius422, 32);
	const ringMaterial422 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh422 = new THREE.Mesh(ringGeometry422, ringMaterial422);

	function setCircleRotation422(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.48039215686274506],[0.,0.,0.47058823529411764]);

        ringMesh422.position.setX(incenter[0]);
        ringMesh422.position.setY(incenter[1]);
        ringMesh422.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex170(), getVertex171());
        var relRadius = inradius/inradius422;

        ringMesh422.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A422 = new THREE.Vector3(0.,1.,0.);
        const B422 = new THREE.Vector3(0.,0.,0.48039215686274506);
        const C422 = new THREE.Vector3(0.,0.,0.47058823529411764);

        const normalVec422 = new THREE.Vector3();
        normalVec422.crossVectors(B422.sub(A422), C422.sub(A422));
        normalVec422.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal422 = new THREE.Vector3(0,0,1);

        const quaternionRotation422 = new THREE.Quaternion();
        quaternionRotation422.setFromUnitVectors(initialNormal422, normalVec422);

        ringMesh422.setRotationFromQuaternion(quaternionRotation422);

        return quaternionRotation422;
    }

    ringRoot.add(ringMesh422);
            
	var inradius423 = calulateInradius(getVertex117(), getVertex165(), getVertex166());
	var incenter423 = calulateIncenter(getVertex117(), getVertex165(), getVertex166());
	var ringGeometry423 = new THREE.RingGeometry((inradius423 - 0.005),inradius423, 32);
	const ringMaterial423 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh423 = new THREE.Mesh(ringGeometry423, ringMaterial423);

	function setCircleRotation423(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.52941176470588236],[0.,0.,0.51960784313725483]);

        ringMesh423.position.setX(incenter[0]);
        ringMesh423.position.setY(incenter[1]);
        ringMesh423.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex165(), getVertex166());
        var relRadius = inradius/inradius423;

        ringMesh423.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A423 = new THREE.Vector3(0.,1.,1.);
        const B423 = new THREE.Vector3(0.,0.,0.52941176470588236);
        const C423 = new THREE.Vector3(0.,0.,0.51960784313725483);

        const normalVec423 = new THREE.Vector3();
        normalVec423.crossVectors(B423.sub(A423), C423.sub(A423));
        normalVec423.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal423 = new THREE.Vector3(0,0,1);

        const quaternionRotation423 = new THREE.Quaternion();
        quaternionRotation423.setFromUnitVectors(initialNormal423, normalVec423);

        ringMesh423.setRotationFromQuaternion(quaternionRotation423);

        return quaternionRotation423;
    }

    ringRoot.add(ringMesh423);
            
	var inradius424 = calulateInradius(getVertex116(), getVertex169(), getVertex170());
	var incenter424 = calulateIncenter(getVertex116(), getVertex169(), getVertex170());
	var ringGeometry424 = new THREE.RingGeometry((inradius424 - 0.005),inradius424, 32);
	const ringMaterial424 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh424 = new THREE.Mesh(ringGeometry424, ringMaterial424);

	function setCircleRotation424(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.49019607843137258],[0.,0.,0.48039215686274506]);

        ringMesh424.position.setX(incenter[0]);
        ringMesh424.position.setY(incenter[1]);
        ringMesh424.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex169(), getVertex170());
        var relRadius = inradius/inradius424;

        ringMesh424.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A424 = new THREE.Vector3(0.,1.,0.);
        const B424 = new THREE.Vector3(0.,0.,0.49019607843137258);
        const C424 = new THREE.Vector3(0.,0.,0.48039215686274506);

        const normalVec424 = new THREE.Vector3();
        normalVec424.crossVectors(B424.sub(A424), C424.sub(A424));
        normalVec424.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal424 = new THREE.Vector3(0,0,1);

        const quaternionRotation424 = new THREE.Quaternion();
        quaternionRotation424.setFromUnitVectors(initialNormal424, normalVec424);

        ringMesh424.setRotationFromQuaternion(quaternionRotation424);

        return quaternionRotation424;
    }

    ringRoot.add(ringMesh424);
            
	var inradius425 = calulateInradius(getVertex117(), getVertex166(), getVertex167());
	var incenter425 = calulateIncenter(getVertex117(), getVertex166(), getVertex167());
	var ringGeometry425 = new THREE.RingGeometry((inradius425 - 0.005),inradius425, 32);
	const ringMaterial425 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh425 = new THREE.Mesh(ringGeometry425, ringMaterial425);

	function setCircleRotation425(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.51960784313725483],[0.,0.,0.50980392156862742]);

        ringMesh425.position.setX(incenter[0]);
        ringMesh425.position.setY(incenter[1]);
        ringMesh425.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex166(), getVertex167());
        var relRadius = inradius/inradius425;

        ringMesh425.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A425 = new THREE.Vector3(0.,1.,1.);
        const B425 = new THREE.Vector3(0.,0.,0.51960784313725483);
        const C425 = new THREE.Vector3(0.,0.,0.50980392156862742);

        const normalVec425 = new THREE.Vector3();
        normalVec425.crossVectors(B425.sub(A425), C425.sub(A425));
        normalVec425.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal425 = new THREE.Vector3(0,0,1);

        const quaternionRotation425 = new THREE.Quaternion();
        quaternionRotation425.setFromUnitVectors(initialNormal425, normalVec425);

        ringMesh425.setRotationFromQuaternion(quaternionRotation425);

        return quaternionRotation425;
    }

    ringRoot.add(ringMesh425);
            
	var inradius426 = calulateInradius(getVertex116(), getVertex168(), getVertex169());
	var incenter426 = calulateIncenter(getVertex116(), getVertex168(), getVertex169());
	var ringGeometry426 = new THREE.RingGeometry((inradius426 - 0.005),inradius426, 32);
	const ringMaterial426 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh426 = new THREE.Mesh(ringGeometry426, ringMaterial426);

	function setCircleRotation426(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.5],[0.,0.,0.49019607843137258]);

        ringMesh426.position.setX(incenter[0]);
        ringMesh426.position.setY(incenter[1]);
        ringMesh426.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex168(), getVertex169());
        var relRadius = inradius/inradius426;

        ringMesh426.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A426 = new THREE.Vector3(0.,1.,0.);
        const B426 = new THREE.Vector3(0.,0.,0.5);
        const C426 = new THREE.Vector3(0.,0.,0.49019607843137258);

        const normalVec426 = new THREE.Vector3();
        normalVec426.crossVectors(B426.sub(A426), C426.sub(A426));
        normalVec426.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal426 = new THREE.Vector3(0,0,1);

        const quaternionRotation426 = new THREE.Quaternion();
        quaternionRotation426.setFromUnitVectors(initialNormal426, normalVec426);

        ringMesh426.setRotationFromQuaternion(quaternionRotation426);

        return quaternionRotation426;
    }

    ringRoot.add(ringMesh426);
            
	var inradius427 = calulateInradius(getVertex117(), getVertex167(), getVertex168());
	var incenter427 = calulateIncenter(getVertex117(), getVertex167(), getVertex168());
	var ringGeometry427 = new THREE.RingGeometry((inradius427 - 0.005),inradius427, 32);
	const ringMaterial427 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh427 = new THREE.Mesh(ringGeometry427, ringMaterial427);

	function setCircleRotation427(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.50980392156862742],[0.,0.,0.5]);

        ringMesh427.position.setX(incenter[0]);
        ringMesh427.position.setY(incenter[1]);
        ringMesh427.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex117(), getVertex167(), getVertex168());
        var relRadius = inradius/inradius427;

        ringMesh427.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A427 = new THREE.Vector3(0.,1.,1.);
        const B427 = new THREE.Vector3(0.,0.,0.50980392156862742);
        const C427 = new THREE.Vector3(0.,0.,0.5);

        const normalVec427 = new THREE.Vector3();
        normalVec427.crossVectors(B427.sub(A427), C427.sub(A427));
        normalVec427.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal427 = new THREE.Vector3(0,0,1);

        const quaternionRotation427 = new THREE.Quaternion();
        quaternionRotation427.setFromUnitVectors(initialNormal427, normalVec427);

        ringMesh427.setRotationFromQuaternion(quaternionRotation427);

        return quaternionRotation427;
    }

    ringRoot.add(ringMesh427);
            
	var inradius428 = calulateInradius(getVertex116(), getVertex117(), getVertex168());
	var incenter428 = calulateIncenter(getVertex116(), getVertex117(), getVertex168());
	var ringGeometry428 = new THREE.RingGeometry((inradius428 - 0.005),inradius428, 32);
	const ringMaterial428 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh428 = new THREE.Mesh(ringGeometry428, ringMaterial428);

	function setCircleRotation428(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.,1.,0.],[ 0.,1.,1.],[0.,0.,0.5]);

        ringMesh428.position.setX(incenter[0]);
        ringMesh428.position.setY(incenter[1]);
        ringMesh428.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex116(), getVertex117(), getVertex168());
        var relRadius = inradius/inradius428;

        ringMesh428.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A428 = new THREE.Vector3(0.,1.,0.);
        const B428 = new THREE.Vector3(0.,1.,1.);
        const C428 = new THREE.Vector3(0.,0.,0.5);

        const normalVec428 = new THREE.Vector3();
        normalVec428.crossVectors(B428.sub(A428), C428.sub(A428));
        normalVec428.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal428 = new THREE.Vector3(0,0,1);

        const quaternionRotation428 = new THREE.Quaternion();
        quaternionRotation428.setFromUnitVectors(initialNormal428, normalVec428);

        ringMesh428.setRotationFromQuaternion(quaternionRotation428);

        return quaternionRotation428;
    }

    ringRoot.add(ringMesh428);
            	// function to update the circles every frame 
	function updateCircles(){
		setCircleRotation1();
		setCircleRotation2();
		setCircleRotation3();
		setCircleRotation4();
		setCircleRotation5();
		setCircleRotation6();
		setCircleRotation7();
		setCircleRotation8();
		setCircleRotation9();
		setCircleRotation10();
		setCircleRotation11();
		setCircleRotation12();
		setCircleRotation13();
		setCircleRotation14();
		setCircleRotation15();
		setCircleRotation16();
		setCircleRotation17();
		setCircleRotation18();
		setCircleRotation19();
		setCircleRotation20();
		setCircleRotation21();
		setCircleRotation22();
		setCircleRotation23();
		setCircleRotation24();
		setCircleRotation25();
		setCircleRotation26();
		setCircleRotation27();
		setCircleRotation28();
		setCircleRotation29();
		setCircleRotation30();
		setCircleRotation31();
		setCircleRotation32();
		setCircleRotation33();
		setCircleRotation34();
		setCircleRotation35();
		setCircleRotation36();
		setCircleRotation37();
		setCircleRotation38();
		setCircleRotation39();
		setCircleRotation40();
		setCircleRotation41();
		setCircleRotation42();
		setCircleRotation43();
		setCircleRotation44();
		setCircleRotation45();
		setCircleRotation46();
		setCircleRotation47();
		setCircleRotation48();
		setCircleRotation49();
		setCircleRotation50();
		setCircleRotation51();
		setCircleRotation52();
		setCircleRotation53();
		setCircleRotation54();
		setCircleRotation55();
		setCircleRotation56();
		setCircleRotation57();
		setCircleRotation58();
		setCircleRotation59();
		setCircleRotation60();
		setCircleRotation61();
		setCircleRotation62();
		setCircleRotation63();
		setCircleRotation64();
		setCircleRotation65();
		setCircleRotation66();
		setCircleRotation67();
		setCircleRotation68();
		setCircleRotation69();
		setCircleRotation70();
		setCircleRotation71();
		setCircleRotation72();
		setCircleRotation73();
		setCircleRotation74();
		setCircleRotation75();
		setCircleRotation76();
		setCircleRotation77();
		setCircleRotation78();
		setCircleRotation79();
		setCircleRotation80();
		setCircleRotation81();
		setCircleRotation82();
		setCircleRotation83();
		setCircleRotation84();
		setCircleRotation85();
		setCircleRotation86();
		setCircleRotation87();
		setCircleRotation88();
		setCircleRotation89();
		setCircleRotation90();
		setCircleRotation91();
		setCircleRotation92();
		setCircleRotation93();
		setCircleRotation94();
		setCircleRotation95();
		setCircleRotation96();
		setCircleRotation97();
		setCircleRotation98();
		setCircleRotation99();
		setCircleRotation100();
		setCircleRotation101();
		setCircleRotation102();
		setCircleRotation103();
		setCircleRotation104();
		setCircleRotation105();
		setCircleRotation106();
		setCircleRotation107();
		setCircleRotation108();
		setCircleRotation109();
		setCircleRotation110();
		setCircleRotation111();
		setCircleRotation112();
		setCircleRotation113();
		setCircleRotation114();
		setCircleRotation115();
		setCircleRotation116();
		setCircleRotation117();
		setCircleRotation118();
		setCircleRotation119();
		setCircleRotation120();
		setCircleRotation121();
		setCircleRotation122();
		setCircleRotation123();
		setCircleRotation124();
		setCircleRotation125();
		setCircleRotation126();
		setCircleRotation127();
		setCircleRotation128();
		setCircleRotation129();
		setCircleRotation130();
		setCircleRotation131();
		setCircleRotation132();
		setCircleRotation133();
		setCircleRotation134();
		setCircleRotation135();
		setCircleRotation136();
		setCircleRotation137();
		setCircleRotation138();
		setCircleRotation139();
		setCircleRotation140();
		setCircleRotation141();
		setCircleRotation142();
		setCircleRotation143();
		setCircleRotation144();
		setCircleRotation145();
		setCircleRotation146();
		setCircleRotation147();
		setCircleRotation148();
		setCircleRotation149();
		setCircleRotation150();
		setCircleRotation151();
		setCircleRotation152();
		setCircleRotation153();
		setCircleRotation154();
		setCircleRotation155();
		setCircleRotation156();
		setCircleRotation157();
		setCircleRotation158();
		setCircleRotation159();
		setCircleRotation160();
		setCircleRotation161();
		setCircleRotation162();
		setCircleRotation163();
		setCircleRotation164();
		setCircleRotation165();
		setCircleRotation166();
		setCircleRotation167();
		setCircleRotation168();
		setCircleRotation169();
		setCircleRotation170();
		setCircleRotation171();
		setCircleRotation172();
		setCircleRotation173();
		setCircleRotation174();
		setCircleRotation175();
		setCircleRotation176();
		setCircleRotation177();
		setCircleRotation178();
		setCircleRotation179();
		setCircleRotation180();
		setCircleRotation181();
		setCircleRotation182();
		setCircleRotation183();
		setCircleRotation184();
		setCircleRotation185();
		setCircleRotation186();
		setCircleRotation187();
		setCircleRotation188();
		setCircleRotation189();
		setCircleRotation190();
		setCircleRotation191();
		setCircleRotation192();
		setCircleRotation193();
		setCircleRotation194();
		setCircleRotation195();
		setCircleRotation196();
		setCircleRotation197();
		setCircleRotation198();
		setCircleRotation199();
		setCircleRotation200();
		setCircleRotation201();
		setCircleRotation202();
		setCircleRotation203();
		setCircleRotation204();
		setCircleRotation205();
		setCircleRotation206();
		setCircleRotation207();
		setCircleRotation208();
		setCircleRotation209();
		setCircleRotation210();
		setCircleRotation211();
		setCircleRotation212();
		setCircleRotation213();
		setCircleRotation214();
		setCircleRotation215();
		setCircleRotation216();
		setCircleRotation217();
		setCircleRotation218();
		setCircleRotation219();
		setCircleRotation220();
		setCircleRotation221();
		setCircleRotation222();
		setCircleRotation223();
		setCircleRotation224();
		setCircleRotation225();
		setCircleRotation226();
		setCircleRotation227();
		setCircleRotation228();
		setCircleRotation229();
		setCircleRotation230();
		setCircleRotation231();
		setCircleRotation232();
		setCircleRotation233();
		setCircleRotation234();
		setCircleRotation235();
		setCircleRotation236();
		setCircleRotation237();
		setCircleRotation238();
		setCircleRotation239();
		setCircleRotation240();
		setCircleRotation241();
		setCircleRotation242();
		setCircleRotation243();
		setCircleRotation244();
		setCircleRotation245();
		setCircleRotation246();
		setCircleRotation247();
		setCircleRotation248();
		setCircleRotation249();
		setCircleRotation250();
		setCircleRotation251();
		setCircleRotation252();
		setCircleRotation253();
		setCircleRotation254();
		setCircleRotation255();
		setCircleRotation256();
		setCircleRotation257();
		setCircleRotation258();
		setCircleRotation259();
		setCircleRotation260();
		setCircleRotation261();
		setCircleRotation262();
		setCircleRotation263();
		setCircleRotation264();
		setCircleRotation265();
		setCircleRotation266();
		setCircleRotation267();
		setCircleRotation268();
		setCircleRotation269();
		setCircleRotation270();
		setCircleRotation271();
		setCircleRotation272();
		setCircleRotation273();
		setCircleRotation274();
		setCircleRotation275();
		setCircleRotation276();
		setCircleRotation277();
		setCircleRotation278();
		setCircleRotation279();
		setCircleRotation280();
		setCircleRotation281();
		setCircleRotation282();
		setCircleRotation283();
		setCircleRotation284();
		setCircleRotation285();
		setCircleRotation286();
		setCircleRotation287();
		setCircleRotation288();
		setCircleRotation289();
		setCircleRotation290();
		setCircleRotation291();
		setCircleRotation292();
		setCircleRotation293();
		setCircleRotation294();
		setCircleRotation295();
		setCircleRotation296();
		setCircleRotation297();
		setCircleRotation298();
		setCircleRotation299();
		setCircleRotation300();
		setCircleRotation301();
		setCircleRotation302();
		setCircleRotation303();
		setCircleRotation304();
		setCircleRotation305();
		setCircleRotation306();
		setCircleRotation307();
		setCircleRotation308();
		setCircleRotation309();
		setCircleRotation310();
		setCircleRotation311();
		setCircleRotation312();
		setCircleRotation313();
		setCircleRotation314();
		setCircleRotation315();
		setCircleRotation316();
		setCircleRotation317();
		setCircleRotation318();
		setCircleRotation319();
		setCircleRotation320();
		setCircleRotation321();
		setCircleRotation322();
		setCircleRotation323();
		setCircleRotation324();
		setCircleRotation325();
		setCircleRotation326();
		setCircleRotation327();
		setCircleRotation328();
		setCircleRotation329();
		setCircleRotation330();
		setCircleRotation331();
		setCircleRotation332();
		setCircleRotation333();
		setCircleRotation334();
		setCircleRotation335();
		setCircleRotation336();
		setCircleRotation337();
		setCircleRotation338();
		setCircleRotation339();
		setCircleRotation340();
		setCircleRotation341();
		setCircleRotation342();
		setCircleRotation343();
		setCircleRotation344();
		setCircleRotation345();
		setCircleRotation346();
		setCircleRotation347();
		setCircleRotation348();
		setCircleRotation349();
		setCircleRotation350();
		setCircleRotation351();
		setCircleRotation352();
		setCircleRotation353();
		setCircleRotation354();
		setCircleRotation355();
		setCircleRotation356();
		setCircleRotation357();
		setCircleRotation358();
		setCircleRotation359();
		setCircleRotation360();
		setCircleRotation361();
		setCircleRotation362();
		setCircleRotation363();
		setCircleRotation364();
		setCircleRotation365();
		setCircleRotation366();
		setCircleRotation367();
		setCircleRotation368();
		setCircleRotation369();
		setCircleRotation370();
		setCircleRotation371();
		setCircleRotation372();
		setCircleRotation373();
		setCircleRotation374();
		setCircleRotation375();
		setCircleRotation376();
		setCircleRotation377();
		setCircleRotation378();
		setCircleRotation379();
		setCircleRotation380();
		setCircleRotation381();
		setCircleRotation382();
		setCircleRotation383();
		setCircleRotation384();
		setCircleRotation385();
		setCircleRotation386();
		setCircleRotation387();
		setCircleRotation388();
		setCircleRotation389();
		setCircleRotation390();
		setCircleRotation391();
		setCircleRotation392();
		setCircleRotation393();
		setCircleRotation394();
		setCircleRotation395();
		setCircleRotation396();
		setCircleRotation397();
		setCircleRotation398();
		setCircleRotation399();
		setCircleRotation400();
		setCircleRotation401();
		setCircleRotation402();
		setCircleRotation403();
		setCircleRotation404();
		setCircleRotation405();
		setCircleRotation406();
		setCircleRotation407();
		setCircleRotation408();
		setCircleRotation409();
		setCircleRotation410();
		setCircleRotation411();
		setCircleRotation412();
		setCircleRotation413();
		setCircleRotation414();
		setCircleRotation415();
		setCircleRotation416();
		setCircleRotation417();
		setCircleRotation418();
		setCircleRotation419();
		setCircleRotation420();
		setCircleRotation421();
		setCircleRotation422();
		setCircleRotation423();
		setCircleRotation424();
		setCircleRotation425();
		setCircleRotation426();
		setCircleRotation427();
		setCircleRotation428();
	}

	// needs to be called once to be initialized 
	updateCircles();

	// function to update the circles width, that is called every frame even if the surface is not parameterized 
	function updateCircleWidth(){
		ringGeometry1.dispose();
		ringGeometry1 = new THREE.RingGeometry((inradius1 - guiParameters.circleWidth),inradius1, 32);
		ringMesh1.geometry = ringGeometry1; 
		ringGeometry2.dispose();
		ringGeometry2 = new THREE.RingGeometry((inradius2 - guiParameters.circleWidth),inradius2, 32);
		ringMesh2.geometry = ringGeometry2; 
		ringGeometry3.dispose();
		ringGeometry3 = new THREE.RingGeometry((inradius3 - guiParameters.circleWidth),inradius3, 32);
		ringMesh3.geometry = ringGeometry3; 
		ringGeometry4.dispose();
		ringGeometry4 = new THREE.RingGeometry((inradius4 - guiParameters.circleWidth),inradius4, 32);
		ringMesh4.geometry = ringGeometry4; 
		ringGeometry5.dispose();
		ringGeometry5 = new THREE.RingGeometry((inradius5 - guiParameters.circleWidth),inradius5, 32);
		ringMesh5.geometry = ringGeometry5; 
		ringGeometry6.dispose();
		ringGeometry6 = new THREE.RingGeometry((inradius6 - guiParameters.circleWidth),inradius6, 32);
		ringMesh6.geometry = ringGeometry6; 
		ringGeometry7.dispose();
		ringGeometry7 = new THREE.RingGeometry((inradius7 - guiParameters.circleWidth),inradius7, 32);
		ringMesh7.geometry = ringGeometry7; 
		ringGeometry8.dispose();
		ringGeometry8 = new THREE.RingGeometry((inradius8 - guiParameters.circleWidth),inradius8, 32);
		ringMesh8.geometry = ringGeometry8; 
		ringGeometry9.dispose();
		ringGeometry9 = new THREE.RingGeometry((inradius9 - guiParameters.circleWidth),inradius9, 32);
		ringMesh9.geometry = ringGeometry9; 
		ringGeometry10.dispose();
		ringGeometry10 = new THREE.RingGeometry((inradius10 - guiParameters.circleWidth),inradius10, 32);
		ringMesh10.geometry = ringGeometry10; 
		ringGeometry11.dispose();
		ringGeometry11 = new THREE.RingGeometry((inradius11 - guiParameters.circleWidth),inradius11, 32);
		ringMesh11.geometry = ringGeometry11; 
		ringGeometry12.dispose();
		ringGeometry12 = new THREE.RingGeometry((inradius12 - guiParameters.circleWidth),inradius12, 32);
		ringMesh12.geometry = ringGeometry12; 
		ringGeometry13.dispose();
		ringGeometry13 = new THREE.RingGeometry((inradius13 - guiParameters.circleWidth),inradius13, 32);
		ringMesh13.geometry = ringGeometry13; 
		ringGeometry14.dispose();
		ringGeometry14 = new THREE.RingGeometry((inradius14 - guiParameters.circleWidth),inradius14, 32);
		ringMesh14.geometry = ringGeometry14; 
		ringGeometry15.dispose();
		ringGeometry15 = new THREE.RingGeometry((inradius15 - guiParameters.circleWidth),inradius15, 32);
		ringMesh15.geometry = ringGeometry15; 
		ringGeometry16.dispose();
		ringGeometry16 = new THREE.RingGeometry((inradius16 - guiParameters.circleWidth),inradius16, 32);
		ringMesh16.geometry = ringGeometry16; 
		ringGeometry17.dispose();
		ringGeometry17 = new THREE.RingGeometry((inradius17 - guiParameters.circleWidth),inradius17, 32);
		ringMesh17.geometry = ringGeometry17; 
		ringGeometry18.dispose();
		ringGeometry18 = new THREE.RingGeometry((inradius18 - guiParameters.circleWidth),inradius18, 32);
		ringMesh18.geometry = ringGeometry18; 
		ringGeometry19.dispose();
		ringGeometry19 = new THREE.RingGeometry((inradius19 - guiParameters.circleWidth),inradius19, 32);
		ringMesh19.geometry = ringGeometry19; 
		ringGeometry20.dispose();
		ringGeometry20 = new THREE.RingGeometry((inradius20 - guiParameters.circleWidth),inradius20, 32);
		ringMesh20.geometry = ringGeometry20; 
		ringGeometry21.dispose();
		ringGeometry21 = new THREE.RingGeometry((inradius21 - guiParameters.circleWidth),inradius21, 32);
		ringMesh21.geometry = ringGeometry21; 
		ringGeometry22.dispose();
		ringGeometry22 = new THREE.RingGeometry((inradius22 - guiParameters.circleWidth),inradius22, 32);
		ringMesh22.geometry = ringGeometry22; 
		ringGeometry23.dispose();
		ringGeometry23 = new THREE.RingGeometry((inradius23 - guiParameters.circleWidth),inradius23, 32);
		ringMesh23.geometry = ringGeometry23; 
		ringGeometry24.dispose();
		ringGeometry24 = new THREE.RingGeometry((inradius24 - guiParameters.circleWidth),inradius24, 32);
		ringMesh24.geometry = ringGeometry24; 
		ringGeometry25.dispose();
		ringGeometry25 = new THREE.RingGeometry((inradius25 - guiParameters.circleWidth),inradius25, 32);
		ringMesh25.geometry = ringGeometry25; 
		ringGeometry26.dispose();
		ringGeometry26 = new THREE.RingGeometry((inradius26 - guiParameters.circleWidth),inradius26, 32);
		ringMesh26.geometry = ringGeometry26; 
		ringGeometry27.dispose();
		ringGeometry27 = new THREE.RingGeometry((inradius27 - guiParameters.circleWidth),inradius27, 32);
		ringMesh27.geometry = ringGeometry27; 
		ringGeometry28.dispose();
		ringGeometry28 = new THREE.RingGeometry((inradius28 - guiParameters.circleWidth),inradius28, 32);
		ringMesh28.geometry = ringGeometry28; 
		ringGeometry29.dispose();
		ringGeometry29 = new THREE.RingGeometry((inradius29 - guiParameters.circleWidth),inradius29, 32);
		ringMesh29.geometry = ringGeometry29; 
		ringGeometry30.dispose();
		ringGeometry30 = new THREE.RingGeometry((inradius30 - guiParameters.circleWidth),inradius30, 32);
		ringMesh30.geometry = ringGeometry30; 
		ringGeometry31.dispose();
		ringGeometry31 = new THREE.RingGeometry((inradius31 - guiParameters.circleWidth),inradius31, 32);
		ringMesh31.geometry = ringGeometry31; 
		ringGeometry32.dispose();
		ringGeometry32 = new THREE.RingGeometry((inradius32 - guiParameters.circleWidth),inradius32, 32);
		ringMesh32.geometry = ringGeometry32; 
		ringGeometry33.dispose();
		ringGeometry33 = new THREE.RingGeometry((inradius33 - guiParameters.circleWidth),inradius33, 32);
		ringMesh33.geometry = ringGeometry33; 
		ringGeometry34.dispose();
		ringGeometry34 = new THREE.RingGeometry((inradius34 - guiParameters.circleWidth),inradius34, 32);
		ringMesh34.geometry = ringGeometry34; 
		ringGeometry35.dispose();
		ringGeometry35 = new THREE.RingGeometry((inradius35 - guiParameters.circleWidth),inradius35, 32);
		ringMesh35.geometry = ringGeometry35; 
		ringGeometry36.dispose();
		ringGeometry36 = new THREE.RingGeometry((inradius36 - guiParameters.circleWidth),inradius36, 32);
		ringMesh36.geometry = ringGeometry36; 
		ringGeometry37.dispose();
		ringGeometry37 = new THREE.RingGeometry((inradius37 - guiParameters.circleWidth),inradius37, 32);
		ringMesh37.geometry = ringGeometry37; 
		ringGeometry38.dispose();
		ringGeometry38 = new THREE.RingGeometry((inradius38 - guiParameters.circleWidth),inradius38, 32);
		ringMesh38.geometry = ringGeometry38; 
		ringGeometry39.dispose();
		ringGeometry39 = new THREE.RingGeometry((inradius39 - guiParameters.circleWidth),inradius39, 32);
		ringMesh39.geometry = ringGeometry39; 
		ringGeometry40.dispose();
		ringGeometry40 = new THREE.RingGeometry((inradius40 - guiParameters.circleWidth),inradius40, 32);
		ringMesh40.geometry = ringGeometry40; 
		ringGeometry41.dispose();
		ringGeometry41 = new THREE.RingGeometry((inradius41 - guiParameters.circleWidth),inradius41, 32);
		ringMesh41.geometry = ringGeometry41; 
		ringGeometry42.dispose();
		ringGeometry42 = new THREE.RingGeometry((inradius42 - guiParameters.circleWidth),inradius42, 32);
		ringMesh42.geometry = ringGeometry42; 
		ringGeometry43.dispose();
		ringGeometry43 = new THREE.RingGeometry((inradius43 - guiParameters.circleWidth),inradius43, 32);
		ringMesh43.geometry = ringGeometry43; 
		ringGeometry44.dispose();
		ringGeometry44 = new THREE.RingGeometry((inradius44 - guiParameters.circleWidth),inradius44, 32);
		ringMesh44.geometry = ringGeometry44; 
		ringGeometry45.dispose();
		ringGeometry45 = new THREE.RingGeometry((inradius45 - guiParameters.circleWidth),inradius45, 32);
		ringMesh45.geometry = ringGeometry45; 
		ringGeometry46.dispose();
		ringGeometry46 = new THREE.RingGeometry((inradius46 - guiParameters.circleWidth),inradius46, 32);
		ringMesh46.geometry = ringGeometry46; 
		ringGeometry47.dispose();
		ringGeometry47 = new THREE.RingGeometry((inradius47 - guiParameters.circleWidth),inradius47, 32);
		ringMesh47.geometry = ringGeometry47; 
		ringGeometry48.dispose();
		ringGeometry48 = new THREE.RingGeometry((inradius48 - guiParameters.circleWidth),inradius48, 32);
		ringMesh48.geometry = ringGeometry48; 
		ringGeometry49.dispose();
		ringGeometry49 = new THREE.RingGeometry((inradius49 - guiParameters.circleWidth),inradius49, 32);
		ringMesh49.geometry = ringGeometry49; 
		ringGeometry50.dispose();
		ringGeometry50 = new THREE.RingGeometry((inradius50 - guiParameters.circleWidth),inradius50, 32);
		ringMesh50.geometry = ringGeometry50; 
		ringGeometry51.dispose();
		ringGeometry51 = new THREE.RingGeometry((inradius51 - guiParameters.circleWidth),inradius51, 32);
		ringMesh51.geometry = ringGeometry51; 
		ringGeometry52.dispose();
		ringGeometry52 = new THREE.RingGeometry((inradius52 - guiParameters.circleWidth),inradius52, 32);
		ringMesh52.geometry = ringGeometry52; 
		ringGeometry53.dispose();
		ringGeometry53 = new THREE.RingGeometry((inradius53 - guiParameters.circleWidth),inradius53, 32);
		ringMesh53.geometry = ringGeometry53; 
		ringGeometry54.dispose();
		ringGeometry54 = new THREE.RingGeometry((inradius54 - guiParameters.circleWidth),inradius54, 32);
		ringMesh54.geometry = ringGeometry54; 
		ringGeometry55.dispose();
		ringGeometry55 = new THREE.RingGeometry((inradius55 - guiParameters.circleWidth),inradius55, 32);
		ringMesh55.geometry = ringGeometry55; 
		ringGeometry56.dispose();
		ringGeometry56 = new THREE.RingGeometry((inradius56 - guiParameters.circleWidth),inradius56, 32);
		ringMesh56.geometry = ringGeometry56; 
		ringGeometry57.dispose();
		ringGeometry57 = new THREE.RingGeometry((inradius57 - guiParameters.circleWidth),inradius57, 32);
		ringMesh57.geometry = ringGeometry57; 
		ringGeometry58.dispose();
		ringGeometry58 = new THREE.RingGeometry((inradius58 - guiParameters.circleWidth),inradius58, 32);
		ringMesh58.geometry = ringGeometry58; 
		ringGeometry59.dispose();
		ringGeometry59 = new THREE.RingGeometry((inradius59 - guiParameters.circleWidth),inradius59, 32);
		ringMesh59.geometry = ringGeometry59; 
		ringGeometry60.dispose();
		ringGeometry60 = new THREE.RingGeometry((inradius60 - guiParameters.circleWidth),inradius60, 32);
		ringMesh60.geometry = ringGeometry60; 
		ringGeometry61.dispose();
		ringGeometry61 = new THREE.RingGeometry((inradius61 - guiParameters.circleWidth),inradius61, 32);
		ringMesh61.geometry = ringGeometry61; 
		ringGeometry62.dispose();
		ringGeometry62 = new THREE.RingGeometry((inradius62 - guiParameters.circleWidth),inradius62, 32);
		ringMesh62.geometry = ringGeometry62; 
		ringGeometry63.dispose();
		ringGeometry63 = new THREE.RingGeometry((inradius63 - guiParameters.circleWidth),inradius63, 32);
		ringMesh63.geometry = ringGeometry63; 
		ringGeometry64.dispose();
		ringGeometry64 = new THREE.RingGeometry((inradius64 - guiParameters.circleWidth),inradius64, 32);
		ringMesh64.geometry = ringGeometry64; 
		ringGeometry65.dispose();
		ringGeometry65 = new THREE.RingGeometry((inradius65 - guiParameters.circleWidth),inradius65, 32);
		ringMesh65.geometry = ringGeometry65; 
		ringGeometry66.dispose();
		ringGeometry66 = new THREE.RingGeometry((inradius66 - guiParameters.circleWidth),inradius66, 32);
		ringMesh66.geometry = ringGeometry66; 
		ringGeometry67.dispose();
		ringGeometry67 = new THREE.RingGeometry((inradius67 - guiParameters.circleWidth),inradius67, 32);
		ringMesh67.geometry = ringGeometry67; 
		ringGeometry68.dispose();
		ringGeometry68 = new THREE.RingGeometry((inradius68 - guiParameters.circleWidth),inradius68, 32);
		ringMesh68.geometry = ringGeometry68; 
		ringGeometry69.dispose();
		ringGeometry69 = new THREE.RingGeometry((inradius69 - guiParameters.circleWidth),inradius69, 32);
		ringMesh69.geometry = ringGeometry69; 
		ringGeometry70.dispose();
		ringGeometry70 = new THREE.RingGeometry((inradius70 - guiParameters.circleWidth),inradius70, 32);
		ringMesh70.geometry = ringGeometry70; 
		ringGeometry71.dispose();
		ringGeometry71 = new THREE.RingGeometry((inradius71 - guiParameters.circleWidth),inradius71, 32);
		ringMesh71.geometry = ringGeometry71; 
		ringGeometry72.dispose();
		ringGeometry72 = new THREE.RingGeometry((inradius72 - guiParameters.circleWidth),inradius72, 32);
		ringMesh72.geometry = ringGeometry72; 
		ringGeometry73.dispose();
		ringGeometry73 = new THREE.RingGeometry((inradius73 - guiParameters.circleWidth),inradius73, 32);
		ringMesh73.geometry = ringGeometry73; 
		ringGeometry74.dispose();
		ringGeometry74 = new THREE.RingGeometry((inradius74 - guiParameters.circleWidth),inradius74, 32);
		ringMesh74.geometry = ringGeometry74; 
		ringGeometry75.dispose();
		ringGeometry75 = new THREE.RingGeometry((inradius75 - guiParameters.circleWidth),inradius75, 32);
		ringMesh75.geometry = ringGeometry75; 
		ringGeometry76.dispose();
		ringGeometry76 = new THREE.RingGeometry((inradius76 - guiParameters.circleWidth),inradius76, 32);
		ringMesh76.geometry = ringGeometry76; 
		ringGeometry77.dispose();
		ringGeometry77 = new THREE.RingGeometry((inradius77 - guiParameters.circleWidth),inradius77, 32);
		ringMesh77.geometry = ringGeometry77; 
		ringGeometry78.dispose();
		ringGeometry78 = new THREE.RingGeometry((inradius78 - guiParameters.circleWidth),inradius78, 32);
		ringMesh78.geometry = ringGeometry78; 
		ringGeometry79.dispose();
		ringGeometry79 = new THREE.RingGeometry((inradius79 - guiParameters.circleWidth),inradius79, 32);
		ringMesh79.geometry = ringGeometry79; 
		ringGeometry80.dispose();
		ringGeometry80 = new THREE.RingGeometry((inradius80 - guiParameters.circleWidth),inradius80, 32);
		ringMesh80.geometry = ringGeometry80; 
		ringGeometry81.dispose();
		ringGeometry81 = new THREE.RingGeometry((inradius81 - guiParameters.circleWidth),inradius81, 32);
		ringMesh81.geometry = ringGeometry81; 
		ringGeometry82.dispose();
		ringGeometry82 = new THREE.RingGeometry((inradius82 - guiParameters.circleWidth),inradius82, 32);
		ringMesh82.geometry = ringGeometry82; 
		ringGeometry83.dispose();
		ringGeometry83 = new THREE.RingGeometry((inradius83 - guiParameters.circleWidth),inradius83, 32);
		ringMesh83.geometry = ringGeometry83; 
		ringGeometry84.dispose();
		ringGeometry84 = new THREE.RingGeometry((inradius84 - guiParameters.circleWidth),inradius84, 32);
		ringMesh84.geometry = ringGeometry84; 
		ringGeometry85.dispose();
		ringGeometry85 = new THREE.RingGeometry((inradius85 - guiParameters.circleWidth),inradius85, 32);
		ringMesh85.geometry = ringGeometry85; 
		ringGeometry86.dispose();
		ringGeometry86 = new THREE.RingGeometry((inradius86 - guiParameters.circleWidth),inradius86, 32);
		ringMesh86.geometry = ringGeometry86; 
		ringGeometry87.dispose();
		ringGeometry87 = new THREE.RingGeometry((inradius87 - guiParameters.circleWidth),inradius87, 32);
		ringMesh87.geometry = ringGeometry87; 
		ringGeometry88.dispose();
		ringGeometry88 = new THREE.RingGeometry((inradius88 - guiParameters.circleWidth),inradius88, 32);
		ringMesh88.geometry = ringGeometry88; 
		ringGeometry89.dispose();
		ringGeometry89 = new THREE.RingGeometry((inradius89 - guiParameters.circleWidth),inradius89, 32);
		ringMesh89.geometry = ringGeometry89; 
		ringGeometry90.dispose();
		ringGeometry90 = new THREE.RingGeometry((inradius90 - guiParameters.circleWidth),inradius90, 32);
		ringMesh90.geometry = ringGeometry90; 
		ringGeometry91.dispose();
		ringGeometry91 = new THREE.RingGeometry((inradius91 - guiParameters.circleWidth),inradius91, 32);
		ringMesh91.geometry = ringGeometry91; 
		ringGeometry92.dispose();
		ringGeometry92 = new THREE.RingGeometry((inradius92 - guiParameters.circleWidth),inradius92, 32);
		ringMesh92.geometry = ringGeometry92; 
		ringGeometry93.dispose();
		ringGeometry93 = new THREE.RingGeometry((inradius93 - guiParameters.circleWidth),inradius93, 32);
		ringMesh93.geometry = ringGeometry93; 
		ringGeometry94.dispose();
		ringGeometry94 = new THREE.RingGeometry((inradius94 - guiParameters.circleWidth),inradius94, 32);
		ringMesh94.geometry = ringGeometry94; 
		ringGeometry95.dispose();
		ringGeometry95 = new THREE.RingGeometry((inradius95 - guiParameters.circleWidth),inradius95, 32);
		ringMesh95.geometry = ringGeometry95; 
		ringGeometry96.dispose();
		ringGeometry96 = new THREE.RingGeometry((inradius96 - guiParameters.circleWidth),inradius96, 32);
		ringMesh96.geometry = ringGeometry96; 
		ringGeometry97.dispose();
		ringGeometry97 = new THREE.RingGeometry((inradius97 - guiParameters.circleWidth),inradius97, 32);
		ringMesh97.geometry = ringGeometry97; 
		ringGeometry98.dispose();
		ringGeometry98 = new THREE.RingGeometry((inradius98 - guiParameters.circleWidth),inradius98, 32);
		ringMesh98.geometry = ringGeometry98; 
		ringGeometry99.dispose();
		ringGeometry99 = new THREE.RingGeometry((inradius99 - guiParameters.circleWidth),inradius99, 32);
		ringMesh99.geometry = ringGeometry99; 
		ringGeometry100.dispose();
		ringGeometry100 = new THREE.RingGeometry((inradius100 - guiParameters.circleWidth),inradius100, 32);
		ringMesh100.geometry = ringGeometry100; 
		ringGeometry101.dispose();
		ringGeometry101 = new THREE.RingGeometry((inradius101 - guiParameters.circleWidth),inradius101, 32);
		ringMesh101.geometry = ringGeometry101; 
		ringGeometry102.dispose();
		ringGeometry102 = new THREE.RingGeometry((inradius102 - guiParameters.circleWidth),inradius102, 32);
		ringMesh102.geometry = ringGeometry102; 
		ringGeometry103.dispose();
		ringGeometry103 = new THREE.RingGeometry((inradius103 - guiParameters.circleWidth),inradius103, 32);
		ringMesh103.geometry = ringGeometry103; 
		ringGeometry104.dispose();
		ringGeometry104 = new THREE.RingGeometry((inradius104 - guiParameters.circleWidth),inradius104, 32);
		ringMesh104.geometry = ringGeometry104; 
		ringGeometry105.dispose();
		ringGeometry105 = new THREE.RingGeometry((inradius105 - guiParameters.circleWidth),inradius105, 32);
		ringMesh105.geometry = ringGeometry105; 
		ringGeometry106.dispose();
		ringGeometry106 = new THREE.RingGeometry((inradius106 - guiParameters.circleWidth),inradius106, 32);
		ringMesh106.geometry = ringGeometry106; 
		ringGeometry107.dispose();
		ringGeometry107 = new THREE.RingGeometry((inradius107 - guiParameters.circleWidth),inradius107, 32);
		ringMesh107.geometry = ringGeometry107; 
		ringGeometry108.dispose();
		ringGeometry108 = new THREE.RingGeometry((inradius108 - guiParameters.circleWidth),inradius108, 32);
		ringMesh108.geometry = ringGeometry108; 
		ringGeometry109.dispose();
		ringGeometry109 = new THREE.RingGeometry((inradius109 - guiParameters.circleWidth),inradius109, 32);
		ringMesh109.geometry = ringGeometry109; 
		ringGeometry110.dispose();
		ringGeometry110 = new THREE.RingGeometry((inradius110 - guiParameters.circleWidth),inradius110, 32);
		ringMesh110.geometry = ringGeometry110; 
		ringGeometry111.dispose();
		ringGeometry111 = new THREE.RingGeometry((inradius111 - guiParameters.circleWidth),inradius111, 32);
		ringMesh111.geometry = ringGeometry111; 
		ringGeometry112.dispose();
		ringGeometry112 = new THREE.RingGeometry((inradius112 - guiParameters.circleWidth),inradius112, 32);
		ringMesh112.geometry = ringGeometry112; 
		ringGeometry113.dispose();
		ringGeometry113 = new THREE.RingGeometry((inradius113 - guiParameters.circleWidth),inradius113, 32);
		ringMesh113.geometry = ringGeometry113; 
		ringGeometry114.dispose();
		ringGeometry114 = new THREE.RingGeometry((inradius114 - guiParameters.circleWidth),inradius114, 32);
		ringMesh114.geometry = ringGeometry114; 
		ringGeometry115.dispose();
		ringGeometry115 = new THREE.RingGeometry((inradius115 - guiParameters.circleWidth),inradius115, 32);
		ringMesh115.geometry = ringGeometry115; 
		ringGeometry116.dispose();
		ringGeometry116 = new THREE.RingGeometry((inradius116 - guiParameters.circleWidth),inradius116, 32);
		ringMesh116.geometry = ringGeometry116; 
		ringGeometry117.dispose();
		ringGeometry117 = new THREE.RingGeometry((inradius117 - guiParameters.circleWidth),inradius117, 32);
		ringMesh117.geometry = ringGeometry117; 
		ringGeometry118.dispose();
		ringGeometry118 = new THREE.RingGeometry((inradius118 - guiParameters.circleWidth),inradius118, 32);
		ringMesh118.geometry = ringGeometry118; 
		ringGeometry119.dispose();
		ringGeometry119 = new THREE.RingGeometry((inradius119 - guiParameters.circleWidth),inradius119, 32);
		ringMesh119.geometry = ringGeometry119; 
		ringGeometry120.dispose();
		ringGeometry120 = new THREE.RingGeometry((inradius120 - guiParameters.circleWidth),inradius120, 32);
		ringMesh120.geometry = ringGeometry120; 
		ringGeometry121.dispose();
		ringGeometry121 = new THREE.RingGeometry((inradius121 - guiParameters.circleWidth),inradius121, 32);
		ringMesh121.geometry = ringGeometry121; 
		ringGeometry122.dispose();
		ringGeometry122 = new THREE.RingGeometry((inradius122 - guiParameters.circleWidth),inradius122, 32);
		ringMesh122.geometry = ringGeometry122; 
		ringGeometry123.dispose();
		ringGeometry123 = new THREE.RingGeometry((inradius123 - guiParameters.circleWidth),inradius123, 32);
		ringMesh123.geometry = ringGeometry123; 
		ringGeometry124.dispose();
		ringGeometry124 = new THREE.RingGeometry((inradius124 - guiParameters.circleWidth),inradius124, 32);
		ringMesh124.geometry = ringGeometry124; 
		ringGeometry125.dispose();
		ringGeometry125 = new THREE.RingGeometry((inradius125 - guiParameters.circleWidth),inradius125, 32);
		ringMesh125.geometry = ringGeometry125; 
		ringGeometry126.dispose();
		ringGeometry126 = new THREE.RingGeometry((inradius126 - guiParameters.circleWidth),inradius126, 32);
		ringMesh126.geometry = ringGeometry126; 
		ringGeometry127.dispose();
		ringGeometry127 = new THREE.RingGeometry((inradius127 - guiParameters.circleWidth),inradius127, 32);
		ringMesh127.geometry = ringGeometry127; 
		ringGeometry128.dispose();
		ringGeometry128 = new THREE.RingGeometry((inradius128 - guiParameters.circleWidth),inradius128, 32);
		ringMesh128.geometry = ringGeometry128; 
		ringGeometry129.dispose();
		ringGeometry129 = new THREE.RingGeometry((inradius129 - guiParameters.circleWidth),inradius129, 32);
		ringMesh129.geometry = ringGeometry129; 
		ringGeometry130.dispose();
		ringGeometry130 = new THREE.RingGeometry((inradius130 - guiParameters.circleWidth),inradius130, 32);
		ringMesh130.geometry = ringGeometry130; 
		ringGeometry131.dispose();
		ringGeometry131 = new THREE.RingGeometry((inradius131 - guiParameters.circleWidth),inradius131, 32);
		ringMesh131.geometry = ringGeometry131; 
		ringGeometry132.dispose();
		ringGeometry132 = new THREE.RingGeometry((inradius132 - guiParameters.circleWidth),inradius132, 32);
		ringMesh132.geometry = ringGeometry132; 
		ringGeometry133.dispose();
		ringGeometry133 = new THREE.RingGeometry((inradius133 - guiParameters.circleWidth),inradius133, 32);
		ringMesh133.geometry = ringGeometry133; 
		ringGeometry134.dispose();
		ringGeometry134 = new THREE.RingGeometry((inradius134 - guiParameters.circleWidth),inradius134, 32);
		ringMesh134.geometry = ringGeometry134; 
		ringGeometry135.dispose();
		ringGeometry135 = new THREE.RingGeometry((inradius135 - guiParameters.circleWidth),inradius135, 32);
		ringMesh135.geometry = ringGeometry135; 
		ringGeometry136.dispose();
		ringGeometry136 = new THREE.RingGeometry((inradius136 - guiParameters.circleWidth),inradius136, 32);
		ringMesh136.geometry = ringGeometry136; 
		ringGeometry137.dispose();
		ringGeometry137 = new THREE.RingGeometry((inradius137 - guiParameters.circleWidth),inradius137, 32);
		ringMesh137.geometry = ringGeometry137; 
		ringGeometry138.dispose();
		ringGeometry138 = new THREE.RingGeometry((inradius138 - guiParameters.circleWidth),inradius138, 32);
		ringMesh138.geometry = ringGeometry138; 
		ringGeometry139.dispose();
		ringGeometry139 = new THREE.RingGeometry((inradius139 - guiParameters.circleWidth),inradius139, 32);
		ringMesh139.geometry = ringGeometry139; 
		ringGeometry140.dispose();
		ringGeometry140 = new THREE.RingGeometry((inradius140 - guiParameters.circleWidth),inradius140, 32);
		ringMesh140.geometry = ringGeometry140; 
		ringGeometry141.dispose();
		ringGeometry141 = new THREE.RingGeometry((inradius141 - guiParameters.circleWidth),inradius141, 32);
		ringMesh141.geometry = ringGeometry141; 
		ringGeometry142.dispose();
		ringGeometry142 = new THREE.RingGeometry((inradius142 - guiParameters.circleWidth),inradius142, 32);
		ringMesh142.geometry = ringGeometry142; 
		ringGeometry143.dispose();
		ringGeometry143 = new THREE.RingGeometry((inradius143 - guiParameters.circleWidth),inradius143, 32);
		ringMesh143.geometry = ringGeometry143; 
		ringGeometry144.dispose();
		ringGeometry144 = new THREE.RingGeometry((inradius144 - guiParameters.circleWidth),inradius144, 32);
		ringMesh144.geometry = ringGeometry144; 
		ringGeometry145.dispose();
		ringGeometry145 = new THREE.RingGeometry((inradius145 - guiParameters.circleWidth),inradius145, 32);
		ringMesh145.geometry = ringGeometry145; 
		ringGeometry146.dispose();
		ringGeometry146 = new THREE.RingGeometry((inradius146 - guiParameters.circleWidth),inradius146, 32);
		ringMesh146.geometry = ringGeometry146; 
		ringGeometry147.dispose();
		ringGeometry147 = new THREE.RingGeometry((inradius147 - guiParameters.circleWidth),inradius147, 32);
		ringMesh147.geometry = ringGeometry147; 
		ringGeometry148.dispose();
		ringGeometry148 = new THREE.RingGeometry((inradius148 - guiParameters.circleWidth),inradius148, 32);
		ringMesh148.geometry = ringGeometry148; 
		ringGeometry149.dispose();
		ringGeometry149 = new THREE.RingGeometry((inradius149 - guiParameters.circleWidth),inradius149, 32);
		ringMesh149.geometry = ringGeometry149; 
		ringGeometry150.dispose();
		ringGeometry150 = new THREE.RingGeometry((inradius150 - guiParameters.circleWidth),inradius150, 32);
		ringMesh150.geometry = ringGeometry150; 
		ringGeometry151.dispose();
		ringGeometry151 = new THREE.RingGeometry((inradius151 - guiParameters.circleWidth),inradius151, 32);
		ringMesh151.geometry = ringGeometry151; 
		ringGeometry152.dispose();
		ringGeometry152 = new THREE.RingGeometry((inradius152 - guiParameters.circleWidth),inradius152, 32);
		ringMesh152.geometry = ringGeometry152; 
		ringGeometry153.dispose();
		ringGeometry153 = new THREE.RingGeometry((inradius153 - guiParameters.circleWidth),inradius153, 32);
		ringMesh153.geometry = ringGeometry153; 
		ringGeometry154.dispose();
		ringGeometry154 = new THREE.RingGeometry((inradius154 - guiParameters.circleWidth),inradius154, 32);
		ringMesh154.geometry = ringGeometry154; 
		ringGeometry155.dispose();
		ringGeometry155 = new THREE.RingGeometry((inradius155 - guiParameters.circleWidth),inradius155, 32);
		ringMesh155.geometry = ringGeometry155; 
		ringGeometry156.dispose();
		ringGeometry156 = new THREE.RingGeometry((inradius156 - guiParameters.circleWidth),inradius156, 32);
		ringMesh156.geometry = ringGeometry156; 
		ringGeometry157.dispose();
		ringGeometry157 = new THREE.RingGeometry((inradius157 - guiParameters.circleWidth),inradius157, 32);
		ringMesh157.geometry = ringGeometry157; 
		ringGeometry158.dispose();
		ringGeometry158 = new THREE.RingGeometry((inradius158 - guiParameters.circleWidth),inradius158, 32);
		ringMesh158.geometry = ringGeometry158; 
		ringGeometry159.dispose();
		ringGeometry159 = new THREE.RingGeometry((inradius159 - guiParameters.circleWidth),inradius159, 32);
		ringMesh159.geometry = ringGeometry159; 
		ringGeometry160.dispose();
		ringGeometry160 = new THREE.RingGeometry((inradius160 - guiParameters.circleWidth),inradius160, 32);
		ringMesh160.geometry = ringGeometry160; 
		ringGeometry161.dispose();
		ringGeometry161 = new THREE.RingGeometry((inradius161 - guiParameters.circleWidth),inradius161, 32);
		ringMesh161.geometry = ringGeometry161; 
		ringGeometry162.dispose();
		ringGeometry162 = new THREE.RingGeometry((inradius162 - guiParameters.circleWidth),inradius162, 32);
		ringMesh162.geometry = ringGeometry162; 
		ringGeometry163.dispose();
		ringGeometry163 = new THREE.RingGeometry((inradius163 - guiParameters.circleWidth),inradius163, 32);
		ringMesh163.geometry = ringGeometry163; 
		ringGeometry164.dispose();
		ringGeometry164 = new THREE.RingGeometry((inradius164 - guiParameters.circleWidth),inradius164, 32);
		ringMesh164.geometry = ringGeometry164; 
		ringGeometry165.dispose();
		ringGeometry165 = new THREE.RingGeometry((inradius165 - guiParameters.circleWidth),inradius165, 32);
		ringMesh165.geometry = ringGeometry165; 
		ringGeometry166.dispose();
		ringGeometry166 = new THREE.RingGeometry((inradius166 - guiParameters.circleWidth),inradius166, 32);
		ringMesh166.geometry = ringGeometry166; 
		ringGeometry167.dispose();
		ringGeometry167 = new THREE.RingGeometry((inradius167 - guiParameters.circleWidth),inradius167, 32);
		ringMesh167.geometry = ringGeometry167; 
		ringGeometry168.dispose();
		ringGeometry168 = new THREE.RingGeometry((inradius168 - guiParameters.circleWidth),inradius168, 32);
		ringMesh168.geometry = ringGeometry168; 
		ringGeometry169.dispose();
		ringGeometry169 = new THREE.RingGeometry((inradius169 - guiParameters.circleWidth),inradius169, 32);
		ringMesh169.geometry = ringGeometry169; 
		ringGeometry170.dispose();
		ringGeometry170 = new THREE.RingGeometry((inradius170 - guiParameters.circleWidth),inradius170, 32);
		ringMesh170.geometry = ringGeometry170; 
		ringGeometry171.dispose();
		ringGeometry171 = new THREE.RingGeometry((inradius171 - guiParameters.circleWidth),inradius171, 32);
		ringMesh171.geometry = ringGeometry171; 
		ringGeometry172.dispose();
		ringGeometry172 = new THREE.RingGeometry((inradius172 - guiParameters.circleWidth),inradius172, 32);
		ringMesh172.geometry = ringGeometry172; 
		ringGeometry173.dispose();
		ringGeometry173 = new THREE.RingGeometry((inradius173 - guiParameters.circleWidth),inradius173, 32);
		ringMesh173.geometry = ringGeometry173; 
		ringGeometry174.dispose();
		ringGeometry174 = new THREE.RingGeometry((inradius174 - guiParameters.circleWidth),inradius174, 32);
		ringMesh174.geometry = ringGeometry174; 
		ringGeometry175.dispose();
		ringGeometry175 = new THREE.RingGeometry((inradius175 - guiParameters.circleWidth),inradius175, 32);
		ringMesh175.geometry = ringGeometry175; 
		ringGeometry176.dispose();
		ringGeometry176 = new THREE.RingGeometry((inradius176 - guiParameters.circleWidth),inradius176, 32);
		ringMesh176.geometry = ringGeometry176; 
		ringGeometry177.dispose();
		ringGeometry177 = new THREE.RingGeometry((inradius177 - guiParameters.circleWidth),inradius177, 32);
		ringMesh177.geometry = ringGeometry177; 
		ringGeometry178.dispose();
		ringGeometry178 = new THREE.RingGeometry((inradius178 - guiParameters.circleWidth),inradius178, 32);
		ringMesh178.geometry = ringGeometry178; 
		ringGeometry179.dispose();
		ringGeometry179 = new THREE.RingGeometry((inradius179 - guiParameters.circleWidth),inradius179, 32);
		ringMesh179.geometry = ringGeometry179; 
		ringGeometry180.dispose();
		ringGeometry180 = new THREE.RingGeometry((inradius180 - guiParameters.circleWidth),inradius180, 32);
		ringMesh180.geometry = ringGeometry180; 
		ringGeometry181.dispose();
		ringGeometry181 = new THREE.RingGeometry((inradius181 - guiParameters.circleWidth),inradius181, 32);
		ringMesh181.geometry = ringGeometry181; 
		ringGeometry182.dispose();
		ringGeometry182 = new THREE.RingGeometry((inradius182 - guiParameters.circleWidth),inradius182, 32);
		ringMesh182.geometry = ringGeometry182; 
		ringGeometry183.dispose();
		ringGeometry183 = new THREE.RingGeometry((inradius183 - guiParameters.circleWidth),inradius183, 32);
		ringMesh183.geometry = ringGeometry183; 
		ringGeometry184.dispose();
		ringGeometry184 = new THREE.RingGeometry((inradius184 - guiParameters.circleWidth),inradius184, 32);
		ringMesh184.geometry = ringGeometry184; 
		ringGeometry185.dispose();
		ringGeometry185 = new THREE.RingGeometry((inradius185 - guiParameters.circleWidth),inradius185, 32);
		ringMesh185.geometry = ringGeometry185; 
		ringGeometry186.dispose();
		ringGeometry186 = new THREE.RingGeometry((inradius186 - guiParameters.circleWidth),inradius186, 32);
		ringMesh186.geometry = ringGeometry186; 
		ringGeometry187.dispose();
		ringGeometry187 = new THREE.RingGeometry((inradius187 - guiParameters.circleWidth),inradius187, 32);
		ringMesh187.geometry = ringGeometry187; 
		ringGeometry188.dispose();
		ringGeometry188 = new THREE.RingGeometry((inradius188 - guiParameters.circleWidth),inradius188, 32);
		ringMesh188.geometry = ringGeometry188; 
		ringGeometry189.dispose();
		ringGeometry189 = new THREE.RingGeometry((inradius189 - guiParameters.circleWidth),inradius189, 32);
		ringMesh189.geometry = ringGeometry189; 
		ringGeometry190.dispose();
		ringGeometry190 = new THREE.RingGeometry((inradius190 - guiParameters.circleWidth),inradius190, 32);
		ringMesh190.geometry = ringGeometry190; 
		ringGeometry191.dispose();
		ringGeometry191 = new THREE.RingGeometry((inradius191 - guiParameters.circleWidth),inradius191, 32);
		ringMesh191.geometry = ringGeometry191; 
		ringGeometry192.dispose();
		ringGeometry192 = new THREE.RingGeometry((inradius192 - guiParameters.circleWidth),inradius192, 32);
		ringMesh192.geometry = ringGeometry192; 
		ringGeometry193.dispose();
		ringGeometry193 = new THREE.RingGeometry((inradius193 - guiParameters.circleWidth),inradius193, 32);
		ringMesh193.geometry = ringGeometry193; 
		ringGeometry194.dispose();
		ringGeometry194 = new THREE.RingGeometry((inradius194 - guiParameters.circleWidth),inradius194, 32);
		ringMesh194.geometry = ringGeometry194; 
		ringGeometry195.dispose();
		ringGeometry195 = new THREE.RingGeometry((inradius195 - guiParameters.circleWidth),inradius195, 32);
		ringMesh195.geometry = ringGeometry195; 
		ringGeometry196.dispose();
		ringGeometry196 = new THREE.RingGeometry((inradius196 - guiParameters.circleWidth),inradius196, 32);
		ringMesh196.geometry = ringGeometry196; 
		ringGeometry197.dispose();
		ringGeometry197 = new THREE.RingGeometry((inradius197 - guiParameters.circleWidth),inradius197, 32);
		ringMesh197.geometry = ringGeometry197; 
		ringGeometry198.dispose();
		ringGeometry198 = new THREE.RingGeometry((inradius198 - guiParameters.circleWidth),inradius198, 32);
		ringMesh198.geometry = ringGeometry198; 
		ringGeometry199.dispose();
		ringGeometry199 = new THREE.RingGeometry((inradius199 - guiParameters.circleWidth),inradius199, 32);
		ringMesh199.geometry = ringGeometry199; 
		ringGeometry200.dispose();
		ringGeometry200 = new THREE.RingGeometry((inradius200 - guiParameters.circleWidth),inradius200, 32);
		ringMesh200.geometry = ringGeometry200; 
		ringGeometry201.dispose();
		ringGeometry201 = new THREE.RingGeometry((inradius201 - guiParameters.circleWidth),inradius201, 32);
		ringMesh201.geometry = ringGeometry201; 
		ringGeometry202.dispose();
		ringGeometry202 = new THREE.RingGeometry((inradius202 - guiParameters.circleWidth),inradius202, 32);
		ringMesh202.geometry = ringGeometry202; 
		ringGeometry203.dispose();
		ringGeometry203 = new THREE.RingGeometry((inradius203 - guiParameters.circleWidth),inradius203, 32);
		ringMesh203.geometry = ringGeometry203; 
		ringGeometry204.dispose();
		ringGeometry204 = new THREE.RingGeometry((inradius204 - guiParameters.circleWidth),inradius204, 32);
		ringMesh204.geometry = ringGeometry204; 
		ringGeometry205.dispose();
		ringGeometry205 = new THREE.RingGeometry((inradius205 - guiParameters.circleWidth),inradius205, 32);
		ringMesh205.geometry = ringGeometry205; 
		ringGeometry206.dispose();
		ringGeometry206 = new THREE.RingGeometry((inradius206 - guiParameters.circleWidth),inradius206, 32);
		ringMesh206.geometry = ringGeometry206; 
		ringGeometry207.dispose();
		ringGeometry207 = new THREE.RingGeometry((inradius207 - guiParameters.circleWidth),inradius207, 32);
		ringMesh207.geometry = ringGeometry207; 
		ringGeometry208.dispose();
		ringGeometry208 = new THREE.RingGeometry((inradius208 - guiParameters.circleWidth),inradius208, 32);
		ringMesh208.geometry = ringGeometry208; 
		ringGeometry209.dispose();
		ringGeometry209 = new THREE.RingGeometry((inradius209 - guiParameters.circleWidth),inradius209, 32);
		ringMesh209.geometry = ringGeometry209; 
		ringGeometry210.dispose();
		ringGeometry210 = new THREE.RingGeometry((inradius210 - guiParameters.circleWidth),inradius210, 32);
		ringMesh210.geometry = ringGeometry210; 
		ringGeometry211.dispose();
		ringGeometry211 = new THREE.RingGeometry((inradius211 - guiParameters.circleWidth),inradius211, 32);
		ringMesh211.geometry = ringGeometry211; 
		ringGeometry212.dispose();
		ringGeometry212 = new THREE.RingGeometry((inradius212 - guiParameters.circleWidth),inradius212, 32);
		ringMesh212.geometry = ringGeometry212; 
		ringGeometry213.dispose();
		ringGeometry213 = new THREE.RingGeometry((inradius213 - guiParameters.circleWidth),inradius213, 32);
		ringMesh213.geometry = ringGeometry213; 
		ringGeometry214.dispose();
		ringGeometry214 = new THREE.RingGeometry((inradius214 - guiParameters.circleWidth),inradius214, 32);
		ringMesh214.geometry = ringGeometry214; 
		ringGeometry215.dispose();
		ringGeometry215 = new THREE.RingGeometry((inradius215 - guiParameters.circleWidth),inradius215, 32);
		ringMesh215.geometry = ringGeometry215; 
		ringGeometry216.dispose();
		ringGeometry216 = new THREE.RingGeometry((inradius216 - guiParameters.circleWidth),inradius216, 32);
		ringMesh216.geometry = ringGeometry216; 
		ringGeometry217.dispose();
		ringGeometry217 = new THREE.RingGeometry((inradius217 - guiParameters.circleWidth),inradius217, 32);
		ringMesh217.geometry = ringGeometry217; 
		ringGeometry218.dispose();
		ringGeometry218 = new THREE.RingGeometry((inradius218 - guiParameters.circleWidth),inradius218, 32);
		ringMesh218.geometry = ringGeometry218; 
		ringGeometry219.dispose();
		ringGeometry219 = new THREE.RingGeometry((inradius219 - guiParameters.circleWidth),inradius219, 32);
		ringMesh219.geometry = ringGeometry219; 
		ringGeometry220.dispose();
		ringGeometry220 = new THREE.RingGeometry((inradius220 - guiParameters.circleWidth),inradius220, 32);
		ringMesh220.geometry = ringGeometry220; 
		ringGeometry221.dispose();
		ringGeometry221 = new THREE.RingGeometry((inradius221 - guiParameters.circleWidth),inradius221, 32);
		ringMesh221.geometry = ringGeometry221; 
		ringGeometry222.dispose();
		ringGeometry222 = new THREE.RingGeometry((inradius222 - guiParameters.circleWidth),inradius222, 32);
		ringMesh222.geometry = ringGeometry222; 
		ringGeometry223.dispose();
		ringGeometry223 = new THREE.RingGeometry((inradius223 - guiParameters.circleWidth),inradius223, 32);
		ringMesh223.geometry = ringGeometry223; 
		ringGeometry224.dispose();
		ringGeometry224 = new THREE.RingGeometry((inradius224 - guiParameters.circleWidth),inradius224, 32);
		ringMesh224.geometry = ringGeometry224; 
		ringGeometry225.dispose();
		ringGeometry225 = new THREE.RingGeometry((inradius225 - guiParameters.circleWidth),inradius225, 32);
		ringMesh225.geometry = ringGeometry225; 
		ringGeometry226.dispose();
		ringGeometry226 = new THREE.RingGeometry((inradius226 - guiParameters.circleWidth),inradius226, 32);
		ringMesh226.geometry = ringGeometry226; 
		ringGeometry227.dispose();
		ringGeometry227 = new THREE.RingGeometry((inradius227 - guiParameters.circleWidth),inradius227, 32);
		ringMesh227.geometry = ringGeometry227; 
		ringGeometry228.dispose();
		ringGeometry228 = new THREE.RingGeometry((inradius228 - guiParameters.circleWidth),inradius228, 32);
		ringMesh228.geometry = ringGeometry228; 
		ringGeometry229.dispose();
		ringGeometry229 = new THREE.RingGeometry((inradius229 - guiParameters.circleWidth),inradius229, 32);
		ringMesh229.geometry = ringGeometry229; 
		ringGeometry230.dispose();
		ringGeometry230 = new THREE.RingGeometry((inradius230 - guiParameters.circleWidth),inradius230, 32);
		ringMesh230.geometry = ringGeometry230; 
		ringGeometry231.dispose();
		ringGeometry231 = new THREE.RingGeometry((inradius231 - guiParameters.circleWidth),inradius231, 32);
		ringMesh231.geometry = ringGeometry231; 
		ringGeometry232.dispose();
		ringGeometry232 = new THREE.RingGeometry((inradius232 - guiParameters.circleWidth),inradius232, 32);
		ringMesh232.geometry = ringGeometry232; 
		ringGeometry233.dispose();
		ringGeometry233 = new THREE.RingGeometry((inradius233 - guiParameters.circleWidth),inradius233, 32);
		ringMesh233.geometry = ringGeometry233; 
		ringGeometry234.dispose();
		ringGeometry234 = new THREE.RingGeometry((inradius234 - guiParameters.circleWidth),inradius234, 32);
		ringMesh234.geometry = ringGeometry234; 
		ringGeometry235.dispose();
		ringGeometry235 = new THREE.RingGeometry((inradius235 - guiParameters.circleWidth),inradius235, 32);
		ringMesh235.geometry = ringGeometry235; 
		ringGeometry236.dispose();
		ringGeometry236 = new THREE.RingGeometry((inradius236 - guiParameters.circleWidth),inradius236, 32);
		ringMesh236.geometry = ringGeometry236; 
		ringGeometry237.dispose();
		ringGeometry237 = new THREE.RingGeometry((inradius237 - guiParameters.circleWidth),inradius237, 32);
		ringMesh237.geometry = ringGeometry237; 
		ringGeometry238.dispose();
		ringGeometry238 = new THREE.RingGeometry((inradius238 - guiParameters.circleWidth),inradius238, 32);
		ringMesh238.geometry = ringGeometry238; 
		ringGeometry239.dispose();
		ringGeometry239 = new THREE.RingGeometry((inradius239 - guiParameters.circleWidth),inradius239, 32);
		ringMesh239.geometry = ringGeometry239; 
		ringGeometry240.dispose();
		ringGeometry240 = new THREE.RingGeometry((inradius240 - guiParameters.circleWidth),inradius240, 32);
		ringMesh240.geometry = ringGeometry240; 
		ringGeometry241.dispose();
		ringGeometry241 = new THREE.RingGeometry((inradius241 - guiParameters.circleWidth),inradius241, 32);
		ringMesh241.geometry = ringGeometry241; 
		ringGeometry242.dispose();
		ringGeometry242 = new THREE.RingGeometry((inradius242 - guiParameters.circleWidth),inradius242, 32);
		ringMesh242.geometry = ringGeometry242; 
		ringGeometry243.dispose();
		ringGeometry243 = new THREE.RingGeometry((inradius243 - guiParameters.circleWidth),inradius243, 32);
		ringMesh243.geometry = ringGeometry243; 
		ringGeometry244.dispose();
		ringGeometry244 = new THREE.RingGeometry((inradius244 - guiParameters.circleWidth),inradius244, 32);
		ringMesh244.geometry = ringGeometry244; 
		ringGeometry245.dispose();
		ringGeometry245 = new THREE.RingGeometry((inradius245 - guiParameters.circleWidth),inradius245, 32);
		ringMesh245.geometry = ringGeometry245; 
		ringGeometry246.dispose();
		ringGeometry246 = new THREE.RingGeometry((inradius246 - guiParameters.circleWidth),inradius246, 32);
		ringMesh246.geometry = ringGeometry246; 
		ringGeometry247.dispose();
		ringGeometry247 = new THREE.RingGeometry((inradius247 - guiParameters.circleWidth),inradius247, 32);
		ringMesh247.geometry = ringGeometry247; 
		ringGeometry248.dispose();
		ringGeometry248 = new THREE.RingGeometry((inradius248 - guiParameters.circleWidth),inradius248, 32);
		ringMesh248.geometry = ringGeometry248; 
		ringGeometry249.dispose();
		ringGeometry249 = new THREE.RingGeometry((inradius249 - guiParameters.circleWidth),inradius249, 32);
		ringMesh249.geometry = ringGeometry249; 
		ringGeometry250.dispose();
		ringGeometry250 = new THREE.RingGeometry((inradius250 - guiParameters.circleWidth),inradius250, 32);
		ringMesh250.geometry = ringGeometry250; 
		ringGeometry251.dispose();
		ringGeometry251 = new THREE.RingGeometry((inradius251 - guiParameters.circleWidth),inradius251, 32);
		ringMesh251.geometry = ringGeometry251; 
		ringGeometry252.dispose();
		ringGeometry252 = new THREE.RingGeometry((inradius252 - guiParameters.circleWidth),inradius252, 32);
		ringMesh252.geometry = ringGeometry252; 
		ringGeometry253.dispose();
		ringGeometry253 = new THREE.RingGeometry((inradius253 - guiParameters.circleWidth),inradius253, 32);
		ringMesh253.geometry = ringGeometry253; 
		ringGeometry254.dispose();
		ringGeometry254 = new THREE.RingGeometry((inradius254 - guiParameters.circleWidth),inradius254, 32);
		ringMesh254.geometry = ringGeometry254; 
		ringGeometry255.dispose();
		ringGeometry255 = new THREE.RingGeometry((inradius255 - guiParameters.circleWidth),inradius255, 32);
		ringMesh255.geometry = ringGeometry255; 
		ringGeometry256.dispose();
		ringGeometry256 = new THREE.RingGeometry((inradius256 - guiParameters.circleWidth),inradius256, 32);
		ringMesh256.geometry = ringGeometry256; 
		ringGeometry257.dispose();
		ringGeometry257 = new THREE.RingGeometry((inradius257 - guiParameters.circleWidth),inradius257, 32);
		ringMesh257.geometry = ringGeometry257; 
		ringGeometry258.dispose();
		ringGeometry258 = new THREE.RingGeometry((inradius258 - guiParameters.circleWidth),inradius258, 32);
		ringMesh258.geometry = ringGeometry258; 
		ringGeometry259.dispose();
		ringGeometry259 = new THREE.RingGeometry((inradius259 - guiParameters.circleWidth),inradius259, 32);
		ringMesh259.geometry = ringGeometry259; 
		ringGeometry260.dispose();
		ringGeometry260 = new THREE.RingGeometry((inradius260 - guiParameters.circleWidth),inradius260, 32);
		ringMesh260.geometry = ringGeometry260; 
		ringGeometry261.dispose();
		ringGeometry261 = new THREE.RingGeometry((inradius261 - guiParameters.circleWidth),inradius261, 32);
		ringMesh261.geometry = ringGeometry261; 
		ringGeometry262.dispose();
		ringGeometry262 = new THREE.RingGeometry((inradius262 - guiParameters.circleWidth),inradius262, 32);
		ringMesh262.geometry = ringGeometry262; 
		ringGeometry263.dispose();
		ringGeometry263 = new THREE.RingGeometry((inradius263 - guiParameters.circleWidth),inradius263, 32);
		ringMesh263.geometry = ringGeometry263; 
		ringGeometry264.dispose();
		ringGeometry264 = new THREE.RingGeometry((inradius264 - guiParameters.circleWidth),inradius264, 32);
		ringMesh264.geometry = ringGeometry264; 
		ringGeometry265.dispose();
		ringGeometry265 = new THREE.RingGeometry((inradius265 - guiParameters.circleWidth),inradius265, 32);
		ringMesh265.geometry = ringGeometry265; 
		ringGeometry266.dispose();
		ringGeometry266 = new THREE.RingGeometry((inradius266 - guiParameters.circleWidth),inradius266, 32);
		ringMesh266.geometry = ringGeometry266; 
		ringGeometry267.dispose();
		ringGeometry267 = new THREE.RingGeometry((inradius267 - guiParameters.circleWidth),inradius267, 32);
		ringMesh267.geometry = ringGeometry267; 
		ringGeometry268.dispose();
		ringGeometry268 = new THREE.RingGeometry((inradius268 - guiParameters.circleWidth),inradius268, 32);
		ringMesh268.geometry = ringGeometry268; 
		ringGeometry269.dispose();
		ringGeometry269 = new THREE.RingGeometry((inradius269 - guiParameters.circleWidth),inradius269, 32);
		ringMesh269.geometry = ringGeometry269; 
		ringGeometry270.dispose();
		ringGeometry270 = new THREE.RingGeometry((inradius270 - guiParameters.circleWidth),inradius270, 32);
		ringMesh270.geometry = ringGeometry270; 
		ringGeometry271.dispose();
		ringGeometry271 = new THREE.RingGeometry((inradius271 - guiParameters.circleWidth),inradius271, 32);
		ringMesh271.geometry = ringGeometry271; 
		ringGeometry272.dispose();
		ringGeometry272 = new THREE.RingGeometry((inradius272 - guiParameters.circleWidth),inradius272, 32);
		ringMesh272.geometry = ringGeometry272; 
		ringGeometry273.dispose();
		ringGeometry273 = new THREE.RingGeometry((inradius273 - guiParameters.circleWidth),inradius273, 32);
		ringMesh273.geometry = ringGeometry273; 
		ringGeometry274.dispose();
		ringGeometry274 = new THREE.RingGeometry((inradius274 - guiParameters.circleWidth),inradius274, 32);
		ringMesh274.geometry = ringGeometry274; 
		ringGeometry275.dispose();
		ringGeometry275 = new THREE.RingGeometry((inradius275 - guiParameters.circleWidth),inradius275, 32);
		ringMesh275.geometry = ringGeometry275; 
		ringGeometry276.dispose();
		ringGeometry276 = new THREE.RingGeometry((inradius276 - guiParameters.circleWidth),inradius276, 32);
		ringMesh276.geometry = ringGeometry276; 
		ringGeometry277.dispose();
		ringGeometry277 = new THREE.RingGeometry((inradius277 - guiParameters.circleWidth),inradius277, 32);
		ringMesh277.geometry = ringGeometry277; 
		ringGeometry278.dispose();
		ringGeometry278 = new THREE.RingGeometry((inradius278 - guiParameters.circleWidth),inradius278, 32);
		ringMesh278.geometry = ringGeometry278; 
		ringGeometry279.dispose();
		ringGeometry279 = new THREE.RingGeometry((inradius279 - guiParameters.circleWidth),inradius279, 32);
		ringMesh279.geometry = ringGeometry279; 
		ringGeometry280.dispose();
		ringGeometry280 = new THREE.RingGeometry((inradius280 - guiParameters.circleWidth),inradius280, 32);
		ringMesh280.geometry = ringGeometry280; 
		ringGeometry281.dispose();
		ringGeometry281 = new THREE.RingGeometry((inradius281 - guiParameters.circleWidth),inradius281, 32);
		ringMesh281.geometry = ringGeometry281; 
		ringGeometry282.dispose();
		ringGeometry282 = new THREE.RingGeometry((inradius282 - guiParameters.circleWidth),inradius282, 32);
		ringMesh282.geometry = ringGeometry282; 
		ringGeometry283.dispose();
		ringGeometry283 = new THREE.RingGeometry((inradius283 - guiParameters.circleWidth),inradius283, 32);
		ringMesh283.geometry = ringGeometry283; 
		ringGeometry284.dispose();
		ringGeometry284 = new THREE.RingGeometry((inradius284 - guiParameters.circleWidth),inradius284, 32);
		ringMesh284.geometry = ringGeometry284; 
		ringGeometry285.dispose();
		ringGeometry285 = new THREE.RingGeometry((inradius285 - guiParameters.circleWidth),inradius285, 32);
		ringMesh285.geometry = ringGeometry285; 
		ringGeometry286.dispose();
		ringGeometry286 = new THREE.RingGeometry((inradius286 - guiParameters.circleWidth),inradius286, 32);
		ringMesh286.geometry = ringGeometry286; 
		ringGeometry287.dispose();
		ringGeometry287 = new THREE.RingGeometry((inradius287 - guiParameters.circleWidth),inradius287, 32);
		ringMesh287.geometry = ringGeometry287; 
		ringGeometry288.dispose();
		ringGeometry288 = new THREE.RingGeometry((inradius288 - guiParameters.circleWidth),inradius288, 32);
		ringMesh288.geometry = ringGeometry288; 
		ringGeometry289.dispose();
		ringGeometry289 = new THREE.RingGeometry((inradius289 - guiParameters.circleWidth),inradius289, 32);
		ringMesh289.geometry = ringGeometry289; 
		ringGeometry290.dispose();
		ringGeometry290 = new THREE.RingGeometry((inradius290 - guiParameters.circleWidth),inradius290, 32);
		ringMesh290.geometry = ringGeometry290; 
		ringGeometry291.dispose();
		ringGeometry291 = new THREE.RingGeometry((inradius291 - guiParameters.circleWidth),inradius291, 32);
		ringMesh291.geometry = ringGeometry291; 
		ringGeometry292.dispose();
		ringGeometry292 = new THREE.RingGeometry((inradius292 - guiParameters.circleWidth),inradius292, 32);
		ringMesh292.geometry = ringGeometry292; 
		ringGeometry293.dispose();
		ringGeometry293 = new THREE.RingGeometry((inradius293 - guiParameters.circleWidth),inradius293, 32);
		ringMesh293.geometry = ringGeometry293; 
		ringGeometry294.dispose();
		ringGeometry294 = new THREE.RingGeometry((inradius294 - guiParameters.circleWidth),inradius294, 32);
		ringMesh294.geometry = ringGeometry294; 
		ringGeometry295.dispose();
		ringGeometry295 = new THREE.RingGeometry((inradius295 - guiParameters.circleWidth),inradius295, 32);
		ringMesh295.geometry = ringGeometry295; 
		ringGeometry296.dispose();
		ringGeometry296 = new THREE.RingGeometry((inradius296 - guiParameters.circleWidth),inradius296, 32);
		ringMesh296.geometry = ringGeometry296; 
		ringGeometry297.dispose();
		ringGeometry297 = new THREE.RingGeometry((inradius297 - guiParameters.circleWidth),inradius297, 32);
		ringMesh297.geometry = ringGeometry297; 
		ringGeometry298.dispose();
		ringGeometry298 = new THREE.RingGeometry((inradius298 - guiParameters.circleWidth),inradius298, 32);
		ringMesh298.geometry = ringGeometry298; 
		ringGeometry299.dispose();
		ringGeometry299 = new THREE.RingGeometry((inradius299 - guiParameters.circleWidth),inradius299, 32);
		ringMesh299.geometry = ringGeometry299; 
		ringGeometry300.dispose();
		ringGeometry300 = new THREE.RingGeometry((inradius300 - guiParameters.circleWidth),inradius300, 32);
		ringMesh300.geometry = ringGeometry300; 
		ringGeometry301.dispose();
		ringGeometry301 = new THREE.RingGeometry((inradius301 - guiParameters.circleWidth),inradius301, 32);
		ringMesh301.geometry = ringGeometry301; 
		ringGeometry302.dispose();
		ringGeometry302 = new THREE.RingGeometry((inradius302 - guiParameters.circleWidth),inradius302, 32);
		ringMesh302.geometry = ringGeometry302; 
		ringGeometry303.dispose();
		ringGeometry303 = new THREE.RingGeometry((inradius303 - guiParameters.circleWidth),inradius303, 32);
		ringMesh303.geometry = ringGeometry303; 
		ringGeometry304.dispose();
		ringGeometry304 = new THREE.RingGeometry((inradius304 - guiParameters.circleWidth),inradius304, 32);
		ringMesh304.geometry = ringGeometry304; 
		ringGeometry305.dispose();
		ringGeometry305 = new THREE.RingGeometry((inradius305 - guiParameters.circleWidth),inradius305, 32);
		ringMesh305.geometry = ringGeometry305; 
		ringGeometry306.dispose();
		ringGeometry306 = new THREE.RingGeometry((inradius306 - guiParameters.circleWidth),inradius306, 32);
		ringMesh306.geometry = ringGeometry306; 
		ringGeometry307.dispose();
		ringGeometry307 = new THREE.RingGeometry((inradius307 - guiParameters.circleWidth),inradius307, 32);
		ringMesh307.geometry = ringGeometry307; 
		ringGeometry308.dispose();
		ringGeometry308 = new THREE.RingGeometry((inradius308 - guiParameters.circleWidth),inradius308, 32);
		ringMesh308.geometry = ringGeometry308; 
		ringGeometry309.dispose();
		ringGeometry309 = new THREE.RingGeometry((inradius309 - guiParameters.circleWidth),inradius309, 32);
		ringMesh309.geometry = ringGeometry309; 
		ringGeometry310.dispose();
		ringGeometry310 = new THREE.RingGeometry((inradius310 - guiParameters.circleWidth),inradius310, 32);
		ringMesh310.geometry = ringGeometry310; 
		ringGeometry311.dispose();
		ringGeometry311 = new THREE.RingGeometry((inradius311 - guiParameters.circleWidth),inradius311, 32);
		ringMesh311.geometry = ringGeometry311; 
		ringGeometry312.dispose();
		ringGeometry312 = new THREE.RingGeometry((inradius312 - guiParameters.circleWidth),inradius312, 32);
		ringMesh312.geometry = ringGeometry312; 
		ringGeometry313.dispose();
		ringGeometry313 = new THREE.RingGeometry((inradius313 - guiParameters.circleWidth),inradius313, 32);
		ringMesh313.geometry = ringGeometry313; 
		ringGeometry314.dispose();
		ringGeometry314 = new THREE.RingGeometry((inradius314 - guiParameters.circleWidth),inradius314, 32);
		ringMesh314.geometry = ringGeometry314; 
		ringGeometry315.dispose();
		ringGeometry315 = new THREE.RingGeometry((inradius315 - guiParameters.circleWidth),inradius315, 32);
		ringMesh315.geometry = ringGeometry315; 
		ringGeometry316.dispose();
		ringGeometry316 = new THREE.RingGeometry((inradius316 - guiParameters.circleWidth),inradius316, 32);
		ringMesh316.geometry = ringGeometry316; 
		ringGeometry317.dispose();
		ringGeometry317 = new THREE.RingGeometry((inradius317 - guiParameters.circleWidth),inradius317, 32);
		ringMesh317.geometry = ringGeometry317; 
		ringGeometry318.dispose();
		ringGeometry318 = new THREE.RingGeometry((inradius318 - guiParameters.circleWidth),inradius318, 32);
		ringMesh318.geometry = ringGeometry318; 
		ringGeometry319.dispose();
		ringGeometry319 = new THREE.RingGeometry((inradius319 - guiParameters.circleWidth),inradius319, 32);
		ringMesh319.geometry = ringGeometry319; 
		ringGeometry320.dispose();
		ringGeometry320 = new THREE.RingGeometry((inradius320 - guiParameters.circleWidth),inradius320, 32);
		ringMesh320.geometry = ringGeometry320; 
		ringGeometry321.dispose();
		ringGeometry321 = new THREE.RingGeometry((inradius321 - guiParameters.circleWidth),inradius321, 32);
		ringMesh321.geometry = ringGeometry321; 
		ringGeometry322.dispose();
		ringGeometry322 = new THREE.RingGeometry((inradius322 - guiParameters.circleWidth),inradius322, 32);
		ringMesh322.geometry = ringGeometry322; 
		ringGeometry323.dispose();
		ringGeometry323 = new THREE.RingGeometry((inradius323 - guiParameters.circleWidth),inradius323, 32);
		ringMesh323.geometry = ringGeometry323; 
		ringGeometry324.dispose();
		ringGeometry324 = new THREE.RingGeometry((inradius324 - guiParameters.circleWidth),inradius324, 32);
		ringMesh324.geometry = ringGeometry324; 
		ringGeometry325.dispose();
		ringGeometry325 = new THREE.RingGeometry((inradius325 - guiParameters.circleWidth),inradius325, 32);
		ringMesh325.geometry = ringGeometry325; 
		ringGeometry326.dispose();
		ringGeometry326 = new THREE.RingGeometry((inradius326 - guiParameters.circleWidth),inradius326, 32);
		ringMesh326.geometry = ringGeometry326; 
		ringGeometry327.dispose();
		ringGeometry327 = new THREE.RingGeometry((inradius327 - guiParameters.circleWidth),inradius327, 32);
		ringMesh327.geometry = ringGeometry327; 
		ringGeometry328.dispose();
		ringGeometry328 = new THREE.RingGeometry((inradius328 - guiParameters.circleWidth),inradius328, 32);
		ringMesh328.geometry = ringGeometry328; 
		ringGeometry329.dispose();
		ringGeometry329 = new THREE.RingGeometry((inradius329 - guiParameters.circleWidth),inradius329, 32);
		ringMesh329.geometry = ringGeometry329; 
		ringGeometry330.dispose();
		ringGeometry330 = new THREE.RingGeometry((inradius330 - guiParameters.circleWidth),inradius330, 32);
		ringMesh330.geometry = ringGeometry330; 
		ringGeometry331.dispose();
		ringGeometry331 = new THREE.RingGeometry((inradius331 - guiParameters.circleWidth),inradius331, 32);
		ringMesh331.geometry = ringGeometry331; 
		ringGeometry332.dispose();
		ringGeometry332 = new THREE.RingGeometry((inradius332 - guiParameters.circleWidth),inradius332, 32);
		ringMesh332.geometry = ringGeometry332; 
		ringGeometry333.dispose();
		ringGeometry333 = new THREE.RingGeometry((inradius333 - guiParameters.circleWidth),inradius333, 32);
		ringMesh333.geometry = ringGeometry333; 
		ringGeometry334.dispose();
		ringGeometry334 = new THREE.RingGeometry((inradius334 - guiParameters.circleWidth),inradius334, 32);
		ringMesh334.geometry = ringGeometry334; 
		ringGeometry335.dispose();
		ringGeometry335 = new THREE.RingGeometry((inradius335 - guiParameters.circleWidth),inradius335, 32);
		ringMesh335.geometry = ringGeometry335; 
		ringGeometry336.dispose();
		ringGeometry336 = new THREE.RingGeometry((inradius336 - guiParameters.circleWidth),inradius336, 32);
		ringMesh336.geometry = ringGeometry336; 
		ringGeometry337.dispose();
		ringGeometry337 = new THREE.RingGeometry((inradius337 - guiParameters.circleWidth),inradius337, 32);
		ringMesh337.geometry = ringGeometry337; 
		ringGeometry338.dispose();
		ringGeometry338 = new THREE.RingGeometry((inradius338 - guiParameters.circleWidth),inradius338, 32);
		ringMesh338.geometry = ringGeometry338; 
		ringGeometry339.dispose();
		ringGeometry339 = new THREE.RingGeometry((inradius339 - guiParameters.circleWidth),inradius339, 32);
		ringMesh339.geometry = ringGeometry339; 
		ringGeometry340.dispose();
		ringGeometry340 = new THREE.RingGeometry((inradius340 - guiParameters.circleWidth),inradius340, 32);
		ringMesh340.geometry = ringGeometry340; 
		ringGeometry341.dispose();
		ringGeometry341 = new THREE.RingGeometry((inradius341 - guiParameters.circleWidth),inradius341, 32);
		ringMesh341.geometry = ringGeometry341; 
		ringGeometry342.dispose();
		ringGeometry342 = new THREE.RingGeometry((inradius342 - guiParameters.circleWidth),inradius342, 32);
		ringMesh342.geometry = ringGeometry342; 
		ringGeometry343.dispose();
		ringGeometry343 = new THREE.RingGeometry((inradius343 - guiParameters.circleWidth),inradius343, 32);
		ringMesh343.geometry = ringGeometry343; 
		ringGeometry344.dispose();
		ringGeometry344 = new THREE.RingGeometry((inradius344 - guiParameters.circleWidth),inradius344, 32);
		ringMesh344.geometry = ringGeometry344; 
		ringGeometry345.dispose();
		ringGeometry345 = new THREE.RingGeometry((inradius345 - guiParameters.circleWidth),inradius345, 32);
		ringMesh345.geometry = ringGeometry345; 
		ringGeometry346.dispose();
		ringGeometry346 = new THREE.RingGeometry((inradius346 - guiParameters.circleWidth),inradius346, 32);
		ringMesh346.geometry = ringGeometry346; 
		ringGeometry347.dispose();
		ringGeometry347 = new THREE.RingGeometry((inradius347 - guiParameters.circleWidth),inradius347, 32);
		ringMesh347.geometry = ringGeometry347; 
		ringGeometry348.dispose();
		ringGeometry348 = new THREE.RingGeometry((inradius348 - guiParameters.circleWidth),inradius348, 32);
		ringMesh348.geometry = ringGeometry348; 
		ringGeometry349.dispose();
		ringGeometry349 = new THREE.RingGeometry((inradius349 - guiParameters.circleWidth),inradius349, 32);
		ringMesh349.geometry = ringGeometry349; 
		ringGeometry350.dispose();
		ringGeometry350 = new THREE.RingGeometry((inradius350 - guiParameters.circleWidth),inradius350, 32);
		ringMesh350.geometry = ringGeometry350; 
		ringGeometry351.dispose();
		ringGeometry351 = new THREE.RingGeometry((inradius351 - guiParameters.circleWidth),inradius351, 32);
		ringMesh351.geometry = ringGeometry351; 
		ringGeometry352.dispose();
		ringGeometry352 = new THREE.RingGeometry((inradius352 - guiParameters.circleWidth),inradius352, 32);
		ringMesh352.geometry = ringGeometry352; 
		ringGeometry353.dispose();
		ringGeometry353 = new THREE.RingGeometry((inradius353 - guiParameters.circleWidth),inradius353, 32);
		ringMesh353.geometry = ringGeometry353; 
		ringGeometry354.dispose();
		ringGeometry354 = new THREE.RingGeometry((inradius354 - guiParameters.circleWidth),inradius354, 32);
		ringMesh354.geometry = ringGeometry354; 
		ringGeometry355.dispose();
		ringGeometry355 = new THREE.RingGeometry((inradius355 - guiParameters.circleWidth),inradius355, 32);
		ringMesh355.geometry = ringGeometry355; 
		ringGeometry356.dispose();
		ringGeometry356 = new THREE.RingGeometry((inradius356 - guiParameters.circleWidth),inradius356, 32);
		ringMesh356.geometry = ringGeometry356; 
		ringGeometry357.dispose();
		ringGeometry357 = new THREE.RingGeometry((inradius357 - guiParameters.circleWidth),inradius357, 32);
		ringMesh357.geometry = ringGeometry357; 
		ringGeometry358.dispose();
		ringGeometry358 = new THREE.RingGeometry((inradius358 - guiParameters.circleWidth),inradius358, 32);
		ringMesh358.geometry = ringGeometry358; 
		ringGeometry359.dispose();
		ringGeometry359 = new THREE.RingGeometry((inradius359 - guiParameters.circleWidth),inradius359, 32);
		ringMesh359.geometry = ringGeometry359; 
		ringGeometry360.dispose();
		ringGeometry360 = new THREE.RingGeometry((inradius360 - guiParameters.circleWidth),inradius360, 32);
		ringMesh360.geometry = ringGeometry360; 
		ringGeometry361.dispose();
		ringGeometry361 = new THREE.RingGeometry((inradius361 - guiParameters.circleWidth),inradius361, 32);
		ringMesh361.geometry = ringGeometry361; 
		ringGeometry362.dispose();
		ringGeometry362 = new THREE.RingGeometry((inradius362 - guiParameters.circleWidth),inradius362, 32);
		ringMesh362.geometry = ringGeometry362; 
		ringGeometry363.dispose();
		ringGeometry363 = new THREE.RingGeometry((inradius363 - guiParameters.circleWidth),inradius363, 32);
		ringMesh363.geometry = ringGeometry363; 
		ringGeometry364.dispose();
		ringGeometry364 = new THREE.RingGeometry((inradius364 - guiParameters.circleWidth),inradius364, 32);
		ringMesh364.geometry = ringGeometry364; 
		ringGeometry365.dispose();
		ringGeometry365 = new THREE.RingGeometry((inradius365 - guiParameters.circleWidth),inradius365, 32);
		ringMesh365.geometry = ringGeometry365; 
		ringGeometry366.dispose();
		ringGeometry366 = new THREE.RingGeometry((inradius366 - guiParameters.circleWidth),inradius366, 32);
		ringMesh366.geometry = ringGeometry366; 
		ringGeometry367.dispose();
		ringGeometry367 = new THREE.RingGeometry((inradius367 - guiParameters.circleWidth),inradius367, 32);
		ringMesh367.geometry = ringGeometry367; 
		ringGeometry368.dispose();
		ringGeometry368 = new THREE.RingGeometry((inradius368 - guiParameters.circleWidth),inradius368, 32);
		ringMesh368.geometry = ringGeometry368; 
		ringGeometry369.dispose();
		ringGeometry369 = new THREE.RingGeometry((inradius369 - guiParameters.circleWidth),inradius369, 32);
		ringMesh369.geometry = ringGeometry369; 
		ringGeometry370.dispose();
		ringGeometry370 = new THREE.RingGeometry((inradius370 - guiParameters.circleWidth),inradius370, 32);
		ringMesh370.geometry = ringGeometry370; 
		ringGeometry371.dispose();
		ringGeometry371 = new THREE.RingGeometry((inradius371 - guiParameters.circleWidth),inradius371, 32);
		ringMesh371.geometry = ringGeometry371; 
		ringGeometry372.dispose();
		ringGeometry372 = new THREE.RingGeometry((inradius372 - guiParameters.circleWidth),inradius372, 32);
		ringMesh372.geometry = ringGeometry372; 
		ringGeometry373.dispose();
		ringGeometry373 = new THREE.RingGeometry((inradius373 - guiParameters.circleWidth),inradius373, 32);
		ringMesh373.geometry = ringGeometry373; 
		ringGeometry374.dispose();
		ringGeometry374 = new THREE.RingGeometry((inradius374 - guiParameters.circleWidth),inradius374, 32);
		ringMesh374.geometry = ringGeometry374; 
		ringGeometry375.dispose();
		ringGeometry375 = new THREE.RingGeometry((inradius375 - guiParameters.circleWidth),inradius375, 32);
		ringMesh375.geometry = ringGeometry375; 
		ringGeometry376.dispose();
		ringGeometry376 = new THREE.RingGeometry((inradius376 - guiParameters.circleWidth),inradius376, 32);
		ringMesh376.geometry = ringGeometry376; 
		ringGeometry377.dispose();
		ringGeometry377 = new THREE.RingGeometry((inradius377 - guiParameters.circleWidth),inradius377, 32);
		ringMesh377.geometry = ringGeometry377; 
		ringGeometry378.dispose();
		ringGeometry378 = new THREE.RingGeometry((inradius378 - guiParameters.circleWidth),inradius378, 32);
		ringMesh378.geometry = ringGeometry378; 
		ringGeometry379.dispose();
		ringGeometry379 = new THREE.RingGeometry((inradius379 - guiParameters.circleWidth),inradius379, 32);
		ringMesh379.geometry = ringGeometry379; 
		ringGeometry380.dispose();
		ringGeometry380 = new THREE.RingGeometry((inradius380 - guiParameters.circleWidth),inradius380, 32);
		ringMesh380.geometry = ringGeometry380; 
		ringGeometry381.dispose();
		ringGeometry381 = new THREE.RingGeometry((inradius381 - guiParameters.circleWidth),inradius381, 32);
		ringMesh381.geometry = ringGeometry381; 
		ringGeometry382.dispose();
		ringGeometry382 = new THREE.RingGeometry((inradius382 - guiParameters.circleWidth),inradius382, 32);
		ringMesh382.geometry = ringGeometry382; 
		ringGeometry383.dispose();
		ringGeometry383 = new THREE.RingGeometry((inradius383 - guiParameters.circleWidth),inradius383, 32);
		ringMesh383.geometry = ringGeometry383; 
		ringGeometry384.dispose();
		ringGeometry384 = new THREE.RingGeometry((inradius384 - guiParameters.circleWidth),inradius384, 32);
		ringMesh384.geometry = ringGeometry384; 
		ringGeometry385.dispose();
		ringGeometry385 = new THREE.RingGeometry((inradius385 - guiParameters.circleWidth),inradius385, 32);
		ringMesh385.geometry = ringGeometry385; 
		ringGeometry386.dispose();
		ringGeometry386 = new THREE.RingGeometry((inradius386 - guiParameters.circleWidth),inradius386, 32);
		ringMesh386.geometry = ringGeometry386; 
		ringGeometry387.dispose();
		ringGeometry387 = new THREE.RingGeometry((inradius387 - guiParameters.circleWidth),inradius387, 32);
		ringMesh387.geometry = ringGeometry387; 
		ringGeometry388.dispose();
		ringGeometry388 = new THREE.RingGeometry((inradius388 - guiParameters.circleWidth),inradius388, 32);
		ringMesh388.geometry = ringGeometry388; 
		ringGeometry389.dispose();
		ringGeometry389 = new THREE.RingGeometry((inradius389 - guiParameters.circleWidth),inradius389, 32);
		ringMesh389.geometry = ringGeometry389; 
		ringGeometry390.dispose();
		ringGeometry390 = new THREE.RingGeometry((inradius390 - guiParameters.circleWidth),inradius390, 32);
		ringMesh390.geometry = ringGeometry390; 
		ringGeometry391.dispose();
		ringGeometry391 = new THREE.RingGeometry((inradius391 - guiParameters.circleWidth),inradius391, 32);
		ringMesh391.geometry = ringGeometry391; 
		ringGeometry392.dispose();
		ringGeometry392 = new THREE.RingGeometry((inradius392 - guiParameters.circleWidth),inradius392, 32);
		ringMesh392.geometry = ringGeometry392; 
		ringGeometry393.dispose();
		ringGeometry393 = new THREE.RingGeometry((inradius393 - guiParameters.circleWidth),inradius393, 32);
		ringMesh393.geometry = ringGeometry393; 
		ringGeometry394.dispose();
		ringGeometry394 = new THREE.RingGeometry((inradius394 - guiParameters.circleWidth),inradius394, 32);
		ringMesh394.geometry = ringGeometry394; 
		ringGeometry395.dispose();
		ringGeometry395 = new THREE.RingGeometry((inradius395 - guiParameters.circleWidth),inradius395, 32);
		ringMesh395.geometry = ringGeometry395; 
		ringGeometry396.dispose();
		ringGeometry396 = new THREE.RingGeometry((inradius396 - guiParameters.circleWidth),inradius396, 32);
		ringMesh396.geometry = ringGeometry396; 
		ringGeometry397.dispose();
		ringGeometry397 = new THREE.RingGeometry((inradius397 - guiParameters.circleWidth),inradius397, 32);
		ringMesh397.geometry = ringGeometry397; 
		ringGeometry398.dispose();
		ringGeometry398 = new THREE.RingGeometry((inradius398 - guiParameters.circleWidth),inradius398, 32);
		ringMesh398.geometry = ringGeometry398; 
		ringGeometry399.dispose();
		ringGeometry399 = new THREE.RingGeometry((inradius399 - guiParameters.circleWidth),inradius399, 32);
		ringMesh399.geometry = ringGeometry399; 
		ringGeometry400.dispose();
		ringGeometry400 = new THREE.RingGeometry((inradius400 - guiParameters.circleWidth),inradius400, 32);
		ringMesh400.geometry = ringGeometry400; 
		ringGeometry401.dispose();
		ringGeometry401 = new THREE.RingGeometry((inradius401 - guiParameters.circleWidth),inradius401, 32);
		ringMesh401.geometry = ringGeometry401; 
		ringGeometry402.dispose();
		ringGeometry402 = new THREE.RingGeometry((inradius402 - guiParameters.circleWidth),inradius402, 32);
		ringMesh402.geometry = ringGeometry402; 
		ringGeometry403.dispose();
		ringGeometry403 = new THREE.RingGeometry((inradius403 - guiParameters.circleWidth),inradius403, 32);
		ringMesh403.geometry = ringGeometry403; 
		ringGeometry404.dispose();
		ringGeometry404 = new THREE.RingGeometry((inradius404 - guiParameters.circleWidth),inradius404, 32);
		ringMesh404.geometry = ringGeometry404; 
		ringGeometry405.dispose();
		ringGeometry405 = new THREE.RingGeometry((inradius405 - guiParameters.circleWidth),inradius405, 32);
		ringMesh405.geometry = ringGeometry405; 
		ringGeometry406.dispose();
		ringGeometry406 = new THREE.RingGeometry((inradius406 - guiParameters.circleWidth),inradius406, 32);
		ringMesh406.geometry = ringGeometry406; 
		ringGeometry407.dispose();
		ringGeometry407 = new THREE.RingGeometry((inradius407 - guiParameters.circleWidth),inradius407, 32);
		ringMesh407.geometry = ringGeometry407; 
		ringGeometry408.dispose();
		ringGeometry408 = new THREE.RingGeometry((inradius408 - guiParameters.circleWidth),inradius408, 32);
		ringMesh408.geometry = ringGeometry408; 
		ringGeometry409.dispose();
		ringGeometry409 = new THREE.RingGeometry((inradius409 - guiParameters.circleWidth),inradius409, 32);
		ringMesh409.geometry = ringGeometry409; 
		ringGeometry410.dispose();
		ringGeometry410 = new THREE.RingGeometry((inradius410 - guiParameters.circleWidth),inradius410, 32);
		ringMesh410.geometry = ringGeometry410; 
		ringGeometry411.dispose();
		ringGeometry411 = new THREE.RingGeometry((inradius411 - guiParameters.circleWidth),inradius411, 32);
		ringMesh411.geometry = ringGeometry411; 
		ringGeometry412.dispose();
		ringGeometry412 = new THREE.RingGeometry((inradius412 - guiParameters.circleWidth),inradius412, 32);
		ringMesh412.geometry = ringGeometry412; 
		ringGeometry413.dispose();
		ringGeometry413 = new THREE.RingGeometry((inradius413 - guiParameters.circleWidth),inradius413, 32);
		ringMesh413.geometry = ringGeometry413; 
		ringGeometry414.dispose();
		ringGeometry414 = new THREE.RingGeometry((inradius414 - guiParameters.circleWidth),inradius414, 32);
		ringMesh414.geometry = ringGeometry414; 
		ringGeometry415.dispose();
		ringGeometry415 = new THREE.RingGeometry((inradius415 - guiParameters.circleWidth),inradius415, 32);
		ringMesh415.geometry = ringGeometry415; 
		ringGeometry416.dispose();
		ringGeometry416 = new THREE.RingGeometry((inradius416 - guiParameters.circleWidth),inradius416, 32);
		ringMesh416.geometry = ringGeometry416; 
		ringGeometry417.dispose();
		ringGeometry417 = new THREE.RingGeometry((inradius417 - guiParameters.circleWidth),inradius417, 32);
		ringMesh417.geometry = ringGeometry417; 
		ringGeometry418.dispose();
		ringGeometry418 = new THREE.RingGeometry((inradius418 - guiParameters.circleWidth),inradius418, 32);
		ringMesh418.geometry = ringGeometry418; 
		ringGeometry419.dispose();
		ringGeometry419 = new THREE.RingGeometry((inradius419 - guiParameters.circleWidth),inradius419, 32);
		ringMesh419.geometry = ringGeometry419; 
		ringGeometry420.dispose();
		ringGeometry420 = new THREE.RingGeometry((inradius420 - guiParameters.circleWidth),inradius420, 32);
		ringMesh420.geometry = ringGeometry420; 
		ringGeometry421.dispose();
		ringGeometry421 = new THREE.RingGeometry((inradius421 - guiParameters.circleWidth),inradius421, 32);
		ringMesh421.geometry = ringGeometry421; 
		ringGeometry422.dispose();
		ringGeometry422 = new THREE.RingGeometry((inradius422 - guiParameters.circleWidth),inradius422, 32);
		ringMesh422.geometry = ringGeometry422; 
		ringGeometry423.dispose();
		ringGeometry423 = new THREE.RingGeometry((inradius423 - guiParameters.circleWidth),inradius423, 32);
		ringMesh423.geometry = ringGeometry423; 
		ringGeometry424.dispose();
		ringGeometry424 = new THREE.RingGeometry((inradius424 - guiParameters.circleWidth),inradius424, 32);
		ringMesh424.geometry = ringGeometry424; 
		ringGeometry425.dispose();
		ringGeometry425 = new THREE.RingGeometry((inradius425 - guiParameters.circleWidth),inradius425, 32);
		ringMesh425.geometry = ringGeometry425; 
		ringGeometry426.dispose();
		ringGeometry426 = new THREE.RingGeometry((inradius426 - guiParameters.circleWidth),inradius426, 32);
		ringMesh426.geometry = ringGeometry426; 
		ringGeometry427.dispose();
		ringGeometry427 = new THREE.RingGeometry((inradius427 - guiParameters.circleWidth),inradius427, 32);
		ringMesh427.geometry = ringGeometry427; 
		ringGeometry428.dispose();
		ringGeometry428 = new THREE.RingGeometry((inradius428 - guiParameters.circleWidth),inradius428, 32);
		ringMesh428.geometry = ringGeometry428; 
	}

	updateCircleWidth();

	// generate the normals trough the incenter orthogonal to the face 
	// getNormalsVectors generates the coordinates for the current values of the parameterized surface 
	function getNormalsVectors(){
		var vector1;
		var vector2;

		var normals = [];
		vector1 = [];
		vector2 = [];
		vector1[0] = (-1.)-(-1.);
		vector1[1] = (-1.)-(-1.);
		vector1[2] = (0.)-(1.);

		vector2[0] = (-1.)-(-1.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.)-(1.);

		var incenter = calulateIncenter([-1.,-1.,1.],[ -1.,-1.,0.],[-1.,0.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1.)-(-1.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.)-(1.);

		vector2[0] = (-1.)-(-1.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (1.)-(1.);

		var incenter = calulateIncenter([-1.,-1.,1.],[ -1.,0.,0.],[-1.,0.,1.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1.)-(-1.);
		vector1[1] = (-1.)-(-1.);
		vector1[2] = (0.)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (-1.)-(-1.);
		vector2[2] = (0.)-(1.);

		var incenter = calulateIncenter([-1.,-1.,1.],[ -1.,-1.,0.],[0.,-1.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (-1.)-(-1.);
		vector1[2] = (0.)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (-1.)-(-1.);
		vector2[2] = (1.)-(1.);

		var incenter = calulateIncenter([-1.,-1.,1.],[ 0.,-1.,0.],[0.,-1.,1.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1.)-(-1.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (-1.)-(-1.);
		vector2[2] = (0.)-(0.);

		var incenter = calulateIncenter([-1.,-1.,0.],[ -1.,0.,0.],[0.,-1.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (-1.)-(0.);
		vector2[2] = (0.)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.],[0.,-1.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1.)-(-1.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (1.)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (-1.)-(-1.);
		vector2[2] = (1.)-(1.);

		var incenter = calulateIncenter([-1.,-1.,1.],[ -1.,0.,1.],[0.,-1.,1.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (1.)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (-1.)-(0.);
		vector2[2] = (1.)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,1.],[0.,-1.,1.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.009803921568627416)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.],[0.,0.,0.0098039215686274161]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (1.)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9901960784313726)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,1.],[0.,0.,0.99019607843137258]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.01960784313725494)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.009803921568627416)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.019607843137254943],[0.,0.,0.0098039215686274161]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9901960784313726)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9803921568627451)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.99019607843137258],[0.,0.,0.98039215686274506]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.02941176470588236)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.01960784313725494)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.029411764705882359],[0.,0.,0.019607843137254943]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9803921568627451)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9705882352941176)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.98039215686274506],[0.,0.,0.97058823529411764]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.03921568627450978)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.02941176470588236)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.039215686274509776],[0.,0.,0.029411764705882359]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9705882352941176)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9607843137254902)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.97058823529411764],[0.,0.,0.96078431372549022]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.0490196078431373)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.03921568627450978)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.049019607843137303],[0.,0.,0.039215686274509776]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9607843137254902)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9509803921568627)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.96078431372549022],[0.,0.,0.9509803921568627]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.05882352941176472)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.0490196078431373)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.058823529411764719],[0.,0.,0.049019607843137303]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9509803921568627)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9411764705882353)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.9509803921568627],[0.,0.,0.94117647058823528]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.06862745098039214)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.05882352941176472)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.068627450980392135],[0.,0.,0.058823529411764719]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9411764705882353)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9313725490196079)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.94117647058823528],[0.,0.,0.93137254901960786]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.07843137254901966)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.06862745098039214)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.078431372549019662],[0.,0.,0.068627450980392135]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9313725490196079)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9215686274509804)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.93137254901960786],[0.,0.,0.92156862745098045]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.08823529411764708)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.07843137254901966)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.088235294117647078],[0.,0.,0.078431372549019662]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9215686274509804)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9117647058823529)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.92156862745098045],[0.,0.,0.91176470588235292]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.09803921568627449)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.08823529411764708)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.098039215686274495],[0.,0.,0.088235294117647078]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9117647058823529)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9019607843137255)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.91176470588235292],[0.,0.,0.90196078431372551]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.107843137254902)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.09803921568627449)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.10784313725490202],[0.,0.,0.098039215686274495]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9019607843137255)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.892156862745098)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.90196078431372551],[0.,0.,0.89215686274509798]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1176470588235294)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.107843137254902)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.11764705882352944],[0.,0.,0.10784313725490202]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.892156862745098)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8823529411764706)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.89215686274509798],[0.,0.,0.88235294117647056]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1274509803921569)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1176470588235294)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.12745098039215685],[0.,0.,0.11764705882352944]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8823529411764706)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8725490196078431)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.88235294117647056],[0.,0.,0.87254901960784315]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1372549019607843)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1274509803921569)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.13725490196078427],[0.,0.,0.12745098039215685]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8725490196078431)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8627450980392157)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.87254901960784315],[0.,0.,0.86274509803921573]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1470588235294118)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1372549019607843)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.1470588235294118],[0.,0.,0.13725490196078427]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8627450980392157)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8529411764705882)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.86274509803921573],[0.,0.,0.8529411764705882]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1568627450980392)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1470588235294118)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.15686274509803921],[0.,0.,0.1470588235294118]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8529411764705882)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8431372549019608)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.8529411764705882],[0.,0.,0.84313725490196079]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1666666666666666)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1568627450980392)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.16666666666666663],[0.,0.,0.15686274509803921]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8431372549019608)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8333333333333334)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.84313725490196079],[0.,0.,0.83333333333333337]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1764705882352942)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1666666666666666)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.17647058823529416],[0.,0.,0.16666666666666663]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8333333333333334)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8235294117647058)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.83333333333333337],[0.,0.,0.82352941176470584]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1862745098039216)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1764705882352942)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.18627450980392157],[0.,0.,0.17647058823529416]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8235294117647058)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8137254901960784)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.82352941176470584],[0.,0.,0.81372549019607843]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.196078431372549)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1862745098039216)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.19607843137254899],[0.,0.,0.18627450980392157]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8137254901960784)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.803921568627451)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.81372549019607843],[0.,0.,0.80392156862745101]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2058823529411765)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.196078431372549)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.20588235294117652],[0.,0.,0.19607843137254899]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.803921568627451)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7941176470588236)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.80392156862745101],[0.,0.,0.79411764705882359]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2156862745098039)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2058823529411765)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.21568627450980393],[0.,0.,0.20588235294117652]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7941176470588236)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7843137254901961)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.79411764705882359],[0.,0.,0.78431372549019607]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2254901960784313)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2156862745098039)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.22549019607843135],[0.,0.,0.21568627450980393]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7843137254901961)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7745098039215687)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.78431372549019607],[0.,0.,0.77450980392156865]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2352941176470589)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2254901960784313)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.23529411764705888],[0.,0.,0.22549019607843135]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7745098039215687)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7647058823529411)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.77450980392156865],[0.,0.,0.76470588235294112]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2450980392156863)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2352941176470589)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.24509803921568629],[0.,0.,0.23529411764705888]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7647058823529411)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7549019607843137)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.76470588235294112],[0.,0.,0.75490196078431371]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2549019607843137)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2450980392156863)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.25490196078431371],[0.,0.,0.24509803921568629]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7549019607843137)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7450980392156863)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.75490196078431371],[0.,0.,0.74509803921568629]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2647058823529412)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2549019607843137)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.26470588235294124],[0.,0.,0.25490196078431371]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7450980392156863)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7352941176470589)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.74509803921568629],[0.,0.,0.73529411764705888]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2745098039215687)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2647058823529412)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.27450980392156865],[0.,0.,0.26470588235294124]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7352941176470589)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7254901960784313)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.73529411764705888],[0.,0.,0.72549019607843135]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2843137254901961)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2745098039215687)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.28431372549019607],[0.,0.,0.27450980392156865]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7254901960784313)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7156862745098039)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.72549019607843135],[0.,0.,0.71568627450980393]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2941176470588236)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2843137254901961)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.29411764705882359],[0.,0.,0.28431372549019607]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7156862745098039)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7058823529411764)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.71568627450980393],[0.,0.,0.70588235294117641]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.303921568627451)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2941176470588236)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.30392156862745101],[0.,0.,0.29411764705882359]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7058823529411764)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.696078431372549)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.70588235294117641],[0.,0.,0.69607843137254899]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3137254901960784)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.303921568627451)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.31372549019607843],[0.,0.,0.30392156862745101]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.696078431372549)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6862745098039216)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.69607843137254899],[0.,0.,0.68627450980392157]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3235294117647058)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3137254901960784)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.32352941176470584],[0.,0.,0.31372549019607843]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6862745098039216)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6764705882352942)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.68627450980392157],[0.,0.,0.67647058823529416]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3333333333333334)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3235294117647058)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.33333333333333337],[0.,0.,0.32352941176470584]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6764705882352942)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6666666666666667)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.67647058823529416],[0.,0.,0.66666666666666674]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3431372549019608)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3333333333333334)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.34313725490196079],[0.,0.,0.33333333333333337]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6666666666666667)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6568627450980392)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.66666666666666674],[0.,0.,0.65686274509803921]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3529411764705882)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3431372549019608)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.3529411764705882],[0.,0.,0.34313725490196079]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6568627450980392)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6470588235294118)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.65686274509803921],[0.,0.,0.6470588235294118]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3627450980392157)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3529411764705882)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.36274509803921573],[0.,0.,0.3529411764705882]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6470588235294118)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6372549019607843)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.6470588235294118],[0.,0.,0.63725490196078427]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3725490196078431)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3627450980392157)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.37254901960784315],[0.,0.,0.36274509803921573]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6372549019607843)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6274509803921569)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.63725490196078427],[0.,0.,0.62745098039215685]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3823529411764706)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3725490196078431)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.38235294117647056],[0.,0.,0.37254901960784315]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6274509803921569)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6176470588235294)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.62745098039215685],[0.,0.,0.61764705882352944]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3921568627450981)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3823529411764706)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.39215686274509809],[0.,0.,0.38235294117647056]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6176470588235294)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.607843137254902)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.61764705882352944],[0.,0.,0.60784313725490202]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4019607843137255)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3921568627450981)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.40196078431372551],[0.,0.,0.39215686274509809]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.607843137254902)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5980392156862745)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.60784313725490202],[0.,0.,0.59803921568627449]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4117647058823529)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4019607843137255)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.41176470588235292],[0.,0.,0.40196078431372551]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5980392156862745)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5882352941176471)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.59803921568627449],[0.,0.,0.58823529411764708]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4215686274509804)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4117647058823529)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.42156862745098045],[0.,0.,0.41176470588235292]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5882352941176471)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5784313725490196)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.58823529411764708],[0.,0.,0.57843137254901955]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4313725490196079)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4215686274509804)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.43137254901960786],[0.,0.,0.42156862745098045]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5784313725490196)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5686274509803921)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.57843137254901955],[0.,0.,0.56862745098039214]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4411764705882353)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4313725490196079)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.44117647058823528],[0.,0.,0.43137254901960786]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5686274509803921)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5588235294117647)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.56862745098039214],[0.,0.,0.55882352941176472]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4509803921568627)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4411764705882353)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.4509803921568627],[0.,0.,0.44117647058823528]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5588235294117647)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5490196078431373)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.55882352941176472],[0.,0.,0.5490196078431373]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4607843137254902)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4509803921568627)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.46078431372549022],[0.,0.,0.4509803921568627]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5490196078431373)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5392156862745099)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.5490196078431373],[0.,0.,0.53921568627450989]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4705882352941176)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4607843137254902)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.47058823529411764],[0.,0.,0.46078431372549022]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5392156862745099)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5294117647058824)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.53921568627450989],[0.,0.,0.52941176470588236]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4803921568627451)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4705882352941176)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.48039215686274506],[0.,0.,0.47058823529411764]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5294117647058824)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5196078431372548)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.52941176470588236],[0.,0.,0.51960784313725483]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4901960784313726)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4803921568627451)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.49019607843137258],[0.,0.,0.48039215686274506]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5196078431372548)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5098039215686274)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.51960784313725483],[0.,0.,0.50980392156862742]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4901960784313726)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ 0.,0.,0.5],[0.,0.,0.49019607843137258]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5098039215686274)-(1.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5)-(1.);

		var incenter = calulateIncenter([-1.,0.,1.],[ 0.,0.,0.50980392156862742],[0.,0.,0.5]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-1.)-(-1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (1.)-(0.);

		vector2[0] = (0.)-(-1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5)-(0.);

		var incenter = calulateIncenter([-1.,0.,0.],[ -1.,0.,1.],[0.,0.,0.5]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (-1.)-(0.);
		vector1[2] = (0.)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.009803921568627416)-(0.);

		var incenter = calulateIncenter([0.,0.,0.],[ 0.,-1.,0.],[0.,0.,0.0098039215686274161]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (-1.)-(0.);
		vector1[2] = (1.)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9901960784313726)-(1.);

		var incenter = calulateIncenter([0.,0.,1.],[ 0.,-1.,1.],[0.,0.,0.99019607843137258]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.01960784313725494)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.009803921568627416)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.019607843137254943],[0.,0.,0.0098039215686274161]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.9901960784313726)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.9803921568627451)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.99019607843137258],[0.,0.,0.98039215686274506]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.02941176470588236)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.01960784313725494)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.029411764705882359],[0.,0.,0.019607843137254943]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.9803921568627451)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.9705882352941176)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.98039215686274506],[0.,0.,0.97058823529411764]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.03921568627450978)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.02941176470588236)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.039215686274509776],[0.,0.,0.029411764705882359]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.9705882352941176)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.9607843137254902)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.97058823529411764],[0.,0.,0.96078431372549022]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.0490196078431373)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.03921568627450978)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.049019607843137303],[0.,0.,0.039215686274509776]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.9607843137254902)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.9509803921568627)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.96078431372549022],[0.,0.,0.9509803921568627]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.05882352941176472)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.0490196078431373)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.058823529411764719],[0.,0.,0.049019607843137303]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.9509803921568627)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.9411764705882353)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.9509803921568627],[0.,0.,0.94117647058823528]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.06862745098039214)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.05882352941176472)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.068627450980392135],[0.,0.,0.058823529411764719]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.9411764705882353)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.9313725490196079)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.94117647058823528],[0.,0.,0.93137254901960786]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.07843137254901966)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.06862745098039214)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.078431372549019662],[0.,0.,0.068627450980392135]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.9313725490196079)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.9215686274509804)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.93137254901960786],[0.,0.,0.92156862745098045]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.08823529411764708)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.07843137254901966)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.088235294117647078],[0.,0.,0.078431372549019662]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.9215686274509804)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.9117647058823529)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.92156862745098045],[0.,0.,0.91176470588235292]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.09803921568627449)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.08823529411764708)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.098039215686274495],[0.,0.,0.088235294117647078]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.9117647058823529)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.9019607843137255)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.91176470588235292],[0.,0.,0.90196078431372551]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.107843137254902)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.09803921568627449)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.10784313725490202],[0.,0.,0.098039215686274495]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.9019607843137255)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.892156862745098)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.90196078431372551],[0.,0.,0.89215686274509798]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.1176470588235294)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.107843137254902)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.11764705882352944],[0.,0.,0.10784313725490202]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.892156862745098)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.8823529411764706)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.89215686274509798],[0.,0.,0.88235294117647056]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.1274509803921569)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.1176470588235294)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.12745098039215685],[0.,0.,0.11764705882352944]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.8823529411764706)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.8725490196078431)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.88235294117647056],[0.,0.,0.87254901960784315]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.1372549019607843)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.1274509803921569)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.13725490196078427],[0.,0.,0.12745098039215685]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.8725490196078431)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.8627450980392157)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.87254901960784315],[0.,0.,0.86274509803921573]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.1470588235294118)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.1372549019607843)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.1470588235294118],[0.,0.,0.13725490196078427]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.8627450980392157)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.8529411764705882)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.86274509803921573],[0.,0.,0.8529411764705882]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.1568627450980392)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.1470588235294118)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.15686274509803921],[0.,0.,0.1470588235294118]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.8529411764705882)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.8431372549019608)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.8529411764705882],[0.,0.,0.84313725490196079]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.1666666666666666)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.1568627450980392)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.16666666666666663],[0.,0.,0.15686274509803921]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.8431372549019608)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.8333333333333334)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.84313725490196079],[0.,0.,0.83333333333333337]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.1764705882352942)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.1666666666666666)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.17647058823529416],[0.,0.,0.16666666666666663]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.8333333333333334)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.8235294117647058)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.83333333333333337],[0.,0.,0.82352941176470584]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.1862745098039216)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.1764705882352942)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.18627450980392157],[0.,0.,0.17647058823529416]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.8235294117647058)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.8137254901960784)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.82352941176470584],[0.,0.,0.81372549019607843]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.196078431372549)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.1862745098039216)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.19607843137254899],[0.,0.,0.18627450980392157]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.8137254901960784)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.803921568627451)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.81372549019607843],[0.,0.,0.80392156862745101]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.2058823529411765)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.196078431372549)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.20588235294117652],[0.,0.,0.19607843137254899]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.803921568627451)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.7941176470588236)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.80392156862745101],[0.,0.,0.79411764705882359]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.2156862745098039)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.2058823529411765)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.21568627450980393],[0.,0.,0.20588235294117652]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.7941176470588236)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.7843137254901961)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.79411764705882359],[0.,0.,0.78431372549019607]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.2254901960784313)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.2156862745098039)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.22549019607843135],[0.,0.,0.21568627450980393]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.7843137254901961)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.7745098039215687)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.78431372549019607],[0.,0.,0.77450980392156865]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.2352941176470589)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.2254901960784313)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.23529411764705888],[0.,0.,0.22549019607843135]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.7745098039215687)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.7647058823529411)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.77450980392156865],[0.,0.,0.76470588235294112]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.2450980392156863)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.2352941176470589)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.24509803921568629],[0.,0.,0.23529411764705888]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.7647058823529411)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.7549019607843137)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.76470588235294112],[0.,0.,0.75490196078431371]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.2549019607843137)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.2450980392156863)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.25490196078431371],[0.,0.,0.24509803921568629]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.7549019607843137)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.7450980392156863)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.75490196078431371],[0.,0.,0.74509803921568629]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.2647058823529412)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.2549019607843137)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.26470588235294124],[0.,0.,0.25490196078431371]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.7450980392156863)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.7352941176470589)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.74509803921568629],[0.,0.,0.73529411764705888]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.2745098039215687)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.2647058823529412)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.27450980392156865],[0.,0.,0.26470588235294124]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.7352941176470589)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.7254901960784313)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.73529411764705888],[0.,0.,0.72549019607843135]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.2843137254901961)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.2745098039215687)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.28431372549019607],[0.,0.,0.27450980392156865]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.7254901960784313)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.7156862745098039)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.72549019607843135],[0.,0.,0.71568627450980393]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.2941176470588236)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.2843137254901961)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.29411764705882359],[0.,0.,0.28431372549019607]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.7156862745098039)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.7058823529411764)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.71568627450980393],[0.,0.,0.70588235294117641]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.303921568627451)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.2941176470588236)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.30392156862745101],[0.,0.,0.29411764705882359]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.7058823529411764)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.696078431372549)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.70588235294117641],[0.,0.,0.69607843137254899]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.3137254901960784)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.303921568627451)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.31372549019607843],[0.,0.,0.30392156862745101]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.696078431372549)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.6862745098039216)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.69607843137254899],[0.,0.,0.68627450980392157]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.3235294117647058)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.3137254901960784)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.32352941176470584],[0.,0.,0.31372549019607843]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.6862745098039216)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.6764705882352942)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.68627450980392157],[0.,0.,0.67647058823529416]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.3333333333333334)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.3235294117647058)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.33333333333333337],[0.,0.,0.32352941176470584]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.6764705882352942)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.6666666666666667)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.67647058823529416],[0.,0.,0.66666666666666674]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.3431372549019608)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.3333333333333334)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.34313725490196079],[0.,0.,0.33333333333333337]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.6666666666666667)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.6568627450980392)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.66666666666666674],[0.,0.,0.65686274509803921]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.3529411764705882)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.3431372549019608)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.3529411764705882],[0.,0.,0.34313725490196079]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.6568627450980392)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.6470588235294118)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.65686274509803921],[0.,0.,0.6470588235294118]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.3627450980392157)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.3529411764705882)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.36274509803921573],[0.,0.,0.3529411764705882]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.6470588235294118)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.6372549019607843)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.6470588235294118],[0.,0.,0.63725490196078427]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.3725490196078431)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.3627450980392157)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.37254901960784315],[0.,0.,0.36274509803921573]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.6372549019607843)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.6274509803921569)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.63725490196078427],[0.,0.,0.62745098039215685]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.3823529411764706)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.3725490196078431)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.38235294117647056],[0.,0.,0.37254901960784315]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.6274509803921569)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.6176470588235294)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.62745098039215685],[0.,0.,0.61764705882352944]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.3921568627450981)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.3823529411764706)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.39215686274509809],[0.,0.,0.38235294117647056]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.6176470588235294)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.607843137254902)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.61764705882352944],[0.,0.,0.60784313725490202]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.4019607843137255)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.3921568627450981)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.40196078431372551],[0.,0.,0.39215686274509809]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.607843137254902)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.5980392156862745)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.60784313725490202],[0.,0.,0.59803921568627449]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.4117647058823529)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.4019607843137255)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.41176470588235292],[0.,0.,0.40196078431372551]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.5980392156862745)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.5882352941176471)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.59803921568627449],[0.,0.,0.58823529411764708]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.4215686274509804)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.4117647058823529)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.42156862745098045],[0.,0.,0.41176470588235292]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.5882352941176471)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.5784313725490196)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.58823529411764708],[0.,0.,0.57843137254901955]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.4313725490196079)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.4215686274509804)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.43137254901960786],[0.,0.,0.42156862745098045]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.5784313725490196)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.5686274509803921)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.57843137254901955],[0.,0.,0.56862745098039214]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.4411764705882353)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.4313725490196079)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.44117647058823528],[0.,0.,0.43137254901960786]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.5686274509803921)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.5588235294117647)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.56862745098039214],[0.,0.,0.55882352941176472]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.4509803921568627)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.4411764705882353)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.4509803921568627],[0.,0.,0.44117647058823528]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.5588235294117647)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.5490196078431373)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.55882352941176472],[0.,0.,0.5490196078431373]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.4607843137254902)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.4509803921568627)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.46078431372549022],[0.,0.,0.4509803921568627]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.5490196078431373)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.5392156862745099)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.5490196078431373],[0.,0.,0.53921568627450989]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.4705882352941176)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.4607843137254902)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.47058823529411764],[0.,0.,0.46078431372549022]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.5392156862745099)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.5294117647058824)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.53921568627450989],[0.,0.,0.52941176470588236]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.4803921568627451)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.4705882352941176)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.48039215686274506],[0.,0.,0.47058823529411764]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.5294117647058824)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.5196078431372548)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.52941176470588236],[0.,0.,0.51960784313725483]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.4901960784313726)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.4803921568627451)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.49019607843137258],[0.,0.,0.48039215686274506]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.5196078431372548)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.5098039215686274)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.51960784313725483],[0.,0.,0.50980392156862742]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.5)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.4901960784313726)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,0.,0.5],[0.,0.,0.49019607843137258]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(-1.);
		vector1[2] = (0.5098039215686274)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.5)-(1.);

		var incenter = calulateIncenter([0.,-1.,1.],[ 0.,0.,0.50980392156862742],[0.,0.,0.5]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (-1.)-(-1.);
		vector1[2] = (1.)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(-1.);
		vector2[2] = (0.5)-(0.);

		var incenter = calulateIncenter([0.,-1.,0.],[ 0.,-1.,1.],[0.,0.,0.5]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1.)-(1.);
		vector1[1] = (1.)-(1.);
		vector1[2] = (0.)-(1.);

		vector2[0] = (1.)-(1.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.)-(1.);

		var incenter = calulateIncenter([1.,1.,1.],[ 1.,1.,0.],[1.,0.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1.)-(1.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.)-(1.);

		vector2[0] = (1.)-(1.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (1.)-(1.);

		var incenter = calulateIncenter([1.,1.,1.],[ 1.,0.,0.],[1.,0.,1.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1.)-(1.);
		vector1[1] = (1.)-(1.);
		vector1[2] = (0.)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (1.)-(1.);
		vector2[2] = (0.)-(1.);

		var incenter = calulateIncenter([1.,1.,1.],[ 1.,1.,0.],[0.,1.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (1.)-(1.);
		vector1[2] = (0.)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (1.)-(1.);
		vector2[2] = (1.)-(1.);

		var incenter = calulateIncenter([1.,1.,1.],[ 0.,1.,0.],[0.,1.,1.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1.)-(1.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (1.)-(1.);
		vector2[2] = (0.)-(0.);

		var incenter = calulateIncenter([1.,1.,0.],[ 1.,0.,0.],[0.,1.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (1.)-(0.);
		vector2[2] = (0.)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.],[0.,1.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1.)-(1.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (1.)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (1.)-(1.);
		vector2[2] = (1.)-(1.);

		var incenter = calulateIncenter([1.,1.,1.],[ 1.,0.,1.],[0.,1.,1.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (1.)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (1.)-(0.);
		vector2[2] = (1.)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,1.],[0.,1.,1.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.009803921568627416)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.],[0.,0.,0.0098039215686274161]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (1.)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9901960784313726)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,1.],[0.,0.,0.99019607843137258]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.01960784313725494)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.009803921568627416)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.019607843137254943],[0.,0.,0.0098039215686274161]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9901960784313726)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9803921568627451)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.99019607843137258],[0.,0.,0.98039215686274506]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.02941176470588236)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.01960784313725494)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.029411764705882359],[0.,0.,0.019607843137254943]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9803921568627451)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9705882352941176)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.98039215686274506],[0.,0.,0.97058823529411764]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.03921568627450978)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.02941176470588236)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.039215686274509776],[0.,0.,0.029411764705882359]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9705882352941176)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9607843137254902)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.97058823529411764],[0.,0.,0.96078431372549022]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.0490196078431373)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.03921568627450978)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.049019607843137303],[0.,0.,0.039215686274509776]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9607843137254902)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9509803921568627)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.96078431372549022],[0.,0.,0.9509803921568627]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.05882352941176472)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.0490196078431373)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.058823529411764719],[0.,0.,0.049019607843137303]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9509803921568627)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9411764705882353)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.9509803921568627],[0.,0.,0.94117647058823528]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.06862745098039214)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.05882352941176472)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.068627450980392135],[0.,0.,0.058823529411764719]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9411764705882353)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9313725490196079)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.94117647058823528],[0.,0.,0.93137254901960786]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.07843137254901966)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.06862745098039214)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.078431372549019662],[0.,0.,0.068627450980392135]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9313725490196079)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9215686274509804)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.93137254901960786],[0.,0.,0.92156862745098045]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.08823529411764708)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.07843137254901966)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.088235294117647078],[0.,0.,0.078431372549019662]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9215686274509804)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9117647058823529)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.92156862745098045],[0.,0.,0.91176470588235292]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.09803921568627449)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.08823529411764708)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.098039215686274495],[0.,0.,0.088235294117647078]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9117647058823529)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9019607843137255)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.91176470588235292],[0.,0.,0.90196078431372551]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.107843137254902)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.09803921568627449)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.10784313725490202],[0.,0.,0.098039215686274495]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.9019607843137255)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.892156862745098)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.90196078431372551],[0.,0.,0.89215686274509798]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1176470588235294)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.107843137254902)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.11764705882352944],[0.,0.,0.10784313725490202]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.892156862745098)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8823529411764706)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.89215686274509798],[0.,0.,0.88235294117647056]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1274509803921569)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1176470588235294)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.12745098039215685],[0.,0.,0.11764705882352944]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8823529411764706)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8725490196078431)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.88235294117647056],[0.,0.,0.87254901960784315]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1372549019607843)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1274509803921569)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.13725490196078427],[0.,0.,0.12745098039215685]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8725490196078431)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8627450980392157)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.87254901960784315],[0.,0.,0.86274509803921573]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1470588235294118)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1372549019607843)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.1470588235294118],[0.,0.,0.13725490196078427]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8627450980392157)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8529411764705882)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.86274509803921573],[0.,0.,0.8529411764705882]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1568627450980392)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1470588235294118)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.15686274509803921],[0.,0.,0.1470588235294118]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8529411764705882)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8431372549019608)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.8529411764705882],[0.,0.,0.84313725490196079]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1666666666666666)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1568627450980392)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.16666666666666663],[0.,0.,0.15686274509803921]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8431372549019608)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8333333333333334)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.84313725490196079],[0.,0.,0.83333333333333337]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1764705882352942)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1666666666666666)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.17647058823529416],[0.,0.,0.16666666666666663]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8333333333333334)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8235294117647058)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.83333333333333337],[0.,0.,0.82352941176470584]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.1862745098039216)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1764705882352942)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.18627450980392157],[0.,0.,0.17647058823529416]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8235294117647058)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.8137254901960784)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.82352941176470584],[0.,0.,0.81372549019607843]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.196078431372549)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.1862745098039216)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.19607843137254899],[0.,0.,0.18627450980392157]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.8137254901960784)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.803921568627451)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.81372549019607843],[0.,0.,0.80392156862745101]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2058823529411765)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.196078431372549)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.20588235294117652],[0.,0.,0.19607843137254899]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.803921568627451)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7941176470588236)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.80392156862745101],[0.,0.,0.79411764705882359]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2156862745098039)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2058823529411765)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.21568627450980393],[0.,0.,0.20588235294117652]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7941176470588236)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7843137254901961)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.79411764705882359],[0.,0.,0.78431372549019607]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2254901960784313)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2156862745098039)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.22549019607843135],[0.,0.,0.21568627450980393]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7843137254901961)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7745098039215687)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.78431372549019607],[0.,0.,0.77450980392156865]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2352941176470589)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2254901960784313)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.23529411764705888],[0.,0.,0.22549019607843135]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7745098039215687)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7647058823529411)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.77450980392156865],[0.,0.,0.76470588235294112]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2450980392156863)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2352941176470589)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.24509803921568629],[0.,0.,0.23529411764705888]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7647058823529411)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7549019607843137)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.76470588235294112],[0.,0.,0.75490196078431371]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2549019607843137)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2450980392156863)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.25490196078431371],[0.,0.,0.24509803921568629]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7549019607843137)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7450980392156863)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.75490196078431371],[0.,0.,0.74509803921568629]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2647058823529412)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2549019607843137)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.26470588235294124],[0.,0.,0.25490196078431371]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7450980392156863)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7352941176470589)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.74509803921568629],[0.,0.,0.73529411764705888]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2745098039215687)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2647058823529412)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.27450980392156865],[0.,0.,0.26470588235294124]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7352941176470589)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7254901960784313)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.73529411764705888],[0.,0.,0.72549019607843135]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2843137254901961)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2745098039215687)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.28431372549019607],[0.,0.,0.27450980392156865]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7254901960784313)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7156862745098039)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.72549019607843135],[0.,0.,0.71568627450980393]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.2941176470588236)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2843137254901961)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.29411764705882359],[0.,0.,0.28431372549019607]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7156862745098039)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.7058823529411764)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.71568627450980393],[0.,0.,0.70588235294117641]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.303921568627451)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.2941176470588236)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.30392156862745101],[0.,0.,0.29411764705882359]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.7058823529411764)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.696078431372549)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.70588235294117641],[0.,0.,0.69607843137254899]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3137254901960784)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.303921568627451)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.31372549019607843],[0.,0.,0.30392156862745101]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.696078431372549)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6862745098039216)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.69607843137254899],[0.,0.,0.68627450980392157]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3235294117647058)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3137254901960784)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.32352941176470584],[0.,0.,0.31372549019607843]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6862745098039216)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6764705882352942)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.68627450980392157],[0.,0.,0.67647058823529416]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3333333333333334)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3235294117647058)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.33333333333333337],[0.,0.,0.32352941176470584]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6764705882352942)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6666666666666667)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.67647058823529416],[0.,0.,0.66666666666666674]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3431372549019608)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3333333333333334)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.34313725490196079],[0.,0.,0.33333333333333337]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6666666666666667)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6568627450980392)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.66666666666666674],[0.,0.,0.65686274509803921]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3529411764705882)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3431372549019608)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.3529411764705882],[0.,0.,0.34313725490196079]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6568627450980392)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6470588235294118)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.65686274509803921],[0.,0.,0.6470588235294118]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3627450980392157)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3529411764705882)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.36274509803921573],[0.,0.,0.3529411764705882]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6470588235294118)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6372549019607843)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.6470588235294118],[0.,0.,0.63725490196078427]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3725490196078431)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3627450980392157)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.37254901960784315],[0.,0.,0.36274509803921573]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6372549019607843)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6274509803921569)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.63725490196078427],[0.,0.,0.62745098039215685]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3823529411764706)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3725490196078431)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.38235294117647056],[0.,0.,0.37254901960784315]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6274509803921569)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.6176470588235294)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.62745098039215685],[0.,0.,0.61764705882352944]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.3921568627450981)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3823529411764706)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.39215686274509809],[0.,0.,0.38235294117647056]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.6176470588235294)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.607843137254902)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.61764705882352944],[0.,0.,0.60784313725490202]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4019607843137255)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.3921568627450981)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.40196078431372551],[0.,0.,0.39215686274509809]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.607843137254902)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5980392156862745)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.60784313725490202],[0.,0.,0.59803921568627449]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4117647058823529)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4019607843137255)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.41176470588235292],[0.,0.,0.40196078431372551]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5980392156862745)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5882352941176471)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.59803921568627449],[0.,0.,0.58823529411764708]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4215686274509804)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4117647058823529)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.42156862745098045],[0.,0.,0.41176470588235292]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5882352941176471)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5784313725490196)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.58823529411764708],[0.,0.,0.57843137254901955]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4313725490196079)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4215686274509804)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.43137254901960786],[0.,0.,0.42156862745098045]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5784313725490196)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5686274509803921)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.57843137254901955],[0.,0.,0.56862745098039214]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4411764705882353)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4313725490196079)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.44117647058823528],[0.,0.,0.43137254901960786]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5686274509803921)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5588235294117647)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.56862745098039214],[0.,0.,0.55882352941176472]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4509803921568627)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4411764705882353)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.4509803921568627],[0.,0.,0.44117647058823528]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5588235294117647)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5490196078431373)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.55882352941176472],[0.,0.,0.5490196078431373]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4607843137254902)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4509803921568627)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.46078431372549022],[0.,0.,0.4509803921568627]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5490196078431373)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5392156862745099)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.5490196078431373],[0.,0.,0.53921568627450989]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4705882352941176)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4607843137254902)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.47058823529411764],[0.,0.,0.46078431372549022]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5392156862745099)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5294117647058824)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.53921568627450989],[0.,0.,0.52941176470588236]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4803921568627451)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4705882352941176)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.48039215686274506],[0.,0.,0.47058823529411764]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5294117647058824)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5196078431372548)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.52941176470588236],[0.,0.,0.51960784313725483]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.4901960784313726)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4803921568627451)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.49019607843137258],[0.,0.,0.48039215686274506]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5196078431372548)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5098039215686274)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.51960784313725483],[0.,0.,0.50980392156862742]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.4901960784313726)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 0.,0.,0.5],[0.,0.,0.49019607843137258]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (0.5098039215686274)-(1.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5)-(1.);

		var incenter = calulateIncenter([1.,0.,1.],[ 0.,0.,0.50980392156862742],[0.,0.,0.5]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (1.)-(1.);
		vector1[1] = (0.)-(0.);
		vector1[2] = (1.)-(0.);

		vector2[0] = (0.)-(1.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.5)-(0.);

		var incenter = calulateIncenter([1.,0.,0.],[ 1.,0.,1.],[0.,0.,0.5]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (1.)-(0.);
		vector1[2] = (0.)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.009803921568627416)-(0.);

		var incenter = calulateIncenter([0.,0.,0.],[ 0.,1.,0.],[0.,0.,0.0098039215686274161]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (1.)-(0.);
		vector1[2] = (1.)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(0.);
		vector2[2] = (0.9901960784313726)-(1.);

		var incenter = calulateIncenter([0.,0.,1.],[ 0.,1.,1.],[0.,0.,0.99019607843137258]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.01960784313725494)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.009803921568627416)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.019607843137254943],[0.,0.,0.0098039215686274161]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.9901960784313726)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.9803921568627451)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.99019607843137258],[0.,0.,0.98039215686274506]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.02941176470588236)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.01960784313725494)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.029411764705882359],[0.,0.,0.019607843137254943]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.9803921568627451)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.9705882352941176)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.98039215686274506],[0.,0.,0.97058823529411764]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.03921568627450978)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.02941176470588236)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.039215686274509776],[0.,0.,0.029411764705882359]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.9705882352941176)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.9607843137254902)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.97058823529411764],[0.,0.,0.96078431372549022]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.0490196078431373)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.03921568627450978)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.049019607843137303],[0.,0.,0.039215686274509776]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.9607843137254902)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.9509803921568627)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.96078431372549022],[0.,0.,0.9509803921568627]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.05882352941176472)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.0490196078431373)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.058823529411764719],[0.,0.,0.049019607843137303]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.9509803921568627)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.9411764705882353)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.9509803921568627],[0.,0.,0.94117647058823528]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.06862745098039214)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.05882352941176472)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.068627450980392135],[0.,0.,0.058823529411764719]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.9411764705882353)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.9313725490196079)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.94117647058823528],[0.,0.,0.93137254901960786]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.07843137254901966)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.06862745098039214)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.078431372549019662],[0.,0.,0.068627450980392135]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.9313725490196079)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.9215686274509804)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.93137254901960786],[0.,0.,0.92156862745098045]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.08823529411764708)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.07843137254901966)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.088235294117647078],[0.,0.,0.078431372549019662]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.9215686274509804)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.9117647058823529)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.92156862745098045],[0.,0.,0.91176470588235292]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.09803921568627449)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.08823529411764708)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.098039215686274495],[0.,0.,0.088235294117647078]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.9117647058823529)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.9019607843137255)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.91176470588235292],[0.,0.,0.90196078431372551]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.107843137254902)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.09803921568627449)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.10784313725490202],[0.,0.,0.098039215686274495]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.9019607843137255)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.892156862745098)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.90196078431372551],[0.,0.,0.89215686274509798]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.1176470588235294)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.107843137254902)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.11764705882352944],[0.,0.,0.10784313725490202]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.892156862745098)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.8823529411764706)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.89215686274509798],[0.,0.,0.88235294117647056]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.1274509803921569)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.1176470588235294)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.12745098039215685],[0.,0.,0.11764705882352944]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.8823529411764706)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.8725490196078431)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.88235294117647056],[0.,0.,0.87254901960784315]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.1372549019607843)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.1274509803921569)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.13725490196078427],[0.,0.,0.12745098039215685]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.8725490196078431)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.8627450980392157)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.87254901960784315],[0.,0.,0.86274509803921573]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.1470588235294118)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.1372549019607843)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.1470588235294118],[0.,0.,0.13725490196078427]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.8627450980392157)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.8529411764705882)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.86274509803921573],[0.,0.,0.8529411764705882]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.1568627450980392)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.1470588235294118)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.15686274509803921],[0.,0.,0.1470588235294118]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.8529411764705882)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.8431372549019608)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.8529411764705882],[0.,0.,0.84313725490196079]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.1666666666666666)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.1568627450980392)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.16666666666666663],[0.,0.,0.15686274509803921]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.8431372549019608)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.8333333333333334)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.84313725490196079],[0.,0.,0.83333333333333337]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.1764705882352942)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.1666666666666666)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.17647058823529416],[0.,0.,0.16666666666666663]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.8333333333333334)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.8235294117647058)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.83333333333333337],[0.,0.,0.82352941176470584]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.1862745098039216)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.1764705882352942)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.18627450980392157],[0.,0.,0.17647058823529416]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.8235294117647058)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.8137254901960784)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.82352941176470584],[0.,0.,0.81372549019607843]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.196078431372549)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.1862745098039216)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.19607843137254899],[0.,0.,0.18627450980392157]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.8137254901960784)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.803921568627451)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.81372549019607843],[0.,0.,0.80392156862745101]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.2058823529411765)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.196078431372549)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.20588235294117652],[0.,0.,0.19607843137254899]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.803921568627451)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.7941176470588236)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.80392156862745101],[0.,0.,0.79411764705882359]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.2156862745098039)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.2058823529411765)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.21568627450980393],[0.,0.,0.20588235294117652]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.7941176470588236)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.7843137254901961)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.79411764705882359],[0.,0.,0.78431372549019607]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.2254901960784313)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.2156862745098039)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.22549019607843135],[0.,0.,0.21568627450980393]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.7843137254901961)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.7745098039215687)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.78431372549019607],[0.,0.,0.77450980392156865]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.2352941176470589)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.2254901960784313)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.23529411764705888],[0.,0.,0.22549019607843135]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.7745098039215687)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.7647058823529411)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.77450980392156865],[0.,0.,0.76470588235294112]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.2450980392156863)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.2352941176470589)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.24509803921568629],[0.,0.,0.23529411764705888]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.7647058823529411)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.7549019607843137)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.76470588235294112],[0.,0.,0.75490196078431371]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.2549019607843137)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.2450980392156863)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.25490196078431371],[0.,0.,0.24509803921568629]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.7549019607843137)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.7450980392156863)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.75490196078431371],[0.,0.,0.74509803921568629]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.2647058823529412)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.2549019607843137)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.26470588235294124],[0.,0.,0.25490196078431371]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.7450980392156863)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.7352941176470589)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.74509803921568629],[0.,0.,0.73529411764705888]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.2745098039215687)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.2647058823529412)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.27450980392156865],[0.,0.,0.26470588235294124]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.7352941176470589)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.7254901960784313)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.73529411764705888],[0.,0.,0.72549019607843135]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.2843137254901961)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.2745098039215687)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.28431372549019607],[0.,0.,0.27450980392156865]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.7254901960784313)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.7156862745098039)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.72549019607843135],[0.,0.,0.71568627450980393]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.2941176470588236)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.2843137254901961)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.29411764705882359],[0.,0.,0.28431372549019607]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.7156862745098039)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.7058823529411764)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.71568627450980393],[0.,0.,0.70588235294117641]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.303921568627451)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.2941176470588236)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.30392156862745101],[0.,0.,0.29411764705882359]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.7058823529411764)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.696078431372549)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.70588235294117641],[0.,0.,0.69607843137254899]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.3137254901960784)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.303921568627451)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.31372549019607843],[0.,0.,0.30392156862745101]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.696078431372549)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.6862745098039216)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.69607843137254899],[0.,0.,0.68627450980392157]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.3235294117647058)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.3137254901960784)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.32352941176470584],[0.,0.,0.31372549019607843]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.6862745098039216)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.6764705882352942)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.68627450980392157],[0.,0.,0.67647058823529416]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.3333333333333334)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.3235294117647058)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.33333333333333337],[0.,0.,0.32352941176470584]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.6764705882352942)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.6666666666666667)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.67647058823529416],[0.,0.,0.66666666666666674]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.3431372549019608)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.3333333333333334)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.34313725490196079],[0.,0.,0.33333333333333337]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.6666666666666667)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.6568627450980392)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.66666666666666674],[0.,0.,0.65686274509803921]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.3529411764705882)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.3431372549019608)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.3529411764705882],[0.,0.,0.34313725490196079]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.6568627450980392)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.6470588235294118)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.65686274509803921],[0.,0.,0.6470588235294118]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.3627450980392157)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.3529411764705882)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.36274509803921573],[0.,0.,0.3529411764705882]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.6470588235294118)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.6372549019607843)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.6470588235294118],[0.,0.,0.63725490196078427]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.3725490196078431)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.3627450980392157)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.37254901960784315],[0.,0.,0.36274509803921573]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.6372549019607843)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.6274509803921569)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.63725490196078427],[0.,0.,0.62745098039215685]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.3823529411764706)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.3725490196078431)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.38235294117647056],[0.,0.,0.37254901960784315]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.6274509803921569)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.6176470588235294)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.62745098039215685],[0.,0.,0.61764705882352944]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.3921568627450981)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.3823529411764706)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.39215686274509809],[0.,0.,0.38235294117647056]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.6176470588235294)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.607843137254902)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.61764705882352944],[0.,0.,0.60784313725490202]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.4019607843137255)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.3921568627450981)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.40196078431372551],[0.,0.,0.39215686274509809]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.607843137254902)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.5980392156862745)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.60784313725490202],[0.,0.,0.59803921568627449]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.4117647058823529)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.4019607843137255)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.41176470588235292],[0.,0.,0.40196078431372551]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.5980392156862745)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.5882352941176471)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.59803921568627449],[0.,0.,0.58823529411764708]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.4215686274509804)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.4117647058823529)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.42156862745098045],[0.,0.,0.41176470588235292]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.5882352941176471)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.5784313725490196)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.58823529411764708],[0.,0.,0.57843137254901955]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.4313725490196079)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.4215686274509804)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.43137254901960786],[0.,0.,0.42156862745098045]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.5784313725490196)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.5686274509803921)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.57843137254901955],[0.,0.,0.56862745098039214]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.4411764705882353)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.4313725490196079)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.44117647058823528],[0.,0.,0.43137254901960786]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.5686274509803921)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.5588235294117647)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.56862745098039214],[0.,0.,0.55882352941176472]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.4509803921568627)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.4411764705882353)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.4509803921568627],[0.,0.,0.44117647058823528]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.5588235294117647)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.5490196078431373)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.55882352941176472],[0.,0.,0.5490196078431373]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.4607843137254902)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.4509803921568627)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.46078431372549022],[0.,0.,0.4509803921568627]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.5490196078431373)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.5392156862745099)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.5490196078431373],[0.,0.,0.53921568627450989]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.4705882352941176)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.4607843137254902)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.47058823529411764],[0.,0.,0.46078431372549022]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.5392156862745099)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.5294117647058824)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.53921568627450989],[0.,0.,0.52941176470588236]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.4803921568627451)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.4705882352941176)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.48039215686274506],[0.,0.,0.47058823529411764]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.5294117647058824)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.5196078431372548)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.52941176470588236],[0.,0.,0.51960784313725483]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.4901960784313726)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.4803921568627451)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.49019607843137258],[0.,0.,0.48039215686274506]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.5196078431372548)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.5098039215686274)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.51960784313725483],[0.,0.,0.50980392156862742]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.5)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.4901960784313726)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,0.,0.5],[0.,0.,0.49019607843137258]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (0.)-(1.);
		vector1[2] = (0.5098039215686274)-(1.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.5)-(1.);

		var incenter = calulateIncenter([0.,1.,1.],[ 0.,0.,0.50980392156862742],[0.,0.,0.5]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.)-(0.);
		vector1[1] = (1.)-(1.);
		vector1[2] = (1.)-(0.);

		vector2[0] = (0.)-(0.);
		vector2[1] = (0.)-(1.);
		vector2[2] = (0.5)-(0.);

		var incenter = calulateIncenter([0.,1.,0.],[ 0.,1.,1.],[0.,0.,0.5]);
		normals.push([vector1, vector2, incenter]);

	return normals;
	}
	// getNormalsCoordinates calculates the right coordinates for the ortogonality and fitting values from the gui 
	function getNormalsCoordinates(){
		var res = [];
		var normals = getNormalsVectors(); 
        for(var i = 0; i < normals.length; i++){
            var plus = [];
            var minus = [];

            minus[0] = normals[i][2][0] - (1/2)*guiParameters.normalsLength*(normals[i][0][1]*normals[i][1][2] - normals[i][0][2]*normals[i][1][1]);
            minus[1] = normals[i][2][1] - (1/2)*guiParameters.normalsLength*(normals[i][0][2]*normals[i][1][0] - normals[i][0][0]*normals[i][1][2]);
            minus[2] = normals[i][2][2] - (1/2)*guiParameters.normalsLength*(normals[i][0][0]*normals[i][1][1] - normals[i][0][1]*normals[i][1][0]);

            plus[0] = normals[i][2][0] + (1/2)*guiParameters.normalsLength*(normals[i][0][1]*normals[i][1][2] - normals[i][0][2]*normals[i][1][1]);
            plus[1] = normals[i][2][1] + (1/2)*guiParameters.normalsLength*(normals[i][0][2]*normals[i][1][0] - normals[i][0][0]*normals[i][1][2]);
            plus[2] = normals[i][2][2] + (1/2)*guiParameters.normalsLength*(normals[i][0][0]*normals[i][1][1] - normals[i][0][1]*normals[i][1][0]);

            res.push(minus[0]);
            res.push(minus[1]);
            res.push(minus[2]);
            res.push(plus[0]);
            res.push(plus[1]);
            res.push(plus[2]);
        }
        res = Float32Array.from(res);

    
		return res;
	}


    const normalsMaterial = new THREE.LineBasicMaterial( {
        color: 0x000000,
    } );
    
    const normalsGeometry = new THREE.BufferGeometry();
    normalsGeometry.setAttribute( 'position', new THREE.BufferAttribute( getNormalsCoordinates(), 3 ) );
    var normalsLine = new THREE.LineSegments( normalsGeometry, normalsMaterial );

    function updateNormals(){
        normalsGeometry.setAttribute( 'position', new THREE.BufferAttribute( getNormalsCoordinates(), 3 ) );
        normalsLine = new THREE.LineSegments( normalsGeometry, normalsMaterial );
    }
    
    normalsRoot.add(normalsLine);

    
	// generate automatic ranges for the intersections if the surface is not parameterized 
	guiParameters.maxX = 1.;
	guiParameters.maxY = 1.;
	guiParameters.maxZ = 1.;
	guiParameters.minX = -1.;
	guiParameters.minY = -1.;
	guiParameters.minZ = 0.;

	guiParameters.planeX = 0.;
	guiParameters.planeY = 0.;
	guiParameters.planeZ = 0.5;
	var performanceOverlayEnabled = false;
	// --- end of generated output --- //

    const center = new THREE.Vector3(guiParameters.planeX, guiParameters.planeY, guiParameters.planeZ);
    controls.target = center;
    
    const planeFolder = gui.addFolder("Intersection Planes");
    planeFolder.add(guiParameters, 'planeXactive');
    planeFolder.add(guiParameters, 'planeX', guiParameters.minX*1.1, guiParameters.maxX*1.1);
    planeFolder.add(guiParameters, 'planeYactive');
    planeFolder.add(guiParameters, 'planeY', guiParameters.minY*1.1, guiParameters.maxY*1.1);
    planeFolder.add(guiParameters, 'planeZactive');
    planeFolder.add(guiParameters, 'planeZ', guiParameters.minZ*1.1, guiParameters.maxZ*1.1);
    
    camera.position.x = Math.min((1.1)*Math.abs(guiParameters.minX), -1)
    camera.position.y = Math.min((1.1)*Math.abs(guiParameters.minY), -1)
    camera.position.z = Math.min((1.1)*Math.abs(guiParameters.minZ), -1)
    camera.lookAt(guiParameters.planeX,guiParameters.planeY,guiParameters.planeZ);

    scene.background = new THREE.Color( 'white' );

    // add both roots to the scene
    scene.add( meshRoot );
    scene.add( wireRoot );
    scene.add( vertexRoot );
    scene.add( vertexlabelRoot );
    scene.add( edgeRoot );
    scene.add( ringRoot );
    scene.add( normalsRoot );
    scene.add( normalMeshRoot );

    //presave some current gui parameters to only update if they change
    var currentCircleWidth = guiParameters.circleWidth;

    function animate() {
        requestAnimationFrame( animate );
        meshRoot.rotation.x += guiParameters.speedX/100;
        meshRoot.rotation.y += guiParameters.speedY/100;
        meshRoot.rotation.z += guiParameters.speedZ/100;

        wireRoot.rotation.x += guiParameters.speedX/100;
        wireRoot.rotation.y += guiParameters.speedY/100;
        wireRoot.rotation.z += guiParameters.speedZ/100;

        vertexRoot.rotation.x += guiParameters.speedX/100;
        vertexRoot.rotation.y += guiParameters.speedY/100;
        vertexRoot.rotation.z += guiParameters.speedZ/100;

        vertexlabelRoot.rotation.x += guiParameters.speedX/100;
        vertexlabelRoot.rotation.y += guiParameters.speedY/100;
        vertexlabelRoot.rotation.z += guiParameters.speedZ/100;

        edgeRoot.rotation.x += guiParameters.speedX/100;
        edgeRoot.rotation.y += guiParameters.speedY/100;
        edgeRoot.rotation.z += guiParameters.speedZ/100;

        ringRoot.rotation.x += guiParameters.speedX/100;
        ringRoot.rotation.y += guiParameters.speedY/100;
        ringRoot.rotation.z += guiParameters.speedZ/100;

        normalsRoot.rotation.x += guiParameters.speedX/100;
        normalsRoot.rotation.y += guiParameters.speedY/100;
        normalsRoot.rotation.z += guiParameters.speedZ/100;

        normalMeshRoot.rotation.x += guiParameters.speedX/100;
        normalMeshRoot.rotation.y += guiParameters.speedY/100;
        normalMeshRoot.rotation.z += guiParameters.speedZ/100;

        //update the light when the camera moves (with orbitcontrols)
        light.position.set(camera.position.x, camera.position.y, camera.position.z);

        planeX.constant = guiParameters.planeX;
        planeY.constant = guiParameters.planeY;
        planeZ.constant = guiParameters.planeZ;

        activePlanes = [];
        if(guiParameters.planeXactive){
            activePlanes.push(planeX);
        }
        if(guiParameters.planeYactive){
            activePlanes.push(planeY);
        }
        if(guiParameters.planeZactive){
            activePlanes.push(planeZ);
        }

        if(vertexParametriziation){
            updateFaceCoordinates();
            if(guiParameters.edgeVisibility){
                updateEdgeCoordinates();
            }
            if(guiParameters.vertexlabelVisibility || guiParameters.vertexVisibility){
                updateVertexCoordinates();
            }
            if(guiParameters.circleVisibility){
                updateCircles();
            }
        }                

        //update stuff that changes from the gui
        meshRoot.traverse( function( node ) {
            if ( node instanceof THREE.Mesh ) {
                node.material.opacity = guiParameters.transparency;
                node.material.clippingPlanes = activePlanes;
                if(guiParameters.normalsMaterial){
                    node.material.opacity = 0;
                }
            }
        } );

        normalMeshRoot.traverse( function( node ) {
            if ( node instanceof THREE.Mesh ) {
                node.material.opacity = guiParameters.transparency;
                node.material.clippingPlanes = activePlanes;
                if(!guiParameters.normalsMaterial){
                    node.material.opacity = 0;
                }
            }
        } );

        edgeRoot.traverse( function( node ) {
            if ( node instanceof Line2 ) {
                node.material.visible = guiParameters.edgeVisibility;
                node.material.linewidth = guiParameters.edgeWidth/100;
            }
            if ( node instanceof THREE.LineSegments ) {
                node.material.visible = guiParameters.edgeVisibility;
            }
        } );

        vertexRoot.traverse( function( node ) {
            if ( node instanceof THREE.Mesh ) {
                node.material.visible = guiParameters.vertexVisibility;
                node.scale.setScalar(guiParameters.vertexSize);
            }
        } );

        vertexlabelRoot.traverse( function( node ) {
            if( node instanceof CSS2DObject) {
                node.visible = guiParameters.vertexlabelVisibility;
            }
        } );

        ringRoot.traverse( function( node ) {
            if( node instanceof THREE.Mesh) {
                node.visible = guiParameters.circleVisibility;
            }
        } );

        normalsRoot.traverse( function( node ) {
            if( node instanceof THREE.LineSegments) {
                node.visible = guiParameters.normalsVisibility;
            }
        } );

        // update the circle width
        if(guiParameters.circleVisibility && currentCircleWidth != guiParameters.circleWidth){
            updateCircleWidth();
            currentCircleWidth = guiParameters.circleWidth;
        }

        //update the normals length 
        if(guiParameters.normalsVisibility){
            updateNormals();
        }

        //update controls
        controls.update();

        //update performance overlay of enabled
        if(performanceOverlayEnabled){
            stats.update();
        }

        renderer.localClippingEnabled = true;

        renderer.render( scene, camera );
        labelRenderer.render( scene, camera );
    }
    animate();

    //resize of window size changes
    window.addEventListener( 'resize', onWindowResize );
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
        labelRenderer.setSize( window.innerWidth, window.innerHeight );
    }
</script>

</body>
</html>