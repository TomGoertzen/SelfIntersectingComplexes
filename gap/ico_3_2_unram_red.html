<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>SimplicialSurface</title>
		<style>
			body { margin: 0; }
		</style>


	</head>
	<body>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>


<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three@0.148.0/build/three.module.js",
			"three/addons/": "https://unpkg.com/three@0.148.0/examples/jsm/",
			"gui": "https://unpkg.com/dat.gui@0.7.9/build/dat.gui.module.js"
		}
	}
</script>


<script type="module">
	import * as THREE from 'three';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
	import { GUI } from 'gui';
	import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
	import { Line2 } from 'three/addons/lines/Line2.js';
	import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
	import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';

	//start scene and camera
	const scene = new THREE.Scene();
	const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 100 );

	const renderer = new THREE.WebGLRenderer({ antialias: true });
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	//Lights
	const skyColor = 0xFFFFFF;
	const skyIntensity = 0.3;
	const skyLight = new THREE.AmbientLight(skyColor, skyIntensity);
	scene.add(skyLight);

	const color = 0xFFFFFF;
	const intensity = 1;
	const light = new THREE.PointLight(color, intensity);
	light.position.set(0, 3, -5);
	scene.add(light);

	//create groups to add everything to
	const meshRoot = new THREE.Group();
	const wireRoot = new THREE.Group();
	const vertexRoot = new THREE.Group();
	const vertexlabelRoot = new THREE.Group();
	const edgeRoot = new THREE.Group();
	const ringRoot = new THREE.Group();
	const normalsRoot = new THREE.Group();
	const normalMeshRoot = new THREE.Group();

	//parameters for the controls on the top right
	var guiParameters = new function() { 
		this.speedX = 0.0; 
		this.speedY = 0.0; 
		this.speedZ = 0.0;
		this.transparency = 1;
		this.edgeVisibility = false;
		this.edgeWidth = 0.2;

		this.vertexVisibility = true;
		this.vertexlabelVisibility = false;
		this.vertexSize = 1;
		this.planeX = 0.0;
		this.minX = -1.5;
		this.maxX = 1.5;
		this.planeXactive = false;
		this.planeY = 0.0;
		this.minY = -1.5;

		this.maxY = 1.5;
		this.planeYactive = false;
		this.planeZ = 0.0;
		this.minZ = -1.5;
		this.maxZ = 1.5;
		this.planeZactive = false;
		this.normalsMaterial = false;
		this.circleVisibility = false;
		this.circleWidth = 0.005;
		this.normalsVisibility = false;
		this.normalsLength = 1;
	} ;

	//generate the plane for intersections
	const planeX = new THREE.Plane( new THREE.Vector3( -1, 0, 0 ), guiParameters.planeX );
	const planeY = new THREE.Plane( new THREE.Vector3( 0, -1, 0 ), guiParameters.planeY );
	const planeZ = new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), guiParameters.planeZ );

	// the array which ones are currently active
	var activePlanes = [];

	//rederer for lables
	const labelRenderer = new CSS2DRenderer();
	labelRenderer.setSize( window.innerWidth, window.innerHeight );
	labelRenderer.domElement.style.position = 'absolute';
	labelRenderer.domElement.style.top = '0px';
	document.body.appendChild( labelRenderer.domElement );
	
	//controls for mouse 
	const controls = new OrbitControls( camera, labelRenderer.domElement );

	//controls in the top right corner
	var gui = new GUI();

	const animationFolder = gui.addFolder("Animations");
	animationFolder.add(guiParameters, 'speedX', 0, 5);
	animationFolder.add(guiParameters, 'speedY', 0, 5);
	animationFolder.add(guiParameters, 'speedZ', 0, 5);
	animationFolder.open();

	const controlFolder = gui.addFolder("Controls");
	controlFolder.add(guiParameters, "transparency", 0, 1);
	controlFolder.add(guiParameters, "edgeVisibility");
	var edgeWidthGUI = controlFolder.add(guiParameters, "edgeWidth", 0.01, 2);
	controlFolder.add(guiParameters, "vertexVisibility");
	controlFolder.add(guiParameters, "vertexlabelVisibility");
	controlFolder.add(guiParameters, "vertexSize", 0.1, 3);
	controlFolder.add(guiParameters, "normalsMaterial");
	controlFolder.add(guiParameters, "circleVisibility");
	controlFolder.add(guiParameters, "circleWidth", 0.0001, 0.1);
	controlFolder.add(guiParameters, "normalsVisibility");
	controlFolder.add(guiParameters, "normalsLength", 0, 2);
	controlFolder.open();

	//generate a sphere geometry for the vertices
	const sphereGeometry = new THREE.SphereGeometry( 0.02, 32, 16 );
	sphereGeometry.transparent = guiParameters.vertexVisibility;
	
	//functions for later calculations

	function calulateIncenter(A, B, C){
		//we follow the math and variable names from here: https://math.stackexchange.com/questions/740111/incenter-of-triangle-in-3d
		var a = Math.sqrt((B[0]-C[0])**2 + (B[1]-C[1])**2 + (B[2]-C[2])**2);
		var b = Math.sqrt((C[0]-A[0])**2 + (C[1]-A[1])**2 + (C[2]-A[2])**2);
		var c = Math.sqrt((A[0]-B[0])**2 + (A[1]-B[1])**2 + (A[2]-B[2])**2);

		var res = [];
		res[0] = a/(a+b+c)*A[0] + b/(a+b+c)*B[0] + c/(a+b+c)*C[0];
		res[1] = a/(a+b+c)*A[1] + b/(a+b+c)*B[1] + c/(a+b+c)*C[1];
		res[2] = a/(a+b+c)*A[2] + b/(a+b+c)*B[2] + c/(a+b+c)*C[2];

		return res;
	}

	function calulateInradius(A, B, C){
		var a = Math.sqrt((B[0]-C[0])**2 + (B[1]-C[1])**2 + (B[2]-C[2])**2);
		var b = Math.sqrt((C[0]-A[0])**2 + (C[1]-A[1])**2 + (C[2]-A[2])**2);
		var c = Math.sqrt((A[0]-B[0])**2 + (A[1]-B[1])**2 + (A[2]-B[2])**2);

		var s = (a+b+c)/2;
		var inradius = Math.sqrt(((s-a)*(s-b)*(s-c)) / s );

		return inradius;
	}

	// --- start of generated output --- //

	// preperations for parameterized vertex coordinates 
	const vertexParametriziation = false;
	// generate the faces color by color 
	const geometry1 = new THREE.BufferGeometry();
	function setVertices1(){
		var vertices1 = new Float32Array( [
				0.951056516,0.,0.,
			0.425325404,0.8506508085,0.,
			0.425325404,0.262865556,0.809016994,

			0.951056516,0.,0.,
			0.425325404,0.8506508085,0.,
			0.1519452257355765,0.05639505893132235,0.06136807718159009,

			0.951056516,0.,0.,
			0.425325404,0.262865556,0.809016994,
			0.425325404,-0.6881909604000001,0.4999999998,

			0.951056516,0.,0.,
			0.1519452257355765,0.05639505893132235,0.06136807718159009,
			0.1657517901096376,-0.01731415965562747,0.06710716423321821,

			0.951056516,0.,0.,
			0.1098867367622748,-0.0945461097393121,0.01458980334578874,
			0.1657517901096376,-0.01731415965562747,0.06710716423321821,

			0.951056516,0.,0.,
			0.425325404,-0.6881909604000001,0.4999999998,
			0.425325404,-0.6881909604000001,-0.4999999998,

			0.951056516,0.,0.,
			0.425325404,-0.6881909604000001,-0.4999999998,
			0.1098867367622748,-0.0945461097393121,0.01458980334578874,

			0.425325404,0.8506508085,0.,
			0.425325404,0.262865556,0.809016994,
			-0.425325404,0.6881909604000001,0.4999999998,

			0.425325404,0.8506508085,0.,
			0.1519452257355765,0.05639505893132235,0.06136807718159009,
			0.05137477354054257,0.1596287483457181,0.0644678440128061,

			0.425325404,0.8506508085,0.,
			0.05137477354054257,0.1596287483457181,0.0644678440128061,
			-0.005118984749543602,0.1724394192620157,0.01649963342152638,

			0.425325404,0.8506508085,0.,
			-0.425325404,0.6881909604000001,0.4999999998,
			-0.425325404,0.6881909604000001,-0.4999999998,

			0.425325404,0.8506508085,0.,
			-0.425325404,0.6881909604000001,-0.4999999998,
			-0.005118984749543602,0.1724394192620157,0.01649963342152638,

			0.425325404,0.262865556,0.809016994,
			0.1098867367749586,0.06791373824254217,0.06737620779366739,
			0.1252273638565441,-0.02301094063083842,0.07082039315948314,

			0.425325404,0.262865556,0.809016994,
			0.1098867367749586,0.06791373824254217,0.06737620779366739,
			0.03542176863691715,0.1222975648548171,0.07082039316041153,

			0.425325404,0.262865556,0.809016994,
			0.1252273638565441,-0.02301094063083842,0.07082039315948314,
			0.425325404,-0.6881909604000001,0.4999999998,

			0.425325404,0.262865556,0.809016994,
			0.03542176863691715,0.1222975648548171,0.07082039316041153,
			-0.425325404,0.6881909604000001,0.4999999998,

			-0.0449027976,-0.0277514551,0.08541019649999999,
			0.1252273638565441,-0.02301094063083842,0.07082039315948314,
			0.03542176863691715,0.1222975648548171,0.07082039316041153,

			-0.0449027976,-0.0277514551,0.08541019649999999,
			0.1252273638565441,-0.02301094063083842,0.07082039315948314,
			0.0354217686536573,-0.140567991027654,-0.01458980336871456,

			-0.0449027976,-0.0277514551,0.08541019649999999,
			0.03542176863691715,0.1222975648548171,0.07082039316041153,
			-0.1183932448542015,0.1256159250281217,0.01541019663681068,

			-0.0449027976,-0.0277514551,0.08541019649999999,
			0.0354217686536573,-0.140567991027654,-0.01458980336871456,
			-0.1519452257355765,-0.05639505893132236,-0.06136807718159017,

			-0.0449027976,-0.0277514551,0.08541019649999999,
			-0.1183932448542015,0.1256159250281217,0.01541019663681068,
			-0.1519452257355765,-0.05639505893132236,-0.06136807718159017,

			0.1098867367749586,0.06791373824254217,0.06737620779366739,
			0.1252273638565441,-0.02301094063083842,0.07082039315948314,
			0.03542176863691715,0.1222975648548171,0.07082039316041153,

			0.1098867367622748,-0.0945461097393121,0.01458980334578874,
			0.1519452257355765,0.05639505893132235,0.06136807718159009,
			0.1657517901096376,-0.01731415965562747,0.06710716423321821,

			0.1519452257355765,0.05639505893132235,0.06136807718159009,
			0.05137477354054257,0.1596287483457181,0.0644678440128061,
			-0.005118984749543602,0.1724394192620157,0.01649963342152638,

			0.1098867367622748,-0.0945461097393121,0.01458980334578874,
			0.0449027976,0.0277514551,-0.08541019649999999,
			0.1519452257355765,0.05639505893132235,0.06136807718159009,

			0.0449027976,0.0277514551,-0.08541019649999999,
			0.1519452257355765,0.05639505893132235,0.06136807718159009,
			-0.005118984749543602,0.1724394192620157,0.01649963342152638,

			0.1252273638565441,-0.02301094063083842,0.07082039315948314,
			0.425325404,-0.6881909604000001,0.4999999998,
			0.1264257014788746,-0.1206515938169228,0.04167184265918403,

			0.1252273638565441,-0.02301094063083842,0.07082039315948314,
			0.0354217686536573,-0.140567991027654,-0.01458980336871456,
			0.1264257014788746,-0.1206515938169228,0.04167184265918403,

			0.03542176863691715,0.1222975648548171,0.07082039316041153,
			-0.425325404,0.6881909604000001,0.4999999998,
			-0.03542176865365726,0.1405679910276539,0.01458980336871446,

			0.03542176863691715,0.1222975648548171,0.07082039316041153,
			-0.03542176865365726,0.1405679910276539,0.01458980336871446,
			-0.1183932448542015,0.1256159250281217,0.01541019663681068,

			0.425325404,-0.6881909604000001,0.4999999998,
			0.425325404,-0.6881909604000001,-0.4999999998,
			-0.425325404,-0.8506508085,0.,

			0.425325404,-0.6881909604000001,0.4999999998,
			0.0354217686536573,-0.140567991027654,-0.01458980336871456,
			0.1264257014788746,-0.1206515938169228,0.04167184265918403,

			0.425325404,-0.6881909604000001,0.4999999998,
			0.0354217686536573,-0.140567991027654,-0.01458980336871456,
			-0.425325404,-0.8506508085,0.,

			0.425325404,-0.6881909604000001,-0.4999999998,
			0.1098867367622748,-0.0945461097393121,0.01458980334578874,
			0.05864019882640532,-0.1656480454318542,-0.03740133285455366,

			0.425325404,-0.6881909604000001,-0.4999999998,
			-0.03542176863691709,-0.122297564854817,-0.07082039316041154,
			0.05864019882640532,-0.1656480454318542,-0.03740133285455366,

			0.425325404,-0.6881909604000001,-0.4999999998,
			-0.425325404,-0.262865556,-0.809016994,
			-0.03542176863691709,-0.122297564854817,-0.07082039316041154,

			0.425325404,-0.6881909604000001,-0.4999999998,
			-0.425325404,-0.262865556,-0.809016994,
			-0.425325404,-0.8506508085,0.,

			0.1098867367622748,-0.0945461097393121,0.01458980334578874,
			-0.03542176863691709,-0.122297564854817,-0.07082039316041154,
			0.05864019882640532,-0.1656480454318542,-0.03740133285455366,

			0.1098867367622748,-0.0945461097393121,0.01458980334578874,
			0.0449027976,0.0277514551,-0.08541019649999999,
			-0.03542176863691709,-0.122297564854817,-0.07082039316041154,

			0.0354217686536573,-0.140567991027654,-0.01458980336871456,
			-0.1519452257355765,-0.05639505893132236,-0.06136807718159017,
			-0.05137477354054253,-0.159628748345718,-0.06446784401280611,

			0.0354217686536573,-0.140567991027654,-0.01458980336871456,
			-0.425325404,-0.8506508085,0.,
			-0.05137477354054253,-0.159628748345718,-0.06446784401280611,

			-0.425325404,0.6881909604000001,0.4999999998,
			-0.425325404,0.6881909604000001,-0.4999999998,
			-0.951056516,0.,0.,

			-0.425325404,0.6881909604000001,0.4999999998,
			-0.03542176865365726,0.1405679910276539,0.01458980336871446,
			-0.1183932448542015,0.1256159250281217,0.01541019663681068,

			-0.425325404,0.6881909604000001,0.4999999998,
			-0.951056516,0.,0.,
			-0.1183932448542015,0.1256159250281217,0.01541019663681068,

			-0.425325404,0.6881909604000001,-0.4999999998,
			-0.1098867367622748,0.09454610973931203,-0.01458980334578877,
			-0.005118984749543602,0.1724394192620157,0.01649963342152638,

			-0.425325404,0.6881909604000001,-0.4999999998,
			-0.1098867367622748,0.09454610973931203,-0.01458980334578877,
			-0.1357419861035725,0.06214779413913728,-0.08800886366509909,

			-0.425325404,0.6881909604000001,-0.4999999998,
			-0.425325404,-0.262865556,-0.809016994,
			-0.1357419861035725,0.06214779413913728,-0.08800886366509909,

			-0.425325404,0.6881909604000001,-0.4999999998,
			-0.425325404,-0.262865556,-0.809016994,
			-0.951056516,0.,0.,

			-0.1098867367622748,0.09454610973931203,-0.01458980334578877,
			-0.005118984749543602,0.1724394192620157,0.01649963342152638,
			-0.1357419861035725,0.06214779413913728,-0.08800886366509909,

			0.0449027976,0.0277514551,-0.08541019649999999,
			-0.005118984749543602,0.1724394192620157,0.01649963342152638,
			-0.1357419861035725,0.06214779413913728,-0.08800886366509909,

			-0.1252273638565441,0.02301094063083842,-0.07082039315948313,
			-0.1183932448542015,0.1256159250281217,0.01541019663681068,
			-0.1519452257355765,-0.05639505893132236,-0.06136807718159017,

			-0.1252273638565441,0.02301094063083842,-0.07082039315948313,
			-0.951056516,0.,0.,
			-0.1183932448542015,0.1256159250281217,0.01541019663681068,

			0.0449027976,0.0277514551,-0.08541019649999999,
			-0.03542176863691709,-0.122297564854817,-0.07082039316041154,
			-0.1357419861035725,0.06214779413913728,-0.08800886366509909,

			-0.425325404,-0.262865556,-0.809016994,
			-0.03542176863691709,-0.122297564854817,-0.07082039316041154,
			-0.1098867367749586,-0.06791373824254218,-0.06737620779366749,

			-0.425325404,-0.262865556,-0.809016994,
			-0.1098867367749586,-0.06791373824254218,-0.06737620779366749,
			-0.1357419861035725,0.06214779413913728,-0.08800886366509909,

			-0.425325404,-0.262865556,-0.809016994,
			-0.425325404,-0.8506508085,0.,
			-0.951056516,0.,0.,

			-0.03542176863691709,-0.122297564854817,-0.07082039316041154,
			-0.1098867367749586,-0.06791373824254218,-0.06737620779366749,
			-0.1357419861035725,0.06214779413913728,-0.08800886366509909,

			-0.425325404,-0.8506508085,0.,
			-0.1519452257355765,-0.05639505893132236,-0.06136807718159017,
			-0.05137477354054253,-0.159628748345718,-0.06446784401280611,

			-0.1252273638565441,0.02301094063083842,-0.07082039315948313,
			-0.951056516,0.,0.,
			-0.1519452257355765,-0.05639505893132236,-0.06136807718159017,

			-0.425325404,-0.8506508085,0.,
			-0.951056516,0.,0.,
			-0.1519452257355765,-0.05639505893132236,-0.06136807718159017,

					] ); 

		return vertices1; 
	}

	geometry1.setAttribute( 'position', new THREE.BufferAttribute( setVertices1(), 3 ) );

	// generate materials in the given color and normals material for the faces 

    const materialNormal1 = new THREE.MeshNormalMaterial({
        flatShading: true,
    });
    materialNormal1.transparent = true;
    materialNormal1.side = THREE.DoubleSide;
        
    const material1 = new THREE.MeshPhongMaterial({
        color: 0x049EF4,
        flatShading: true,
    });
    material1.transparent = true;
    material1.side = THREE.DoubleSide;
        
	// generate meshes for the faces from the materials with the vertex coordinates from before 

    const mesh1 = new THREE.Mesh( geometry1, material1 );
    mesh1.castShadow = true;                         
    mesh1.receiveShadow = true;                      
                                
    meshRoot.add(mesh1);
        
    const meshNormal1 = new THREE.Mesh( geometry1, materialNormal1 );
    mesh1.castShadow = true;                         
    mesh1.receiveShadow = true;                      
                                
    normalMeshRoot.add(meshNormal1);
        
	// generate the edges grouped by color
		controlFolder.remove(edgeWidthGUI);

    const edgeMaterial1 = new THREE.LineBasicMaterial( {
        color: 0xFF0000,
        linewidth: 3.,
    } );
        
	function getEdges1(){
		const edges1 = new Float32Array( [
			0.10988673677495858,0.067913738242542168,0.067376207793667389,
			0.12522736385654409,-0.02301094063083842,0.070820393159483144,

			0.10988673677495858,0.067913738242542168,0.067376207793667389,
			0.03542176863691715,0.12229756485481713,0.070820393160411527,

			0.12522736385654409,-0.02301094063083842,0.070820393159483144,
			0.12642570147887455,-0.12065159381692281,0.041671842659184027,

			0.03542176863691715,0.12229756485481713,0.070820393160411527,
			-0.03542176865365726,0.14056799102765394,0.01458980336871446,

			0.10988673676227484,-0.094546109739312101,0.014589803345788743,
			0.058640198826405317,-0.16564804543185419,-0.037401332854553659,

			0.10988673676227484,-0.094546109739312101,0.014589803345788743,
			0.16575179010963761,-0.017314159655627472,0.067107164233218206,

			0.035421768653657301,-0.14056799102765397,-0.014589803368714557,
			-0.051374773540542526,-0.15962874834571802,-0.064467844012806114,

			0.035421768653657301,-0.14056799102765397,-0.014589803368714557,
			0.12642570147887455,-0.12065159381692281,0.041671842659184027,

			-0.03542176865365726,0.14056799102765394,0.01458980336871446,
			-0.11839324485420148,0.12561592502812169,0.015410196636810683,

			-0.10988673676227483,0.094546109739312031,-0.014589803345788771,
			-0.0051189847495436017,0.17243941926201567,0.016499633421526383,

			-0.10988673676227483,0.094546109739312031,-0.014589803345788771,
			-0.13574198610357255,0.062147794139137284,-0.088008863665099094,

			-0.035421768636917095,-0.12229756485481702,-0.070820393160411541,
			-0.10988673677495864,-0.067913738242542182,-0.067376207793667486,

			-0.035421768636917095,-0.12229756485481702,-0.070820393160411541,
			0.058640198826405317,-0.16564804543185419,-0.037401332854553659,

			-0.10988673677495864,-0.067913738242542182,-0.067376207793667486,
			-0.13574198610357255,0.062147794139137284,-0.088008863665099094,

			-0.12522736385654409,0.02301094063083842,-0.07082039315948313,
			-0.11839324485420148,0.12561592502812169,0.015410196636810683,

			-0.12522736385654409,0.02301094063083842,-0.07082039315948313,
			-0.15194522573557651,-0.056395058931322357,-0.061368077181590173,

			0.15194522573557648,0.05639505893132235,0.06136807718159009,
			0.051374773540542575,0.15962874834571811,0.0644678440128061,

			0.15194522573557648,0.05639505893132235,0.06136807718159009,
			0.16575179010963761,-0.017314159655627472,0.067107164233218206,

			0.051374773540542575,0.15962874834571811,0.0644678440128061,
			-0.0051189847495436017,0.17243941926201567,0.016499633421526383,

			-0.15194522573557651,-0.056395058931322357,-0.061368077181590173,
			-0.051374773540542526,-0.15962874834571802,-0.064467844012806114,

		]);
		return edges1;
	}


	// generate geometries and lines for the edges 

    const edgeGeometry1 = new THREE.BufferGeometry();
    edgeGeometry1.setAttribute( 'position', new THREE.BufferAttribute( getEdges1(), 3 ) );

    const edgeLine1 = new THREE.LineSegments( edgeGeometry1, edgeMaterial1 );
    edgeRoot.add(edgeLine1);
        
	// update function to be called every frame 
	// generate labels and spheres for the vertices


	function getVertex1(){
		return [0.95105651599999996,0.,0.,];
	}
	const sphereMaterial1 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere1 = new THREE.Mesh( sphereGeometry, sphereMaterial1 );
	vertexRoot.add(sphere1);
	sphere1.position.set(getVertex1()[0],getVertex1()[1],getVertex1()[2]);

    const lableDiv1 = document.createElement( 'div' );
    lableDiv1.className = 'label';
    lableDiv1.textContent = '1';
    lableDiv1.style.marginTop = '-1em';

    const vertexLabel1 = new CSS2DObject( lableDiv1 );
    vertexLabel1.position.set(getVertex1()[0],getVertex1()[1],getVertex1()[2]);
    vertexlabelRoot.add( vertexLabel1 );
            
            

	function getVertex2(){
		return [0.42532540400000002,0.85065080849999997,0.,];
	}
	const sphereMaterial2 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere2 = new THREE.Mesh( sphereGeometry, sphereMaterial2 );
	vertexRoot.add(sphere2);
	sphere2.position.set(getVertex2()[0],getVertex2()[1],getVertex2()[2]);

    const lableDiv2 = document.createElement( 'div' );
    lableDiv2.className = 'label';
    lableDiv2.textContent = '2';
    lableDiv2.style.marginTop = '-1em';

    const vertexLabel2 = new CSS2DObject( lableDiv2 );
    vertexLabel2.position.set(getVertex2()[0],getVertex2()[1],getVertex2()[2]);
    vertexlabelRoot.add( vertexLabel2 );
            
            

	function getVertex3(){
		return [0.42532540400000002,0.262865556,0.80901699400000004,];
	}
	const sphereMaterial3 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere3 = new THREE.Mesh( sphereGeometry, sphereMaterial3 );
	vertexRoot.add(sphere3);
	sphere3.position.set(getVertex3()[0],getVertex3()[1],getVertex3()[2]);

    const lableDiv3 = document.createElement( 'div' );
    lableDiv3.className = 'label';
    lableDiv3.textContent = '3';
    lableDiv3.style.marginTop = '-1em';

    const vertexLabel3 = new CSS2DObject( lableDiv3 );
    vertexLabel3.position.set(getVertex3()[0],getVertex3()[1],getVertex3()[2]);
    vertexlabelRoot.add( vertexLabel3 );
            
            

	function getVertex4(){
		return [-0.044902797600000002,-0.027751455099999999,0.085410196499999994,];
	}
	const sphereMaterial4 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere4 = new THREE.Mesh( sphereGeometry, sphereMaterial4 );
	vertexRoot.add(sphere4);
	sphere4.position.set(getVertex4()[0],getVertex4()[1],getVertex4()[2]);

    const lableDiv4 = document.createElement( 'div' );
    lableDiv4.className = 'label';
    lableDiv4.textContent = '4';
    lableDiv4.style.marginTop = '-1em';

    const vertexLabel4 = new CSS2DObject( lableDiv4 );
    vertexLabel4.position.set(getVertex4()[0],getVertex4()[1],getVertex4()[2]);
    vertexlabelRoot.add( vertexLabel4 );
            
            

	function getVertex5(){
		return [0.10988673677495858,0.067913738242542168,0.067376207793667389,];
	}
	const sphereMaterial5 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere5 = new THREE.Mesh( sphereGeometry, sphereMaterial5 );
	vertexRoot.add(sphere5);
	sphere5.position.set(getVertex5()[0],getVertex5()[1],getVertex5()[2]);

    const lableDiv5 = document.createElement( 'div' );
    lableDiv5.className = 'label';
    lableDiv5.textContent = '5';
    lableDiv5.style.marginTop = '-1em';

    const vertexLabel5 = new CSS2DObject( lableDiv5 );
    vertexLabel5.position.set(getVertex5()[0],getVertex5()[1],getVertex5()[2]);
    vertexlabelRoot.add( vertexLabel5 );
            
            

	function getVertex6(){
		return [0.12522736385654409,-0.02301094063083842,0.070820393159483144,];
	}
	const sphereMaterial6 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere6 = new THREE.Mesh( sphereGeometry, sphereMaterial6 );
	vertexRoot.add(sphere6);
	sphere6.position.set(getVertex6()[0],getVertex6()[1],getVertex6()[2]);

    const lableDiv6 = document.createElement( 'div' );
    lableDiv6.className = 'label';
    lableDiv6.textContent = '6';
    lableDiv6.style.marginTop = '-1em';

    const vertexLabel6 = new CSS2DObject( lableDiv6 );
    vertexLabel6.position.set(getVertex6()[0],getVertex6()[1],getVertex6()[2]);
    vertexlabelRoot.add( vertexLabel6 );
            
            

	function getVertex7(){
		return [0.03542176863691715,0.12229756485481713,0.070820393160411527,];
	}
	const sphereMaterial7 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere7 = new THREE.Mesh( sphereGeometry, sphereMaterial7 );
	vertexRoot.add(sphere7);
	sphere7.position.set(getVertex7()[0],getVertex7()[1],getVertex7()[2]);

    const lableDiv7 = document.createElement( 'div' );
    lableDiv7.className = 'label';
    lableDiv7.textContent = '7';
    lableDiv7.style.marginTop = '-1em';

    const vertexLabel7 = new CSS2DObject( lableDiv7 );
    vertexLabel7.position.set(getVertex7()[0],getVertex7()[1],getVertex7()[2]);
    vertexlabelRoot.add( vertexLabel7 );
            
            

	function getVertex8(){
		return [0.42532540400000002,-0.68819096040000005,0.49999999979999998,];
	}
	const sphereMaterial8 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere8 = new THREE.Mesh( sphereGeometry, sphereMaterial8 );
	vertexRoot.add(sphere8);
	sphere8.position.set(getVertex8()[0],getVertex8()[1],getVertex8()[2]);

    const lableDiv8 = document.createElement( 'div' );
    lableDiv8.className = 'label';
    lableDiv8.textContent = '8';
    lableDiv8.style.marginTop = '-1em';

    const vertexLabel8 = new CSS2DObject( lableDiv8 );
    vertexLabel8.position.set(getVertex8()[0],getVertex8()[1],getVertex8()[2]);
    vertexlabelRoot.add( vertexLabel8 );
            
            

	function getVertex9(){
		return [0.42532540400000002,-0.68819096040000005,-0.49999999979999998,];
	}
	const sphereMaterial9 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere9 = new THREE.Mesh( sphereGeometry, sphereMaterial9 );
	vertexRoot.add(sphere9);
	sphere9.position.set(getVertex9()[0],getVertex9()[1],getVertex9()[2]);

    const lableDiv9 = document.createElement( 'div' );
    lableDiv9.className = 'label';
    lableDiv9.textContent = '9';
    lableDiv9.style.marginTop = '-1em';

    const vertexLabel9 = new CSS2DObject( lableDiv9 );
    vertexLabel9.position.set(getVertex9()[0],getVertex9()[1],getVertex9()[2]);
    vertexlabelRoot.add( vertexLabel9 );
            
            

	function getVertex10(){
		return [0.10988673676227484,-0.094546109739312101,0.014589803345788743,];
	}
	const sphereMaterial10 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere10 = new THREE.Mesh( sphereGeometry, sphereMaterial10 );
	vertexRoot.add(sphere10);
	sphere10.position.set(getVertex10()[0],getVertex10()[1],getVertex10()[2]);

    const lableDiv10 = document.createElement( 'div' );
    lableDiv10.className = 'label';
    lableDiv10.textContent = '10';
    lableDiv10.style.marginTop = '-1em';

    const vertexLabel10 = new CSS2DObject( lableDiv10 );
    vertexLabel10.position.set(getVertex10()[0],getVertex10()[1],getVertex10()[2]);
    vertexlabelRoot.add( vertexLabel10 );
            
            

	function getVertex11(){
		return [0.035421768653657301,-0.14056799102765397,-0.014589803368714557,];
	}
	const sphereMaterial11 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere11 = new THREE.Mesh( sphereGeometry, sphereMaterial11 );
	vertexRoot.add(sphere11);
	sphere11.position.set(getVertex11()[0],getVertex11()[1],getVertex11()[2]);

    const lableDiv11 = document.createElement( 'div' );
    lableDiv11.className = 'label';
    lableDiv11.textContent = '11';
    lableDiv11.style.marginTop = '-1em';

    const vertexLabel11 = new CSS2DObject( lableDiv11 );
    vertexLabel11.position.set(getVertex11()[0],getVertex11()[1],getVertex11()[2]);
    vertexlabelRoot.add( vertexLabel11 );
            
            

	function getVertex12(){
		return [-0.42532540400000002,0.68819096040000005,0.49999999979999998,];
	}
	const sphereMaterial12 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere12 = new THREE.Mesh( sphereGeometry, sphereMaterial12 );
	vertexRoot.add(sphere12);
	sphere12.position.set(getVertex12()[0],getVertex12()[1],getVertex12()[2]);

    const lableDiv12 = document.createElement( 'div' );
    lableDiv12.className = 'label';
    lableDiv12.textContent = '12';
    lableDiv12.style.marginTop = '-1em';

    const vertexLabel12 = new CSS2DObject( lableDiv12 );
    vertexLabel12.position.set(getVertex12()[0],getVertex12()[1],getVertex12()[2]);
    vertexlabelRoot.add( vertexLabel12 );
            
            

	function getVertex13(){
		return [-0.42532540400000002,0.68819096040000005,-0.49999999979999998,];
	}
	const sphereMaterial13 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere13 = new THREE.Mesh( sphereGeometry, sphereMaterial13 );
	vertexRoot.add(sphere13);
	sphere13.position.set(getVertex13()[0],getVertex13()[1],getVertex13()[2]);

    const lableDiv13 = document.createElement( 'div' );
    lableDiv13.className = 'label';
    lableDiv13.textContent = '13';
    lableDiv13.style.marginTop = '-1em';

    const vertexLabel13 = new CSS2DObject( lableDiv13 );
    vertexLabel13.position.set(getVertex13()[0],getVertex13()[1],getVertex13()[2]);
    vertexlabelRoot.add( vertexLabel13 );
            
            

	function getVertex14(){
		return [-0.03542176865365726,0.14056799102765394,0.01458980336871446,];
	}
	const sphereMaterial14 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere14 = new THREE.Mesh( sphereGeometry, sphereMaterial14 );
	vertexRoot.add(sphere14);
	sphere14.position.set(getVertex14()[0],getVertex14()[1],getVertex14()[2]);

    const lableDiv14 = document.createElement( 'div' );
    lableDiv14.className = 'label';
    lableDiv14.textContent = '14';
    lableDiv14.style.marginTop = '-1em';

    const vertexLabel14 = new CSS2DObject( lableDiv14 );
    vertexLabel14.position.set(getVertex14()[0],getVertex14()[1],getVertex14()[2]);
    vertexlabelRoot.add( vertexLabel14 );
            
            

	function getVertex15(){
		return [-0.10988673676227483,0.094546109739312031,-0.014589803345788771,];
	}
	const sphereMaterial15 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere15 = new THREE.Mesh( sphereGeometry, sphereMaterial15 );
	vertexRoot.add(sphere15);
	sphere15.position.set(getVertex15()[0],getVertex15()[1],getVertex15()[2]);

    const lableDiv15 = document.createElement( 'div' );
    lableDiv15.className = 'label';
    lableDiv15.textContent = '15';
    lableDiv15.style.marginTop = '-1em';

    const vertexLabel15 = new CSS2DObject( lableDiv15 );
    vertexLabel15.position.set(getVertex15()[0],getVertex15()[1],getVertex15()[2]);
    vertexlabelRoot.add( vertexLabel15 );
            
            

	function getVertex16(){
		return [0.044902797600000002,0.027751455099999999,-0.085410196499999994,];
	}
	const sphereMaterial16 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere16 = new THREE.Mesh( sphereGeometry, sphereMaterial16 );
	vertexRoot.add(sphere16);
	sphere16.position.set(getVertex16()[0],getVertex16()[1],getVertex16()[2]);

    const lableDiv16 = document.createElement( 'div' );
    lableDiv16.className = 'label';
    lableDiv16.textContent = '16';
    lableDiv16.style.marginTop = '-1em';

    const vertexLabel16 = new CSS2DObject( lableDiv16 );
    vertexLabel16.position.set(getVertex16()[0],getVertex16()[1],getVertex16()[2]);
    vertexlabelRoot.add( vertexLabel16 );
            
            

	function getVertex17(){
		return [-0.42532540400000002,-0.262865556,-0.80901699400000004,];
	}
	const sphereMaterial17 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere17 = new THREE.Mesh( sphereGeometry, sphereMaterial17 );
	vertexRoot.add(sphere17);
	sphere17.position.set(getVertex17()[0],getVertex17()[1],getVertex17()[2]);

    const lableDiv17 = document.createElement( 'div' );
    lableDiv17.className = 'label';
    lableDiv17.textContent = '17';
    lableDiv17.style.marginTop = '-1em';

    const vertexLabel17 = new CSS2DObject( lableDiv17 );
    vertexLabel17.position.set(getVertex17()[0],getVertex17()[1],getVertex17()[2]);
    vertexlabelRoot.add( vertexLabel17 );
            
            

	function getVertex18(){
		return [-0.035421768636917095,-0.12229756485481702,-0.070820393160411541,];
	}
	const sphereMaterial18 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere18 = new THREE.Mesh( sphereGeometry, sphereMaterial18 );
	vertexRoot.add(sphere18);
	sphere18.position.set(getVertex18()[0],getVertex18()[1],getVertex18()[2]);

    const lableDiv18 = document.createElement( 'div' );
    lableDiv18.className = 'label';
    lableDiv18.textContent = '18';
    lableDiv18.style.marginTop = '-1em';

    const vertexLabel18 = new CSS2DObject( lableDiv18 );
    vertexLabel18.position.set(getVertex18()[0],getVertex18()[1],getVertex18()[2]);
    vertexlabelRoot.add( vertexLabel18 );
            
            

	function getVertex19(){
		return [-0.10988673677495864,-0.067913738242542182,-0.067376207793667486,];
	}
	const sphereMaterial19 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere19 = new THREE.Mesh( sphereGeometry, sphereMaterial19 );
	vertexRoot.add(sphere19);
	sphere19.position.set(getVertex19()[0],getVertex19()[1],getVertex19()[2]);

    const lableDiv19 = document.createElement( 'div' );
    lableDiv19.className = 'label';
    lableDiv19.textContent = '19';
    lableDiv19.style.marginTop = '-1em';

    const vertexLabel19 = new CSS2DObject( lableDiv19 );
    vertexLabel19.position.set(getVertex19()[0],getVertex19()[1],getVertex19()[2]);
    vertexlabelRoot.add( vertexLabel19 );
            
            

	function getVertex20(){
		return [-0.12522736385654409,0.02301094063083842,-0.07082039315948313,];
	}
	const sphereMaterial20 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere20 = new THREE.Mesh( sphereGeometry, sphereMaterial20 );
	vertexRoot.add(sphere20);
	sphere20.position.set(getVertex20()[0],getVertex20()[1],getVertex20()[2]);

    const lableDiv20 = document.createElement( 'div' );
    lableDiv20.className = 'label';
    lableDiv20.textContent = '20';
    lableDiv20.style.marginTop = '-1em';

    const vertexLabel20 = new CSS2DObject( lableDiv20 );
    vertexLabel20.position.set(getVertex20()[0],getVertex20()[1],getVertex20()[2]);
    vertexlabelRoot.add( vertexLabel20 );
            
            

	function getVertex21(){
		return [-0.42532540400000002,-0.85065080849999997,0.,];
	}
	const sphereMaterial21 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere21 = new THREE.Mesh( sphereGeometry, sphereMaterial21 );
	vertexRoot.add(sphere21);
	sphere21.position.set(getVertex21()[0],getVertex21()[1],getVertex21()[2]);

    const lableDiv21 = document.createElement( 'div' );
    lableDiv21.className = 'label';
    lableDiv21.textContent = '21';
    lableDiv21.style.marginTop = '-1em';

    const vertexLabel21 = new CSS2DObject( lableDiv21 );
    vertexLabel21.position.set(getVertex21()[0],getVertex21()[1],getVertex21()[2]);
    vertexlabelRoot.add( vertexLabel21 );
            
            

	function getVertex22(){
		return [-0.95105651599999996,0.,0.,];
	}
	const sphereMaterial22 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere22 = new THREE.Mesh( sphereGeometry, sphereMaterial22 );
	vertexRoot.add(sphere22);
	sphere22.position.set(getVertex22()[0],getVertex22()[1],getVertex22()[2]);

    const lableDiv22 = document.createElement( 'div' );
    lableDiv22.className = 'label';
    lableDiv22.textContent = '22';
    lableDiv22.style.marginTop = '-1em';

    const vertexLabel22 = new CSS2DObject( lableDiv22 );
    vertexLabel22.position.set(getVertex22()[0],getVertex22()[1],getVertex22()[2]);
    vertexlabelRoot.add( vertexLabel22 );
            
            

	function getVertex23(){
		return [0.15194522573557648,0.05639505893132235,0.06136807718159009,];
	}
	const sphereMaterial23 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere23 = new THREE.Mesh( sphereGeometry, sphereMaterial23 );
	vertexRoot.add(sphere23);
	sphere23.position.set(getVertex23()[0],getVertex23()[1],getVertex23()[2]);

    const lableDiv23 = document.createElement( 'div' );
    lableDiv23.className = 'label';
    lableDiv23.textContent = '23';
    lableDiv23.style.marginTop = '-1em';

    const vertexLabel23 = new CSS2DObject( lableDiv23 );
    vertexLabel23.position.set(getVertex23()[0],getVertex23()[1],getVertex23()[2]);
    vertexlabelRoot.add( vertexLabel23 );
            
            

	function getVertex24(){
		return [0.051374773540542575,0.15962874834571811,0.0644678440128061,];
	}
	const sphereMaterial24 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere24 = new THREE.Mesh( sphereGeometry, sphereMaterial24 );
	vertexRoot.add(sphere24);
	sphere24.position.set(getVertex24()[0],getVertex24()[1],getVertex24()[2]);

    const lableDiv24 = document.createElement( 'div' );
    lableDiv24.className = 'label';
    lableDiv24.textContent = '24';
    lableDiv24.style.marginTop = '-1em';

    const vertexLabel24 = new CSS2DObject( lableDiv24 );
    vertexLabel24.position.set(getVertex24()[0],getVertex24()[1],getVertex24()[2]);
    vertexlabelRoot.add( vertexLabel24 );
            
            

	function getVertex25(){
		return [-0.0051189847495436017,0.17243941926201567,0.016499633421526383,];
	}
	const sphereMaterial25 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere25 = new THREE.Mesh( sphereGeometry, sphereMaterial25 );
	vertexRoot.add(sphere25);
	sphere25.position.set(getVertex25()[0],getVertex25()[1],getVertex25()[2]);

    const lableDiv25 = document.createElement( 'div' );
    lableDiv25.className = 'label';
    lableDiv25.textContent = '25';
    lableDiv25.style.marginTop = '-1em';

    const vertexLabel25 = new CSS2DObject( lableDiv25 );
    vertexLabel25.position.set(getVertex25()[0],getVertex25()[1],getVertex25()[2]);
    vertexlabelRoot.add( vertexLabel25 );
            
            

	function getVertex26(){
		return [-0.11839324485420148,0.12561592502812169,0.015410196636810683,];
	}
	const sphereMaterial26 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere26 = new THREE.Mesh( sphereGeometry, sphereMaterial26 );
	vertexRoot.add(sphere26);
	sphere26.position.set(getVertex26()[0],getVertex26()[1],getVertex26()[2]);

    const lableDiv26 = document.createElement( 'div' );
    lableDiv26.className = 'label';
    lableDiv26.textContent = '26';
    lableDiv26.style.marginTop = '-1em';

    const vertexLabel26 = new CSS2DObject( lableDiv26 );
    vertexLabel26.position.set(getVertex26()[0],getVertex26()[1],getVertex26()[2]);
    vertexlabelRoot.add( vertexLabel26 );
            
            

	function getVertex27(){
		return [-0.13574198610357255,0.062147794139137284,-0.088008863665099094,];
	}
	const sphereMaterial27 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere27 = new THREE.Mesh( sphereGeometry, sphereMaterial27 );
	vertexRoot.add(sphere27);
	sphere27.position.set(getVertex27()[0],getVertex27()[1],getVertex27()[2]);

    const lableDiv27 = document.createElement( 'div' );
    lableDiv27.className = 'label';
    lableDiv27.textContent = '27';
    lableDiv27.style.marginTop = '-1em';

    const vertexLabel27 = new CSS2DObject( lableDiv27 );
    vertexLabel27.position.set(getVertex27()[0],getVertex27()[1],getVertex27()[2]);
    vertexlabelRoot.add( vertexLabel27 );
            
            

	function getVertex28(){
		return [-0.15194522573557651,-0.056395058931322357,-0.061368077181590173,];
	}
	const sphereMaterial28 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere28 = new THREE.Mesh( sphereGeometry, sphereMaterial28 );
	vertexRoot.add(sphere28);
	sphere28.position.set(getVertex28()[0],getVertex28()[1],getVertex28()[2]);

    const lableDiv28 = document.createElement( 'div' );
    lableDiv28.className = 'label';
    lableDiv28.textContent = '28';
    lableDiv28.style.marginTop = '-1em';

    const vertexLabel28 = new CSS2DObject( lableDiv28 );
    vertexLabel28.position.set(getVertex28()[0],getVertex28()[1],getVertex28()[2]);
    vertexlabelRoot.add( vertexLabel28 );
            
            

	function getVertex29(){
		return [-0.051374773540542526,-0.15962874834571802,-0.064467844012806114,];
	}
	const sphereMaterial29 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere29 = new THREE.Mesh( sphereGeometry, sphereMaterial29 );
	vertexRoot.add(sphere29);
	sphere29.position.set(getVertex29()[0],getVertex29()[1],getVertex29()[2]);

    const lableDiv29 = document.createElement( 'div' );
    lableDiv29.className = 'label';
    lableDiv29.textContent = '29';
    lableDiv29.style.marginTop = '-1em';

    const vertexLabel29 = new CSS2DObject( lableDiv29 );
    vertexLabel29.position.set(getVertex29()[0],getVertex29()[1],getVertex29()[2]);
    vertexlabelRoot.add( vertexLabel29 );
            
            

	function getVertex30(){
		return [0.058640198826405317,-0.16564804543185419,-0.037401332854553659,];
	}
	const sphereMaterial30 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere30 = new THREE.Mesh( sphereGeometry, sphereMaterial30 );
	vertexRoot.add(sphere30);
	sphere30.position.set(getVertex30()[0],getVertex30()[1],getVertex30()[2]);

    const lableDiv30 = document.createElement( 'div' );
    lableDiv30.className = 'label';
    lableDiv30.textContent = '30';
    lableDiv30.style.marginTop = '-1em';

    const vertexLabel30 = new CSS2DObject( lableDiv30 );
    vertexLabel30.position.set(getVertex30()[0],getVertex30()[1],getVertex30()[2]);
    vertexlabelRoot.add( vertexLabel30 );
            
            

	function getVertex31(){
		return [0.12642570147887455,-0.12065159381692281,0.041671842659184027,];
	}
	const sphereMaterial31 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere31 = new THREE.Mesh( sphereGeometry, sphereMaterial31 );
	vertexRoot.add(sphere31);
	sphere31.position.set(getVertex31()[0],getVertex31()[1],getVertex31()[2]);

    const lableDiv31 = document.createElement( 'div' );
    lableDiv31.className = 'label';
    lableDiv31.textContent = '31';
    lableDiv31.style.marginTop = '-1em';

    const vertexLabel31 = new CSS2DObject( lableDiv31 );
    vertexLabel31.position.set(getVertex31()[0],getVertex31()[1],getVertex31()[2]);
    vertexlabelRoot.add( vertexLabel31 );
            
            

	function getVertex32(){
		return [0.16575179010963761,-0.017314159655627472,0.067107164233218206,];
	}
	const sphereMaterial32 = new THREE.MeshBasicMaterial( { color: 0xF58137 } );
	const sphere32 = new THREE.Mesh( sphereGeometry, sphereMaterial32 );
	vertexRoot.add(sphere32);
	sphere32.position.set(getVertex32()[0],getVertex32()[1],getVertex32()[2]);

    const lableDiv32 = document.createElement( 'div' );
    lableDiv32.className = 'label';
    lableDiv32.textContent = '32';
    lableDiv32.style.marginTop = '-1em';

    const vertexLabel32 = new CSS2DObject( lableDiv32 );
    vertexLabel32.position.set(getVertex32()[0],getVertex32()[1],getVertex32()[2]);
    vertexlabelRoot.add( vertexLabel32 );
            
            	// generate the rings for the incircles 

	var inradius1 = calulateInradius(getVertex1(), getVertex2(), getVertex3());
	var incenter1 = calulateIncenter(getVertex1(), getVertex2(), getVertex3());
	var ringGeometry1 = new THREE.RingGeometry((inradius1 - 0.005),inradius1, 32);
	const ringMaterial1 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh1 = new THREE.Mesh(ringGeometry1, ringMaterial1);

	function setCircleRotation1(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.42532540400000002,0.85065080849999997,0.],[0.42532540400000002,0.262865556,0.80901699400000004]);

        ringMesh1.position.setX(incenter[0]);
        ringMesh1.position.setY(incenter[1]);
        ringMesh1.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex2(), getVertex3());
        var relRadius = inradius/inradius1;

        ringMesh1.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A1 = new THREE.Vector3(0.95105651599999996,0.,0.);
        const B1 = new THREE.Vector3(0.42532540400000002,0.85065080849999997,0.);
        const C1 = new THREE.Vector3(0.42532540400000002,0.262865556,0.80901699400000004);

        const normalVec1 = new THREE.Vector3();
        normalVec1.crossVectors(B1.sub(A1), C1.sub(A1));
        normalVec1.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal1 = new THREE.Vector3(0,0,1);

        const quaternionRotation1 = new THREE.Quaternion();
        quaternionRotation1.setFromUnitVectors(initialNormal1, normalVec1);

        ringMesh1.setRotationFromQuaternion(quaternionRotation1);

        return quaternionRotation1;
    }

    ringRoot.add(ringMesh1);
            
	var inradius2 = calulateInradius(getVertex1(), getVertex2(), getVertex23());
	var incenter2 = calulateIncenter(getVertex1(), getVertex2(), getVertex23());
	var ringGeometry2 = new THREE.RingGeometry((inradius2 - 0.005),inradius2, 32);
	const ringMaterial2 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh2 = new THREE.Mesh(ringGeometry2, ringMaterial2);

	function setCircleRotation2(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.42532540400000002,0.85065080849999997,0.],[0.15194522573557648,0.05639505893132235,0.06136807718159009]);

        ringMesh2.position.setX(incenter[0]);
        ringMesh2.position.setY(incenter[1]);
        ringMesh2.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex2(), getVertex23());
        var relRadius = inradius/inradius2;

        ringMesh2.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A2 = new THREE.Vector3(0.95105651599999996,0.,0.);
        const B2 = new THREE.Vector3(0.42532540400000002,0.85065080849999997,0.);
        const C2 = new THREE.Vector3(0.15194522573557648,0.05639505893132235,0.06136807718159009);

        const normalVec2 = new THREE.Vector3();
        normalVec2.crossVectors(B2.sub(A2), C2.sub(A2));
        normalVec2.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal2 = new THREE.Vector3(0,0,1);

        const quaternionRotation2 = new THREE.Quaternion();
        quaternionRotation2.setFromUnitVectors(initialNormal2, normalVec2);

        ringMesh2.setRotationFromQuaternion(quaternionRotation2);

        return quaternionRotation2;
    }

    ringRoot.add(ringMesh2);
            
	var inradius3 = calulateInradius(getVertex1(), getVertex3(), getVertex8());
	var incenter3 = calulateIncenter(getVertex1(), getVertex3(), getVertex8());
	var ringGeometry3 = new THREE.RingGeometry((inradius3 - 0.005),inradius3, 32);
	const ringMaterial3 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh3 = new THREE.Mesh(ringGeometry3, ringMaterial3);

	function setCircleRotation3(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.42532540400000002,0.262865556,0.80901699400000004],[0.42532540400000002,-0.68819096040000005,0.49999999979999998]);

        ringMesh3.position.setX(incenter[0]);
        ringMesh3.position.setY(incenter[1]);
        ringMesh3.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex3(), getVertex8());
        var relRadius = inradius/inradius3;

        ringMesh3.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A3 = new THREE.Vector3(0.95105651599999996,0.,0.);
        const B3 = new THREE.Vector3(0.42532540400000002,0.262865556,0.80901699400000004);
        const C3 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,0.49999999979999998);

        const normalVec3 = new THREE.Vector3();
        normalVec3.crossVectors(B3.sub(A3), C3.sub(A3));
        normalVec3.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal3 = new THREE.Vector3(0,0,1);

        const quaternionRotation3 = new THREE.Quaternion();
        quaternionRotation3.setFromUnitVectors(initialNormal3, normalVec3);

        ringMesh3.setRotationFromQuaternion(quaternionRotation3);

        return quaternionRotation3;
    }

    ringRoot.add(ringMesh3);
            
	var inradius4 = calulateInradius(getVertex1(), getVertex23(), getVertex32());
	var incenter4 = calulateIncenter(getVertex1(), getVertex23(), getVertex32());
	var ringGeometry4 = new THREE.RingGeometry((inradius4 - 0.005),inradius4, 32);
	const ringMaterial4 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh4 = new THREE.Mesh(ringGeometry4, ringMaterial4);

	function setCircleRotation4(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.15194522573557648,0.05639505893132235,0.06136807718159009],[0.16575179010963761,-0.017314159655627472,0.067107164233218206]);

        ringMesh4.position.setX(incenter[0]);
        ringMesh4.position.setY(incenter[1]);
        ringMesh4.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex23(), getVertex32());
        var relRadius = inradius/inradius4;

        ringMesh4.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A4 = new THREE.Vector3(0.95105651599999996,0.,0.);
        const B4 = new THREE.Vector3(0.15194522573557648,0.05639505893132235,0.06136807718159009);
        const C4 = new THREE.Vector3(0.16575179010963761,-0.017314159655627472,0.067107164233218206);

        const normalVec4 = new THREE.Vector3();
        normalVec4.crossVectors(B4.sub(A4), C4.sub(A4));
        normalVec4.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal4 = new THREE.Vector3(0,0,1);

        const quaternionRotation4 = new THREE.Quaternion();
        quaternionRotation4.setFromUnitVectors(initialNormal4, normalVec4);

        ringMesh4.setRotationFromQuaternion(quaternionRotation4);

        return quaternionRotation4;
    }

    ringRoot.add(ringMesh4);
            
	var inradius5 = calulateInradius(getVertex1(), getVertex10(), getVertex32());
	var incenter5 = calulateIncenter(getVertex1(), getVertex10(), getVertex32());
	var ringGeometry5 = new THREE.RingGeometry((inradius5 - 0.005),inradius5, 32);
	const ringMaterial5 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh5 = new THREE.Mesh(ringGeometry5, ringMaterial5);

	function setCircleRotation5(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.10988673676227484,-0.094546109739312101,0.014589803345788743],[0.16575179010963761,-0.017314159655627472,0.067107164233218206]);

        ringMesh5.position.setX(incenter[0]);
        ringMesh5.position.setY(incenter[1]);
        ringMesh5.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex10(), getVertex32());
        var relRadius = inradius/inradius5;

        ringMesh5.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A5 = new THREE.Vector3(0.95105651599999996,0.,0.);
        const B5 = new THREE.Vector3(0.10988673676227484,-0.094546109739312101,0.014589803345788743);
        const C5 = new THREE.Vector3(0.16575179010963761,-0.017314159655627472,0.067107164233218206);

        const normalVec5 = new THREE.Vector3();
        normalVec5.crossVectors(B5.sub(A5), C5.sub(A5));
        normalVec5.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal5 = new THREE.Vector3(0,0,1);

        const quaternionRotation5 = new THREE.Quaternion();
        quaternionRotation5.setFromUnitVectors(initialNormal5, normalVec5);

        ringMesh5.setRotationFromQuaternion(quaternionRotation5);

        return quaternionRotation5;
    }

    ringRoot.add(ringMesh5);
            
	var inradius6 = calulateInradius(getVertex1(), getVertex8(), getVertex9());
	var incenter6 = calulateIncenter(getVertex1(), getVertex8(), getVertex9());
	var ringGeometry6 = new THREE.RingGeometry((inradius6 - 0.005),inradius6, 32);
	const ringMaterial6 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh6 = new THREE.Mesh(ringGeometry6, ringMaterial6);

	function setCircleRotation6(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.42532540400000002,-0.68819096040000005,0.49999999979999998],[0.42532540400000002,-0.68819096040000005,-0.49999999979999998]);

        ringMesh6.position.setX(incenter[0]);
        ringMesh6.position.setY(incenter[1]);
        ringMesh6.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex8(), getVertex9());
        var relRadius = inradius/inradius6;

        ringMesh6.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A6 = new THREE.Vector3(0.95105651599999996,0.,0.);
        const B6 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,0.49999999979999998);
        const C6 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,-0.49999999979999998);

        const normalVec6 = new THREE.Vector3();
        normalVec6.crossVectors(B6.sub(A6), C6.sub(A6));
        normalVec6.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal6 = new THREE.Vector3(0,0,1);

        const quaternionRotation6 = new THREE.Quaternion();
        quaternionRotation6.setFromUnitVectors(initialNormal6, normalVec6);

        ringMesh6.setRotationFromQuaternion(quaternionRotation6);

        return quaternionRotation6;
    }

    ringRoot.add(ringMesh6);
            
	var inradius7 = calulateInradius(getVertex1(), getVertex9(), getVertex10());
	var incenter7 = calulateIncenter(getVertex1(), getVertex9(), getVertex10());
	var ringGeometry7 = new THREE.RingGeometry((inradius7 - 0.005),inradius7, 32);
	const ringMaterial7 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh7 = new THREE.Mesh(ringGeometry7, ringMaterial7);

	function setCircleRotation7(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.42532540400000002,-0.68819096040000005,-0.49999999979999998],[0.10988673676227484,-0.094546109739312101,0.014589803345788743]);

        ringMesh7.position.setX(incenter[0]);
        ringMesh7.position.setY(incenter[1]);
        ringMesh7.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex1(), getVertex9(), getVertex10());
        var relRadius = inradius/inradius7;

        ringMesh7.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A7 = new THREE.Vector3(0.95105651599999996,0.,0.);
        const B7 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,-0.49999999979999998);
        const C7 = new THREE.Vector3(0.10988673676227484,-0.094546109739312101,0.014589803345788743);

        const normalVec7 = new THREE.Vector3();
        normalVec7.crossVectors(B7.sub(A7), C7.sub(A7));
        normalVec7.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal7 = new THREE.Vector3(0,0,1);

        const quaternionRotation7 = new THREE.Quaternion();
        quaternionRotation7.setFromUnitVectors(initialNormal7, normalVec7);

        ringMesh7.setRotationFromQuaternion(quaternionRotation7);

        return quaternionRotation7;
    }

    ringRoot.add(ringMesh7);
            
	var inradius8 = calulateInradius(getVertex2(), getVertex3(), getVertex12());
	var incenter8 = calulateIncenter(getVertex2(), getVertex3(), getVertex12());
	var ringGeometry8 = new THREE.RingGeometry((inradius8 - 0.005),inradius8, 32);
	const ringMaterial8 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh8 = new THREE.Mesh(ringGeometry8, ringMaterial8);

	function setCircleRotation8(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,0.85065080849999997,0.],[ 0.42532540400000002,0.262865556,0.80901699400000004],[-0.42532540400000002,0.68819096040000005,0.49999999979999998]);

        ringMesh8.position.setX(incenter[0]);
        ringMesh8.position.setY(incenter[1]);
        ringMesh8.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex2(), getVertex3(), getVertex12());
        var relRadius = inradius/inradius8;

        ringMesh8.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A8 = new THREE.Vector3(0.42532540400000002,0.85065080849999997,0.);
        const B8 = new THREE.Vector3(0.42532540400000002,0.262865556,0.80901699400000004);
        const C8 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,0.49999999979999998);

        const normalVec8 = new THREE.Vector3();
        normalVec8.crossVectors(B8.sub(A8), C8.sub(A8));
        normalVec8.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal8 = new THREE.Vector3(0,0,1);

        const quaternionRotation8 = new THREE.Quaternion();
        quaternionRotation8.setFromUnitVectors(initialNormal8, normalVec8);

        ringMesh8.setRotationFromQuaternion(quaternionRotation8);

        return quaternionRotation8;
    }

    ringRoot.add(ringMesh8);
            
	var inradius9 = calulateInradius(getVertex2(), getVertex23(), getVertex24());
	var incenter9 = calulateIncenter(getVertex2(), getVertex23(), getVertex24());
	var ringGeometry9 = new THREE.RingGeometry((inradius9 - 0.005),inradius9, 32);
	const ringMaterial9 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh9 = new THREE.Mesh(ringGeometry9, ringMaterial9);

	function setCircleRotation9(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,0.85065080849999997,0.],[ 0.15194522573557648,0.05639505893132235,0.06136807718159009],[0.051374773540542575,0.15962874834571811,0.0644678440128061]);

        ringMesh9.position.setX(incenter[0]);
        ringMesh9.position.setY(incenter[1]);
        ringMesh9.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex2(), getVertex23(), getVertex24());
        var relRadius = inradius/inradius9;

        ringMesh9.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A9 = new THREE.Vector3(0.42532540400000002,0.85065080849999997,0.);
        const B9 = new THREE.Vector3(0.15194522573557648,0.05639505893132235,0.06136807718159009);
        const C9 = new THREE.Vector3(0.051374773540542575,0.15962874834571811,0.0644678440128061);

        const normalVec9 = new THREE.Vector3();
        normalVec9.crossVectors(B9.sub(A9), C9.sub(A9));
        normalVec9.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal9 = new THREE.Vector3(0,0,1);

        const quaternionRotation9 = new THREE.Quaternion();
        quaternionRotation9.setFromUnitVectors(initialNormal9, normalVec9);

        ringMesh9.setRotationFromQuaternion(quaternionRotation9);

        return quaternionRotation9;
    }

    ringRoot.add(ringMesh9);
            
	var inradius10 = calulateInradius(getVertex2(), getVertex24(), getVertex25());
	var incenter10 = calulateIncenter(getVertex2(), getVertex24(), getVertex25());
	var ringGeometry10 = new THREE.RingGeometry((inradius10 - 0.005),inradius10, 32);
	const ringMaterial10 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh10 = new THREE.Mesh(ringGeometry10, ringMaterial10);

	function setCircleRotation10(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,0.85065080849999997,0.],[ 0.051374773540542575,0.15962874834571811,0.0644678440128061],[-0.0051189847495436017,0.17243941926201567,0.016499633421526383]);

        ringMesh10.position.setX(incenter[0]);
        ringMesh10.position.setY(incenter[1]);
        ringMesh10.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex2(), getVertex24(), getVertex25());
        var relRadius = inradius/inradius10;

        ringMesh10.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A10 = new THREE.Vector3(0.42532540400000002,0.85065080849999997,0.);
        const B10 = new THREE.Vector3(0.051374773540542575,0.15962874834571811,0.0644678440128061);
        const C10 = new THREE.Vector3(-0.0051189847495436017,0.17243941926201567,0.016499633421526383);

        const normalVec10 = new THREE.Vector3();
        normalVec10.crossVectors(B10.sub(A10), C10.sub(A10));
        normalVec10.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal10 = new THREE.Vector3(0,0,1);

        const quaternionRotation10 = new THREE.Quaternion();
        quaternionRotation10.setFromUnitVectors(initialNormal10, normalVec10);

        ringMesh10.setRotationFromQuaternion(quaternionRotation10);

        return quaternionRotation10;
    }

    ringRoot.add(ringMesh10);
            
	var inradius11 = calulateInradius(getVertex2(), getVertex12(), getVertex13());
	var incenter11 = calulateIncenter(getVertex2(), getVertex12(), getVertex13());
	var ringGeometry11 = new THREE.RingGeometry((inradius11 - 0.005),inradius11, 32);
	const ringMaterial11 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh11 = new THREE.Mesh(ringGeometry11, ringMaterial11);

	function setCircleRotation11(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,0.85065080849999997,0.],[ -0.42532540400000002,0.68819096040000005,0.49999999979999998],[-0.42532540400000002,0.68819096040000005,-0.49999999979999998]);

        ringMesh11.position.setX(incenter[0]);
        ringMesh11.position.setY(incenter[1]);
        ringMesh11.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex2(), getVertex12(), getVertex13());
        var relRadius = inradius/inradius11;

        ringMesh11.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A11 = new THREE.Vector3(0.42532540400000002,0.85065080849999997,0.);
        const B11 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,0.49999999979999998);
        const C11 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,-0.49999999979999998);

        const normalVec11 = new THREE.Vector3();
        normalVec11.crossVectors(B11.sub(A11), C11.sub(A11));
        normalVec11.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal11 = new THREE.Vector3(0,0,1);

        const quaternionRotation11 = new THREE.Quaternion();
        quaternionRotation11.setFromUnitVectors(initialNormal11, normalVec11);

        ringMesh11.setRotationFromQuaternion(quaternionRotation11);

        return quaternionRotation11;
    }

    ringRoot.add(ringMesh11);
            
	var inradius12 = calulateInradius(getVertex2(), getVertex13(), getVertex25());
	var incenter12 = calulateIncenter(getVertex2(), getVertex13(), getVertex25());
	var ringGeometry12 = new THREE.RingGeometry((inradius12 - 0.005),inradius12, 32);
	const ringMaterial12 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh12 = new THREE.Mesh(ringGeometry12, ringMaterial12);

	function setCircleRotation12(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,0.85065080849999997,0.],[ -0.42532540400000002,0.68819096040000005,-0.49999999979999998],[-0.0051189847495436017,0.17243941926201567,0.016499633421526383]);

        ringMesh12.position.setX(incenter[0]);
        ringMesh12.position.setY(incenter[1]);
        ringMesh12.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex2(), getVertex13(), getVertex25());
        var relRadius = inradius/inradius12;

        ringMesh12.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A12 = new THREE.Vector3(0.42532540400000002,0.85065080849999997,0.);
        const B12 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,-0.49999999979999998);
        const C12 = new THREE.Vector3(-0.0051189847495436017,0.17243941926201567,0.016499633421526383);

        const normalVec12 = new THREE.Vector3();
        normalVec12.crossVectors(B12.sub(A12), C12.sub(A12));
        normalVec12.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal12 = new THREE.Vector3(0,0,1);

        const quaternionRotation12 = new THREE.Quaternion();
        quaternionRotation12.setFromUnitVectors(initialNormal12, normalVec12);

        ringMesh12.setRotationFromQuaternion(quaternionRotation12);

        return quaternionRotation12;
    }

    ringRoot.add(ringMesh12);
            
	var inradius13 = calulateInradius(getVertex3(), getVertex5(), getVertex6());
	var incenter13 = calulateIncenter(getVertex3(), getVertex5(), getVertex6());
	var ringGeometry13 = new THREE.RingGeometry((inradius13 - 0.005),inradius13, 32);
	const ringMaterial13 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh13 = new THREE.Mesh(ringGeometry13, ringMaterial13);

	function setCircleRotation13(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,0.262865556,0.80901699400000004],[ 0.10988673677495858,0.067913738242542168,0.067376207793667389],[0.12522736385654409,-0.02301094063083842,0.070820393159483144]);

        ringMesh13.position.setX(incenter[0]);
        ringMesh13.position.setY(incenter[1]);
        ringMesh13.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex5(), getVertex6());
        var relRadius = inradius/inradius13;

        ringMesh13.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A13 = new THREE.Vector3(0.42532540400000002,0.262865556,0.80901699400000004);
        const B13 = new THREE.Vector3(0.10988673677495858,0.067913738242542168,0.067376207793667389);
        const C13 = new THREE.Vector3(0.12522736385654409,-0.02301094063083842,0.070820393159483144);

        const normalVec13 = new THREE.Vector3();
        normalVec13.crossVectors(B13.sub(A13), C13.sub(A13));
        normalVec13.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal13 = new THREE.Vector3(0,0,1);

        const quaternionRotation13 = new THREE.Quaternion();
        quaternionRotation13.setFromUnitVectors(initialNormal13, normalVec13);

        ringMesh13.setRotationFromQuaternion(quaternionRotation13);

        return quaternionRotation13;
    }

    ringRoot.add(ringMesh13);
            
	var inradius14 = calulateInradius(getVertex3(), getVertex5(), getVertex7());
	var incenter14 = calulateIncenter(getVertex3(), getVertex5(), getVertex7());
	var ringGeometry14 = new THREE.RingGeometry((inradius14 - 0.005),inradius14, 32);
	const ringMaterial14 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh14 = new THREE.Mesh(ringGeometry14, ringMaterial14);

	function setCircleRotation14(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,0.262865556,0.80901699400000004],[ 0.10988673677495858,0.067913738242542168,0.067376207793667389],[0.03542176863691715,0.12229756485481713,0.070820393160411527]);

        ringMesh14.position.setX(incenter[0]);
        ringMesh14.position.setY(incenter[1]);
        ringMesh14.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex5(), getVertex7());
        var relRadius = inradius/inradius14;

        ringMesh14.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A14 = new THREE.Vector3(0.42532540400000002,0.262865556,0.80901699400000004);
        const B14 = new THREE.Vector3(0.10988673677495858,0.067913738242542168,0.067376207793667389);
        const C14 = new THREE.Vector3(0.03542176863691715,0.12229756485481713,0.070820393160411527);

        const normalVec14 = new THREE.Vector3();
        normalVec14.crossVectors(B14.sub(A14), C14.sub(A14));
        normalVec14.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal14 = new THREE.Vector3(0,0,1);

        const quaternionRotation14 = new THREE.Quaternion();
        quaternionRotation14.setFromUnitVectors(initialNormal14, normalVec14);

        ringMesh14.setRotationFromQuaternion(quaternionRotation14);

        return quaternionRotation14;
    }

    ringRoot.add(ringMesh14);
            
	var inradius15 = calulateInradius(getVertex3(), getVertex6(), getVertex8());
	var incenter15 = calulateIncenter(getVertex3(), getVertex6(), getVertex8());
	var ringGeometry15 = new THREE.RingGeometry((inradius15 - 0.005),inradius15, 32);
	const ringMaterial15 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh15 = new THREE.Mesh(ringGeometry15, ringMaterial15);

	function setCircleRotation15(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,0.262865556,0.80901699400000004],[ 0.12522736385654409,-0.02301094063083842,0.070820393159483144],[0.42532540400000002,-0.68819096040000005,0.49999999979999998]);

        ringMesh15.position.setX(incenter[0]);
        ringMesh15.position.setY(incenter[1]);
        ringMesh15.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex6(), getVertex8());
        var relRadius = inradius/inradius15;

        ringMesh15.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A15 = new THREE.Vector3(0.42532540400000002,0.262865556,0.80901699400000004);
        const B15 = new THREE.Vector3(0.12522736385654409,-0.02301094063083842,0.070820393159483144);
        const C15 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,0.49999999979999998);

        const normalVec15 = new THREE.Vector3();
        normalVec15.crossVectors(B15.sub(A15), C15.sub(A15));
        normalVec15.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal15 = new THREE.Vector3(0,0,1);

        const quaternionRotation15 = new THREE.Quaternion();
        quaternionRotation15.setFromUnitVectors(initialNormal15, normalVec15);

        ringMesh15.setRotationFromQuaternion(quaternionRotation15);

        return quaternionRotation15;
    }

    ringRoot.add(ringMesh15);
            
	var inradius16 = calulateInradius(getVertex3(), getVertex7(), getVertex12());
	var incenter16 = calulateIncenter(getVertex3(), getVertex7(), getVertex12());
	var ringGeometry16 = new THREE.RingGeometry((inradius16 - 0.005),inradius16, 32);
	const ringMaterial16 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh16 = new THREE.Mesh(ringGeometry16, ringMaterial16);

	function setCircleRotation16(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,0.262865556,0.80901699400000004],[ 0.03542176863691715,0.12229756485481713,0.070820393160411527],[-0.42532540400000002,0.68819096040000005,0.49999999979999998]);

        ringMesh16.position.setX(incenter[0]);
        ringMesh16.position.setY(incenter[1]);
        ringMesh16.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex3(), getVertex7(), getVertex12());
        var relRadius = inradius/inradius16;

        ringMesh16.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A16 = new THREE.Vector3(0.42532540400000002,0.262865556,0.80901699400000004);
        const B16 = new THREE.Vector3(0.03542176863691715,0.12229756485481713,0.070820393160411527);
        const C16 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,0.49999999979999998);

        const normalVec16 = new THREE.Vector3();
        normalVec16.crossVectors(B16.sub(A16), C16.sub(A16));
        normalVec16.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal16 = new THREE.Vector3(0,0,1);

        const quaternionRotation16 = new THREE.Quaternion();
        quaternionRotation16.setFromUnitVectors(initialNormal16, normalVec16);

        ringMesh16.setRotationFromQuaternion(quaternionRotation16);

        return quaternionRotation16;
    }

    ringRoot.add(ringMesh16);
            
	var inradius17 = calulateInradius(getVertex4(), getVertex6(), getVertex7());
	var incenter17 = calulateIncenter(getVertex4(), getVertex6(), getVertex7());
	var ringGeometry17 = new THREE.RingGeometry((inradius17 - 0.005),inradius17, 32);
	const ringMaterial17 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh17 = new THREE.Mesh(ringGeometry17, ringMaterial17);

	function setCircleRotation17(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.044902797600000002,-0.027751455099999999,0.085410196499999994],[ 0.12522736385654409,-0.02301094063083842,0.070820393159483144],[0.03542176863691715,0.12229756485481713,0.070820393160411527]);

        ringMesh17.position.setX(incenter[0]);
        ringMesh17.position.setY(incenter[1]);
        ringMesh17.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex6(), getVertex7());
        var relRadius = inradius/inradius17;

        ringMesh17.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A17 = new THREE.Vector3(-0.044902797600000002,-0.027751455099999999,0.085410196499999994);
        const B17 = new THREE.Vector3(0.12522736385654409,-0.02301094063083842,0.070820393159483144);
        const C17 = new THREE.Vector3(0.03542176863691715,0.12229756485481713,0.070820393160411527);

        const normalVec17 = new THREE.Vector3();
        normalVec17.crossVectors(B17.sub(A17), C17.sub(A17));
        normalVec17.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal17 = new THREE.Vector3(0,0,1);

        const quaternionRotation17 = new THREE.Quaternion();
        quaternionRotation17.setFromUnitVectors(initialNormal17, normalVec17);

        ringMesh17.setRotationFromQuaternion(quaternionRotation17);

        return quaternionRotation17;
    }

    ringRoot.add(ringMesh17);
            
	var inradius18 = calulateInradius(getVertex4(), getVertex6(), getVertex11());
	var incenter18 = calulateIncenter(getVertex4(), getVertex6(), getVertex11());
	var ringGeometry18 = new THREE.RingGeometry((inradius18 - 0.005),inradius18, 32);
	const ringMaterial18 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh18 = new THREE.Mesh(ringGeometry18, ringMaterial18);

	function setCircleRotation18(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.044902797600000002,-0.027751455099999999,0.085410196499999994],[ 0.12522736385654409,-0.02301094063083842,0.070820393159483144],[0.035421768653657301,-0.14056799102765397,-0.014589803368714557]);

        ringMesh18.position.setX(incenter[0]);
        ringMesh18.position.setY(incenter[1]);
        ringMesh18.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex6(), getVertex11());
        var relRadius = inradius/inradius18;

        ringMesh18.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A18 = new THREE.Vector3(-0.044902797600000002,-0.027751455099999999,0.085410196499999994);
        const B18 = new THREE.Vector3(0.12522736385654409,-0.02301094063083842,0.070820393159483144);
        const C18 = new THREE.Vector3(0.035421768653657301,-0.14056799102765397,-0.014589803368714557);

        const normalVec18 = new THREE.Vector3();
        normalVec18.crossVectors(B18.sub(A18), C18.sub(A18));
        normalVec18.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal18 = new THREE.Vector3(0,0,1);

        const quaternionRotation18 = new THREE.Quaternion();
        quaternionRotation18.setFromUnitVectors(initialNormal18, normalVec18);

        ringMesh18.setRotationFromQuaternion(quaternionRotation18);

        return quaternionRotation18;
    }

    ringRoot.add(ringMesh18);
            
	var inradius19 = calulateInradius(getVertex4(), getVertex7(), getVertex26());
	var incenter19 = calulateIncenter(getVertex4(), getVertex7(), getVertex26());
	var ringGeometry19 = new THREE.RingGeometry((inradius19 - 0.005),inradius19, 32);
	const ringMaterial19 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh19 = new THREE.Mesh(ringGeometry19, ringMaterial19);

	function setCircleRotation19(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.044902797600000002,-0.027751455099999999,0.085410196499999994],[ 0.03542176863691715,0.12229756485481713,0.070820393160411527],[-0.11839324485420148,0.12561592502812169,0.015410196636810683]);

        ringMesh19.position.setX(incenter[0]);
        ringMesh19.position.setY(incenter[1]);
        ringMesh19.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex7(), getVertex26());
        var relRadius = inradius/inradius19;

        ringMesh19.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A19 = new THREE.Vector3(-0.044902797600000002,-0.027751455099999999,0.085410196499999994);
        const B19 = new THREE.Vector3(0.03542176863691715,0.12229756485481713,0.070820393160411527);
        const C19 = new THREE.Vector3(-0.11839324485420148,0.12561592502812169,0.015410196636810683);

        const normalVec19 = new THREE.Vector3();
        normalVec19.crossVectors(B19.sub(A19), C19.sub(A19));
        normalVec19.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal19 = new THREE.Vector3(0,0,1);

        const quaternionRotation19 = new THREE.Quaternion();
        quaternionRotation19.setFromUnitVectors(initialNormal19, normalVec19);

        ringMesh19.setRotationFromQuaternion(quaternionRotation19);

        return quaternionRotation19;
    }

    ringRoot.add(ringMesh19);
            
	var inradius20 = calulateInradius(getVertex4(), getVertex11(), getVertex28());
	var incenter20 = calulateIncenter(getVertex4(), getVertex11(), getVertex28());
	var ringGeometry20 = new THREE.RingGeometry((inradius20 - 0.005),inradius20, 32);
	const ringMaterial20 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh20 = new THREE.Mesh(ringGeometry20, ringMaterial20);

	function setCircleRotation20(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.044902797600000002,-0.027751455099999999,0.085410196499999994],[ 0.035421768653657301,-0.14056799102765397,-0.014589803368714557],[-0.15194522573557651,-0.056395058931322357,-0.061368077181590173]);

        ringMesh20.position.setX(incenter[0]);
        ringMesh20.position.setY(incenter[1]);
        ringMesh20.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex11(), getVertex28());
        var relRadius = inradius/inradius20;

        ringMesh20.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A20 = new THREE.Vector3(-0.044902797600000002,-0.027751455099999999,0.085410196499999994);
        const B20 = new THREE.Vector3(0.035421768653657301,-0.14056799102765397,-0.014589803368714557);
        const C20 = new THREE.Vector3(-0.15194522573557651,-0.056395058931322357,-0.061368077181590173);

        const normalVec20 = new THREE.Vector3();
        normalVec20.crossVectors(B20.sub(A20), C20.sub(A20));
        normalVec20.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal20 = new THREE.Vector3(0,0,1);

        const quaternionRotation20 = new THREE.Quaternion();
        quaternionRotation20.setFromUnitVectors(initialNormal20, normalVec20);

        ringMesh20.setRotationFromQuaternion(quaternionRotation20);

        return quaternionRotation20;
    }

    ringRoot.add(ringMesh20);
            
	var inradius21 = calulateInradius(getVertex4(), getVertex26(), getVertex28());
	var incenter21 = calulateIncenter(getVertex4(), getVertex26(), getVertex28());
	var ringGeometry21 = new THREE.RingGeometry((inradius21 - 0.005),inradius21, 32);
	const ringMaterial21 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh21 = new THREE.Mesh(ringGeometry21, ringMaterial21);

	function setCircleRotation21(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.044902797600000002,-0.027751455099999999,0.085410196499999994],[ -0.11839324485420148,0.12561592502812169,0.015410196636810683],[-0.15194522573557651,-0.056395058931322357,-0.061368077181590173]);

        ringMesh21.position.setX(incenter[0]);
        ringMesh21.position.setY(incenter[1]);
        ringMesh21.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex4(), getVertex26(), getVertex28());
        var relRadius = inradius/inradius21;

        ringMesh21.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A21 = new THREE.Vector3(-0.044902797600000002,-0.027751455099999999,0.085410196499999994);
        const B21 = new THREE.Vector3(-0.11839324485420148,0.12561592502812169,0.015410196636810683);
        const C21 = new THREE.Vector3(-0.15194522573557651,-0.056395058931322357,-0.061368077181590173);

        const normalVec21 = new THREE.Vector3();
        normalVec21.crossVectors(B21.sub(A21), C21.sub(A21));
        normalVec21.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal21 = new THREE.Vector3(0,0,1);

        const quaternionRotation21 = new THREE.Quaternion();
        quaternionRotation21.setFromUnitVectors(initialNormal21, normalVec21);

        ringMesh21.setRotationFromQuaternion(quaternionRotation21);

        return quaternionRotation21;
    }

    ringRoot.add(ringMesh21);
            
	var inradius22 = calulateInradius(getVertex5(), getVertex6(), getVertex7());
	var incenter22 = calulateIncenter(getVertex5(), getVertex6(), getVertex7());
	var ringGeometry22 = new THREE.RingGeometry((inradius22 - 0.005),inradius22, 32);
	const ringMaterial22 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh22 = new THREE.Mesh(ringGeometry22, ringMaterial22);

	function setCircleRotation22(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.10988673677495858,0.067913738242542168,0.067376207793667389],[ 0.12522736385654409,-0.02301094063083842,0.070820393159483144],[0.03542176863691715,0.12229756485481713,0.070820393160411527]);

        ringMesh22.position.setX(incenter[0]);
        ringMesh22.position.setY(incenter[1]);
        ringMesh22.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex5(), getVertex6(), getVertex7());
        var relRadius = inradius/inradius22;

        ringMesh22.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A22 = new THREE.Vector3(0.10988673677495858,0.067913738242542168,0.067376207793667389);
        const B22 = new THREE.Vector3(0.12522736385654409,-0.02301094063083842,0.070820393159483144);
        const C22 = new THREE.Vector3(0.03542176863691715,0.12229756485481713,0.070820393160411527);

        const normalVec22 = new THREE.Vector3();
        normalVec22.crossVectors(B22.sub(A22), C22.sub(A22));
        normalVec22.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal22 = new THREE.Vector3(0,0,1);

        const quaternionRotation22 = new THREE.Quaternion();
        quaternionRotation22.setFromUnitVectors(initialNormal22, normalVec22);

        ringMesh22.setRotationFromQuaternion(quaternionRotation22);

        return quaternionRotation22;
    }

    ringRoot.add(ringMesh22);
            
	var inradius23 = calulateInradius(getVertex10(), getVertex23(), getVertex32());
	var incenter23 = calulateIncenter(getVertex10(), getVertex23(), getVertex32());
	var ringGeometry23 = new THREE.RingGeometry((inradius23 - 0.005),inradius23, 32);
	const ringMaterial23 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh23 = new THREE.Mesh(ringGeometry23, ringMaterial23);

	function setCircleRotation23(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.10988673676227484,-0.094546109739312101,0.014589803345788743],[ 0.15194522573557648,0.05639505893132235,0.06136807718159009],[0.16575179010963761,-0.017314159655627472,0.067107164233218206]);

        ringMesh23.position.setX(incenter[0]);
        ringMesh23.position.setY(incenter[1]);
        ringMesh23.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex10(), getVertex23(), getVertex32());
        var relRadius = inradius/inradius23;

        ringMesh23.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A23 = new THREE.Vector3(0.10988673676227484,-0.094546109739312101,0.014589803345788743);
        const B23 = new THREE.Vector3(0.15194522573557648,0.05639505893132235,0.06136807718159009);
        const C23 = new THREE.Vector3(0.16575179010963761,-0.017314159655627472,0.067107164233218206);

        const normalVec23 = new THREE.Vector3();
        normalVec23.crossVectors(B23.sub(A23), C23.sub(A23));
        normalVec23.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal23 = new THREE.Vector3(0,0,1);

        const quaternionRotation23 = new THREE.Quaternion();
        quaternionRotation23.setFromUnitVectors(initialNormal23, normalVec23);

        ringMesh23.setRotationFromQuaternion(quaternionRotation23);

        return quaternionRotation23;
    }

    ringRoot.add(ringMesh23);
            
	var inradius24 = calulateInradius(getVertex23(), getVertex24(), getVertex25());
	var incenter24 = calulateIncenter(getVertex23(), getVertex24(), getVertex25());
	var ringGeometry24 = new THREE.RingGeometry((inradius24 - 0.005),inradius24, 32);
	const ringMaterial24 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh24 = new THREE.Mesh(ringGeometry24, ringMaterial24);

	function setCircleRotation24(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.15194522573557648,0.05639505893132235,0.06136807718159009],[ 0.051374773540542575,0.15962874834571811,0.0644678440128061],[-0.0051189847495436017,0.17243941926201567,0.016499633421526383]);

        ringMesh24.position.setX(incenter[0]);
        ringMesh24.position.setY(incenter[1]);
        ringMesh24.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex23(), getVertex24(), getVertex25());
        var relRadius = inradius/inradius24;

        ringMesh24.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A24 = new THREE.Vector3(0.15194522573557648,0.05639505893132235,0.06136807718159009);
        const B24 = new THREE.Vector3(0.051374773540542575,0.15962874834571811,0.0644678440128061);
        const C24 = new THREE.Vector3(-0.0051189847495436017,0.17243941926201567,0.016499633421526383);

        const normalVec24 = new THREE.Vector3();
        normalVec24.crossVectors(B24.sub(A24), C24.sub(A24));
        normalVec24.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal24 = new THREE.Vector3(0,0,1);

        const quaternionRotation24 = new THREE.Quaternion();
        quaternionRotation24.setFromUnitVectors(initialNormal24, normalVec24);

        ringMesh24.setRotationFromQuaternion(quaternionRotation24);

        return quaternionRotation24;
    }

    ringRoot.add(ringMesh24);
            
	var inradius25 = calulateInradius(getVertex10(), getVertex16(), getVertex23());
	var incenter25 = calulateIncenter(getVertex10(), getVertex16(), getVertex23());
	var ringGeometry25 = new THREE.RingGeometry((inradius25 - 0.005),inradius25, 32);
	const ringMaterial25 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh25 = new THREE.Mesh(ringGeometry25, ringMaterial25);

	function setCircleRotation25(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.10988673676227484,-0.094546109739312101,0.014589803345788743],[ 0.044902797600000002,0.027751455099999999,-0.085410196499999994],[0.15194522573557648,0.05639505893132235,0.06136807718159009]);

        ringMesh25.position.setX(incenter[0]);
        ringMesh25.position.setY(incenter[1]);
        ringMesh25.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex10(), getVertex16(), getVertex23());
        var relRadius = inradius/inradius25;

        ringMesh25.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A25 = new THREE.Vector3(0.10988673676227484,-0.094546109739312101,0.014589803345788743);
        const B25 = new THREE.Vector3(0.044902797600000002,0.027751455099999999,-0.085410196499999994);
        const C25 = new THREE.Vector3(0.15194522573557648,0.05639505893132235,0.06136807718159009);

        const normalVec25 = new THREE.Vector3();
        normalVec25.crossVectors(B25.sub(A25), C25.sub(A25));
        normalVec25.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal25 = new THREE.Vector3(0,0,1);

        const quaternionRotation25 = new THREE.Quaternion();
        quaternionRotation25.setFromUnitVectors(initialNormal25, normalVec25);

        ringMesh25.setRotationFromQuaternion(quaternionRotation25);

        return quaternionRotation25;
    }

    ringRoot.add(ringMesh25);
            
	var inradius26 = calulateInradius(getVertex16(), getVertex23(), getVertex25());
	var incenter26 = calulateIncenter(getVertex16(), getVertex23(), getVertex25());
	var ringGeometry26 = new THREE.RingGeometry((inradius26 - 0.005),inradius26, 32);
	const ringMaterial26 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh26 = new THREE.Mesh(ringGeometry26, ringMaterial26);

	function setCircleRotation26(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.044902797600000002,0.027751455099999999,-0.085410196499999994],[ 0.15194522573557648,0.05639505893132235,0.06136807718159009],[-0.0051189847495436017,0.17243941926201567,0.016499633421526383]);

        ringMesh26.position.setX(incenter[0]);
        ringMesh26.position.setY(incenter[1]);
        ringMesh26.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex16(), getVertex23(), getVertex25());
        var relRadius = inradius/inradius26;

        ringMesh26.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A26 = new THREE.Vector3(0.044902797600000002,0.027751455099999999,-0.085410196499999994);
        const B26 = new THREE.Vector3(0.15194522573557648,0.05639505893132235,0.06136807718159009);
        const C26 = new THREE.Vector3(-0.0051189847495436017,0.17243941926201567,0.016499633421526383);

        const normalVec26 = new THREE.Vector3();
        normalVec26.crossVectors(B26.sub(A26), C26.sub(A26));
        normalVec26.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal26 = new THREE.Vector3(0,0,1);

        const quaternionRotation26 = new THREE.Quaternion();
        quaternionRotation26.setFromUnitVectors(initialNormal26, normalVec26);

        ringMesh26.setRotationFromQuaternion(quaternionRotation26);

        return quaternionRotation26;
    }

    ringRoot.add(ringMesh26);
            
	var inradius27 = calulateInradius(getVertex6(), getVertex8(), getVertex31());
	var incenter27 = calulateIncenter(getVertex6(), getVertex8(), getVertex31());
	var ringGeometry27 = new THREE.RingGeometry((inradius27 - 0.005),inradius27, 32);
	const ringMaterial27 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh27 = new THREE.Mesh(ringGeometry27, ringMaterial27);

	function setCircleRotation27(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.12522736385654409,-0.02301094063083842,0.070820393159483144],[ 0.42532540400000002,-0.68819096040000005,0.49999999979999998],[0.12642570147887455,-0.12065159381692281,0.041671842659184027]);

        ringMesh27.position.setX(incenter[0]);
        ringMesh27.position.setY(incenter[1]);
        ringMesh27.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex6(), getVertex8(), getVertex31());
        var relRadius = inradius/inradius27;

        ringMesh27.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A27 = new THREE.Vector3(0.12522736385654409,-0.02301094063083842,0.070820393159483144);
        const B27 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,0.49999999979999998);
        const C27 = new THREE.Vector3(0.12642570147887455,-0.12065159381692281,0.041671842659184027);

        const normalVec27 = new THREE.Vector3();
        normalVec27.crossVectors(B27.sub(A27), C27.sub(A27));
        normalVec27.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal27 = new THREE.Vector3(0,0,1);

        const quaternionRotation27 = new THREE.Quaternion();
        quaternionRotation27.setFromUnitVectors(initialNormal27, normalVec27);

        ringMesh27.setRotationFromQuaternion(quaternionRotation27);

        return quaternionRotation27;
    }

    ringRoot.add(ringMesh27);
            
	var inradius28 = calulateInradius(getVertex6(), getVertex11(), getVertex31());
	var incenter28 = calulateIncenter(getVertex6(), getVertex11(), getVertex31());
	var ringGeometry28 = new THREE.RingGeometry((inradius28 - 0.005),inradius28, 32);
	const ringMaterial28 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh28 = new THREE.Mesh(ringGeometry28, ringMaterial28);

	function setCircleRotation28(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.12522736385654409,-0.02301094063083842,0.070820393159483144],[ 0.035421768653657301,-0.14056799102765397,-0.014589803368714557],[0.12642570147887455,-0.12065159381692281,0.041671842659184027]);

        ringMesh28.position.setX(incenter[0]);
        ringMesh28.position.setY(incenter[1]);
        ringMesh28.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex6(), getVertex11(), getVertex31());
        var relRadius = inradius/inradius28;

        ringMesh28.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A28 = new THREE.Vector3(0.12522736385654409,-0.02301094063083842,0.070820393159483144);
        const B28 = new THREE.Vector3(0.035421768653657301,-0.14056799102765397,-0.014589803368714557);
        const C28 = new THREE.Vector3(0.12642570147887455,-0.12065159381692281,0.041671842659184027);

        const normalVec28 = new THREE.Vector3();
        normalVec28.crossVectors(B28.sub(A28), C28.sub(A28));
        normalVec28.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal28 = new THREE.Vector3(0,0,1);

        const quaternionRotation28 = new THREE.Quaternion();
        quaternionRotation28.setFromUnitVectors(initialNormal28, normalVec28);

        ringMesh28.setRotationFromQuaternion(quaternionRotation28);

        return quaternionRotation28;
    }

    ringRoot.add(ringMesh28);
            
	var inradius29 = calulateInradius(getVertex7(), getVertex12(), getVertex14());
	var incenter29 = calulateIncenter(getVertex7(), getVertex12(), getVertex14());
	var ringGeometry29 = new THREE.RingGeometry((inradius29 - 0.005),inradius29, 32);
	const ringMaterial29 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh29 = new THREE.Mesh(ringGeometry29, ringMaterial29);

	function setCircleRotation29(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.03542176863691715,0.12229756485481713,0.070820393160411527],[ -0.42532540400000002,0.68819096040000005,0.49999999979999998],[-0.03542176865365726,0.14056799102765394,0.01458980336871446]);

        ringMesh29.position.setX(incenter[0]);
        ringMesh29.position.setY(incenter[1]);
        ringMesh29.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex12(), getVertex14());
        var relRadius = inradius/inradius29;

        ringMesh29.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A29 = new THREE.Vector3(0.03542176863691715,0.12229756485481713,0.070820393160411527);
        const B29 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,0.49999999979999998);
        const C29 = new THREE.Vector3(-0.03542176865365726,0.14056799102765394,0.01458980336871446);

        const normalVec29 = new THREE.Vector3();
        normalVec29.crossVectors(B29.sub(A29), C29.sub(A29));
        normalVec29.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal29 = new THREE.Vector3(0,0,1);

        const quaternionRotation29 = new THREE.Quaternion();
        quaternionRotation29.setFromUnitVectors(initialNormal29, normalVec29);

        ringMesh29.setRotationFromQuaternion(quaternionRotation29);

        return quaternionRotation29;
    }

    ringRoot.add(ringMesh29);
            
	var inradius30 = calulateInradius(getVertex7(), getVertex14(), getVertex26());
	var incenter30 = calulateIncenter(getVertex7(), getVertex14(), getVertex26());
	var ringGeometry30 = new THREE.RingGeometry((inradius30 - 0.005),inradius30, 32);
	const ringMaterial30 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh30 = new THREE.Mesh(ringGeometry30, ringMaterial30);

	function setCircleRotation30(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.03542176863691715,0.12229756485481713,0.070820393160411527],[ -0.03542176865365726,0.14056799102765394,0.01458980336871446],[-0.11839324485420148,0.12561592502812169,0.015410196636810683]);

        ringMesh30.position.setX(incenter[0]);
        ringMesh30.position.setY(incenter[1]);
        ringMesh30.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex7(), getVertex14(), getVertex26());
        var relRadius = inradius/inradius30;

        ringMesh30.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A30 = new THREE.Vector3(0.03542176863691715,0.12229756485481713,0.070820393160411527);
        const B30 = new THREE.Vector3(-0.03542176865365726,0.14056799102765394,0.01458980336871446);
        const C30 = new THREE.Vector3(-0.11839324485420148,0.12561592502812169,0.015410196636810683);

        const normalVec30 = new THREE.Vector3();
        normalVec30.crossVectors(B30.sub(A30), C30.sub(A30));
        normalVec30.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal30 = new THREE.Vector3(0,0,1);

        const quaternionRotation30 = new THREE.Quaternion();
        quaternionRotation30.setFromUnitVectors(initialNormal30, normalVec30);

        ringMesh30.setRotationFromQuaternion(quaternionRotation30);

        return quaternionRotation30;
    }

    ringRoot.add(ringMesh30);
            
	var inradius31 = calulateInradius(getVertex8(), getVertex9(), getVertex21());
	var incenter31 = calulateIncenter(getVertex8(), getVertex9(), getVertex21());
	var ringGeometry31 = new THREE.RingGeometry((inradius31 - 0.005),inradius31, 32);
	const ringMaterial31 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh31 = new THREE.Mesh(ringGeometry31, ringMaterial31);

	function setCircleRotation31(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,0.49999999979999998],[ 0.42532540400000002,-0.68819096040000005,-0.49999999979999998],[-0.42532540400000002,-0.85065080849999997,0.]);

        ringMesh31.position.setX(incenter[0]);
        ringMesh31.position.setY(incenter[1]);
        ringMesh31.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex9(), getVertex21());
        var relRadius = inradius/inradius31;

        ringMesh31.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A31 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,0.49999999979999998);
        const B31 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,-0.49999999979999998);
        const C31 = new THREE.Vector3(-0.42532540400000002,-0.85065080849999997,0.);

        const normalVec31 = new THREE.Vector3();
        normalVec31.crossVectors(B31.sub(A31), C31.sub(A31));
        normalVec31.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal31 = new THREE.Vector3(0,0,1);

        const quaternionRotation31 = new THREE.Quaternion();
        quaternionRotation31.setFromUnitVectors(initialNormal31, normalVec31);

        ringMesh31.setRotationFromQuaternion(quaternionRotation31);

        return quaternionRotation31;
    }

    ringRoot.add(ringMesh31);
            
	var inradius32 = calulateInradius(getVertex8(), getVertex11(), getVertex31());
	var incenter32 = calulateIncenter(getVertex8(), getVertex11(), getVertex31());
	var ringGeometry32 = new THREE.RingGeometry((inradius32 - 0.005),inradius32, 32);
	const ringMaterial32 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh32 = new THREE.Mesh(ringGeometry32, ringMaterial32);

	function setCircleRotation32(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,0.49999999979999998],[ 0.035421768653657301,-0.14056799102765397,-0.014589803368714557],[0.12642570147887455,-0.12065159381692281,0.041671842659184027]);

        ringMesh32.position.setX(incenter[0]);
        ringMesh32.position.setY(incenter[1]);
        ringMesh32.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex11(), getVertex31());
        var relRadius = inradius/inradius32;

        ringMesh32.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A32 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,0.49999999979999998);
        const B32 = new THREE.Vector3(0.035421768653657301,-0.14056799102765397,-0.014589803368714557);
        const C32 = new THREE.Vector3(0.12642570147887455,-0.12065159381692281,0.041671842659184027);

        const normalVec32 = new THREE.Vector3();
        normalVec32.crossVectors(B32.sub(A32), C32.sub(A32));
        normalVec32.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal32 = new THREE.Vector3(0,0,1);

        const quaternionRotation32 = new THREE.Quaternion();
        quaternionRotation32.setFromUnitVectors(initialNormal32, normalVec32);

        ringMesh32.setRotationFromQuaternion(quaternionRotation32);

        return quaternionRotation32;
    }

    ringRoot.add(ringMesh32);
            
	var inradius33 = calulateInradius(getVertex8(), getVertex11(), getVertex21());
	var incenter33 = calulateIncenter(getVertex8(), getVertex11(), getVertex21());
	var ringGeometry33 = new THREE.RingGeometry((inradius33 - 0.005),inradius33, 32);
	const ringMaterial33 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh33 = new THREE.Mesh(ringGeometry33, ringMaterial33);

	function setCircleRotation33(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,0.49999999979999998],[ 0.035421768653657301,-0.14056799102765397,-0.014589803368714557],[-0.42532540400000002,-0.85065080849999997,0.]);

        ringMesh33.position.setX(incenter[0]);
        ringMesh33.position.setY(incenter[1]);
        ringMesh33.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex8(), getVertex11(), getVertex21());
        var relRadius = inradius/inradius33;

        ringMesh33.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A33 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,0.49999999979999998);
        const B33 = new THREE.Vector3(0.035421768653657301,-0.14056799102765397,-0.014589803368714557);
        const C33 = new THREE.Vector3(-0.42532540400000002,-0.85065080849999997,0.);

        const normalVec33 = new THREE.Vector3();
        normalVec33.crossVectors(B33.sub(A33), C33.sub(A33));
        normalVec33.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal33 = new THREE.Vector3(0,0,1);

        const quaternionRotation33 = new THREE.Quaternion();
        quaternionRotation33.setFromUnitVectors(initialNormal33, normalVec33);

        ringMesh33.setRotationFromQuaternion(quaternionRotation33);

        return quaternionRotation33;
    }

    ringRoot.add(ringMesh33);
            
	var inradius34 = calulateInradius(getVertex9(), getVertex10(), getVertex30());
	var incenter34 = calulateIncenter(getVertex9(), getVertex10(), getVertex30());
	var ringGeometry34 = new THREE.RingGeometry((inradius34 - 0.005),inradius34, 32);
	const ringMaterial34 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh34 = new THREE.Mesh(ringGeometry34, ringMaterial34);

	function setCircleRotation34(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,-0.49999999979999998],[ 0.10988673676227484,-0.094546109739312101,0.014589803345788743],[0.058640198826405317,-0.16564804543185419,-0.037401332854553659]);

        ringMesh34.position.setX(incenter[0]);
        ringMesh34.position.setY(incenter[1]);
        ringMesh34.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex9(), getVertex10(), getVertex30());
        var relRadius = inradius/inradius34;

        ringMesh34.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A34 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,-0.49999999979999998);
        const B34 = new THREE.Vector3(0.10988673676227484,-0.094546109739312101,0.014589803345788743);
        const C34 = new THREE.Vector3(0.058640198826405317,-0.16564804543185419,-0.037401332854553659);

        const normalVec34 = new THREE.Vector3();
        normalVec34.crossVectors(B34.sub(A34), C34.sub(A34));
        normalVec34.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal34 = new THREE.Vector3(0,0,1);

        const quaternionRotation34 = new THREE.Quaternion();
        quaternionRotation34.setFromUnitVectors(initialNormal34, normalVec34);

        ringMesh34.setRotationFromQuaternion(quaternionRotation34);

        return quaternionRotation34;
    }

    ringRoot.add(ringMesh34);
            
	var inradius35 = calulateInradius(getVertex9(), getVertex18(), getVertex30());
	var incenter35 = calulateIncenter(getVertex9(), getVertex18(), getVertex30());
	var ringGeometry35 = new THREE.RingGeometry((inradius35 - 0.005),inradius35, 32);
	const ringMaterial35 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh35 = new THREE.Mesh(ringGeometry35, ringMaterial35);

	function setCircleRotation35(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,-0.49999999979999998],[ -0.035421768636917095,-0.12229756485481702,-0.070820393160411541],[0.058640198826405317,-0.16564804543185419,-0.037401332854553659]);

        ringMesh35.position.setX(incenter[0]);
        ringMesh35.position.setY(incenter[1]);
        ringMesh35.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex9(), getVertex18(), getVertex30());
        var relRadius = inradius/inradius35;

        ringMesh35.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A35 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,-0.49999999979999998);
        const B35 = new THREE.Vector3(-0.035421768636917095,-0.12229756485481702,-0.070820393160411541);
        const C35 = new THREE.Vector3(0.058640198826405317,-0.16564804543185419,-0.037401332854553659);

        const normalVec35 = new THREE.Vector3();
        normalVec35.crossVectors(B35.sub(A35), C35.sub(A35));
        normalVec35.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal35 = new THREE.Vector3(0,0,1);

        const quaternionRotation35 = new THREE.Quaternion();
        quaternionRotation35.setFromUnitVectors(initialNormal35, normalVec35);

        ringMesh35.setRotationFromQuaternion(quaternionRotation35);

        return quaternionRotation35;
    }

    ringRoot.add(ringMesh35);
            
	var inradius36 = calulateInradius(getVertex9(), getVertex17(), getVertex18());
	var incenter36 = calulateIncenter(getVertex9(), getVertex17(), getVertex18());
	var ringGeometry36 = new THREE.RingGeometry((inradius36 - 0.005),inradius36, 32);
	const ringMaterial36 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh36 = new THREE.Mesh(ringGeometry36, ringMaterial36);

	function setCircleRotation36(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,-0.49999999979999998],[ -0.42532540400000002,-0.262865556,-0.80901699400000004],[-0.035421768636917095,-0.12229756485481702,-0.070820393160411541]);

        ringMesh36.position.setX(incenter[0]);
        ringMesh36.position.setY(incenter[1]);
        ringMesh36.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex9(), getVertex17(), getVertex18());
        var relRadius = inradius/inradius36;

        ringMesh36.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A36 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,-0.49999999979999998);
        const B36 = new THREE.Vector3(-0.42532540400000002,-0.262865556,-0.80901699400000004);
        const C36 = new THREE.Vector3(-0.035421768636917095,-0.12229756485481702,-0.070820393160411541);

        const normalVec36 = new THREE.Vector3();
        normalVec36.crossVectors(B36.sub(A36), C36.sub(A36));
        normalVec36.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal36 = new THREE.Vector3(0,0,1);

        const quaternionRotation36 = new THREE.Quaternion();
        quaternionRotation36.setFromUnitVectors(initialNormal36, normalVec36);

        ringMesh36.setRotationFromQuaternion(quaternionRotation36);

        return quaternionRotation36;
    }

    ringRoot.add(ringMesh36);
            
	var inradius37 = calulateInradius(getVertex9(), getVertex17(), getVertex21());
	var incenter37 = calulateIncenter(getVertex9(), getVertex17(), getVertex21());
	var ringGeometry37 = new THREE.RingGeometry((inradius37 - 0.005),inradius37, 32);
	const ringMaterial37 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh37 = new THREE.Mesh(ringGeometry37, ringMaterial37);

	function setCircleRotation37(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,-0.49999999979999998],[ -0.42532540400000002,-0.262865556,-0.80901699400000004],[-0.42532540400000002,-0.85065080849999997,0.]);

        ringMesh37.position.setX(incenter[0]);
        ringMesh37.position.setY(incenter[1]);
        ringMesh37.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex9(), getVertex17(), getVertex21());
        var relRadius = inradius/inradius37;

        ringMesh37.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A37 = new THREE.Vector3(0.42532540400000002,-0.68819096040000005,-0.49999999979999998);
        const B37 = new THREE.Vector3(-0.42532540400000002,-0.262865556,-0.80901699400000004);
        const C37 = new THREE.Vector3(-0.42532540400000002,-0.85065080849999997,0.);

        const normalVec37 = new THREE.Vector3();
        normalVec37.crossVectors(B37.sub(A37), C37.sub(A37));
        normalVec37.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal37 = new THREE.Vector3(0,0,1);

        const quaternionRotation37 = new THREE.Quaternion();
        quaternionRotation37.setFromUnitVectors(initialNormal37, normalVec37);

        ringMesh37.setRotationFromQuaternion(quaternionRotation37);

        return quaternionRotation37;
    }

    ringRoot.add(ringMesh37);
            
	var inradius38 = calulateInradius(getVertex10(), getVertex18(), getVertex30());
	var incenter38 = calulateIncenter(getVertex10(), getVertex18(), getVertex30());
	var ringGeometry38 = new THREE.RingGeometry((inradius38 - 0.005),inradius38, 32);
	const ringMaterial38 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh38 = new THREE.Mesh(ringGeometry38, ringMaterial38);

	function setCircleRotation38(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.10988673676227484,-0.094546109739312101,0.014589803345788743],[ -0.035421768636917095,-0.12229756485481702,-0.070820393160411541],[0.058640198826405317,-0.16564804543185419,-0.037401332854553659]);

        ringMesh38.position.setX(incenter[0]);
        ringMesh38.position.setY(incenter[1]);
        ringMesh38.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex10(), getVertex18(), getVertex30());
        var relRadius = inradius/inradius38;

        ringMesh38.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A38 = new THREE.Vector3(0.10988673676227484,-0.094546109739312101,0.014589803345788743);
        const B38 = new THREE.Vector3(-0.035421768636917095,-0.12229756485481702,-0.070820393160411541);
        const C38 = new THREE.Vector3(0.058640198826405317,-0.16564804543185419,-0.037401332854553659);

        const normalVec38 = new THREE.Vector3();
        normalVec38.crossVectors(B38.sub(A38), C38.sub(A38));
        normalVec38.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal38 = new THREE.Vector3(0,0,1);

        const quaternionRotation38 = new THREE.Quaternion();
        quaternionRotation38.setFromUnitVectors(initialNormal38, normalVec38);

        ringMesh38.setRotationFromQuaternion(quaternionRotation38);

        return quaternionRotation38;
    }

    ringRoot.add(ringMesh38);
            
	var inradius39 = calulateInradius(getVertex10(), getVertex16(), getVertex18());
	var incenter39 = calulateIncenter(getVertex10(), getVertex16(), getVertex18());
	var ringGeometry39 = new THREE.RingGeometry((inradius39 - 0.005),inradius39, 32);
	const ringMaterial39 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh39 = new THREE.Mesh(ringGeometry39, ringMaterial39);

	function setCircleRotation39(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.10988673676227484,-0.094546109739312101,0.014589803345788743],[ 0.044902797600000002,0.027751455099999999,-0.085410196499999994],[-0.035421768636917095,-0.12229756485481702,-0.070820393160411541]);

        ringMesh39.position.setX(incenter[0]);
        ringMesh39.position.setY(incenter[1]);
        ringMesh39.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex10(), getVertex16(), getVertex18());
        var relRadius = inradius/inradius39;

        ringMesh39.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A39 = new THREE.Vector3(0.10988673676227484,-0.094546109739312101,0.014589803345788743);
        const B39 = new THREE.Vector3(0.044902797600000002,0.027751455099999999,-0.085410196499999994);
        const C39 = new THREE.Vector3(-0.035421768636917095,-0.12229756485481702,-0.070820393160411541);

        const normalVec39 = new THREE.Vector3();
        normalVec39.crossVectors(B39.sub(A39), C39.sub(A39));
        normalVec39.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal39 = new THREE.Vector3(0,0,1);

        const quaternionRotation39 = new THREE.Quaternion();
        quaternionRotation39.setFromUnitVectors(initialNormal39, normalVec39);

        ringMesh39.setRotationFromQuaternion(quaternionRotation39);

        return quaternionRotation39;
    }

    ringRoot.add(ringMesh39);
            
	var inradius40 = calulateInradius(getVertex11(), getVertex28(), getVertex29());
	var incenter40 = calulateIncenter(getVertex11(), getVertex28(), getVertex29());
	var ringGeometry40 = new THREE.RingGeometry((inradius40 - 0.005),inradius40, 32);
	const ringMaterial40 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh40 = new THREE.Mesh(ringGeometry40, ringMaterial40);

	function setCircleRotation40(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.035421768653657301,-0.14056799102765397,-0.014589803368714557],[ -0.15194522573557651,-0.056395058931322357,-0.061368077181590173],[-0.051374773540542526,-0.15962874834571802,-0.064467844012806114]);

        ringMesh40.position.setX(incenter[0]);
        ringMesh40.position.setY(incenter[1]);
        ringMesh40.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex11(), getVertex28(), getVertex29());
        var relRadius = inradius/inradius40;

        ringMesh40.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A40 = new THREE.Vector3(0.035421768653657301,-0.14056799102765397,-0.014589803368714557);
        const B40 = new THREE.Vector3(-0.15194522573557651,-0.056395058931322357,-0.061368077181590173);
        const C40 = new THREE.Vector3(-0.051374773540542526,-0.15962874834571802,-0.064467844012806114);

        const normalVec40 = new THREE.Vector3();
        normalVec40.crossVectors(B40.sub(A40), C40.sub(A40));
        normalVec40.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal40 = new THREE.Vector3(0,0,1);

        const quaternionRotation40 = new THREE.Quaternion();
        quaternionRotation40.setFromUnitVectors(initialNormal40, normalVec40);

        ringMesh40.setRotationFromQuaternion(quaternionRotation40);

        return quaternionRotation40;
    }

    ringRoot.add(ringMesh40);
            
	var inradius41 = calulateInradius(getVertex11(), getVertex21(), getVertex29());
	var incenter41 = calulateIncenter(getVertex11(), getVertex21(), getVertex29());
	var ringGeometry41 = new THREE.RingGeometry((inradius41 - 0.005),inradius41, 32);
	const ringMaterial41 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh41 = new THREE.Mesh(ringGeometry41, ringMaterial41);

	function setCircleRotation41(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.035421768653657301,-0.14056799102765397,-0.014589803368714557],[ -0.42532540400000002,-0.85065080849999997,0.],[-0.051374773540542526,-0.15962874834571802,-0.064467844012806114]);

        ringMesh41.position.setX(incenter[0]);
        ringMesh41.position.setY(incenter[1]);
        ringMesh41.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex11(), getVertex21(), getVertex29());
        var relRadius = inradius/inradius41;

        ringMesh41.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A41 = new THREE.Vector3(0.035421768653657301,-0.14056799102765397,-0.014589803368714557);
        const B41 = new THREE.Vector3(-0.42532540400000002,-0.85065080849999997,0.);
        const C41 = new THREE.Vector3(-0.051374773540542526,-0.15962874834571802,-0.064467844012806114);

        const normalVec41 = new THREE.Vector3();
        normalVec41.crossVectors(B41.sub(A41), C41.sub(A41));
        normalVec41.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal41 = new THREE.Vector3(0,0,1);

        const quaternionRotation41 = new THREE.Quaternion();
        quaternionRotation41.setFromUnitVectors(initialNormal41, normalVec41);

        ringMesh41.setRotationFromQuaternion(quaternionRotation41);

        return quaternionRotation41;
    }

    ringRoot.add(ringMesh41);
            
	var inradius42 = calulateInradius(getVertex12(), getVertex13(), getVertex22());
	var incenter42 = calulateIncenter(getVertex12(), getVertex13(), getVertex22());
	var ringGeometry42 = new THREE.RingGeometry((inradius42 - 0.005),inradius42, 32);
	const ringMaterial42 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh42 = new THREE.Mesh(ringGeometry42, ringMaterial42);

	function setCircleRotation42(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,0.49999999979999998],[ -0.42532540400000002,0.68819096040000005,-0.49999999979999998],[-0.95105651599999996,0.,0.]);

        ringMesh42.position.setX(incenter[0]);
        ringMesh42.position.setY(incenter[1]);
        ringMesh42.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex12(), getVertex13(), getVertex22());
        var relRadius = inradius/inradius42;

        ringMesh42.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A42 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,0.49999999979999998);
        const B42 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,-0.49999999979999998);
        const C42 = new THREE.Vector3(-0.95105651599999996,0.,0.);

        const normalVec42 = new THREE.Vector3();
        normalVec42.crossVectors(B42.sub(A42), C42.sub(A42));
        normalVec42.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal42 = new THREE.Vector3(0,0,1);

        const quaternionRotation42 = new THREE.Quaternion();
        quaternionRotation42.setFromUnitVectors(initialNormal42, normalVec42);

        ringMesh42.setRotationFromQuaternion(quaternionRotation42);

        return quaternionRotation42;
    }

    ringRoot.add(ringMesh42);
            
	var inradius43 = calulateInradius(getVertex12(), getVertex14(), getVertex26());
	var incenter43 = calulateIncenter(getVertex12(), getVertex14(), getVertex26());
	var ringGeometry43 = new THREE.RingGeometry((inradius43 - 0.005),inradius43, 32);
	const ringMaterial43 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh43 = new THREE.Mesh(ringGeometry43, ringMaterial43);

	function setCircleRotation43(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,0.49999999979999998],[ -0.03542176865365726,0.14056799102765394,0.01458980336871446],[-0.11839324485420148,0.12561592502812169,0.015410196636810683]);

        ringMesh43.position.setX(incenter[0]);
        ringMesh43.position.setY(incenter[1]);
        ringMesh43.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex12(), getVertex14(), getVertex26());
        var relRadius = inradius/inradius43;

        ringMesh43.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A43 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,0.49999999979999998);
        const B43 = new THREE.Vector3(-0.03542176865365726,0.14056799102765394,0.01458980336871446);
        const C43 = new THREE.Vector3(-0.11839324485420148,0.12561592502812169,0.015410196636810683);

        const normalVec43 = new THREE.Vector3();
        normalVec43.crossVectors(B43.sub(A43), C43.sub(A43));
        normalVec43.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal43 = new THREE.Vector3(0,0,1);

        const quaternionRotation43 = new THREE.Quaternion();
        quaternionRotation43.setFromUnitVectors(initialNormal43, normalVec43);

        ringMesh43.setRotationFromQuaternion(quaternionRotation43);

        return quaternionRotation43;
    }

    ringRoot.add(ringMesh43);
            
	var inradius44 = calulateInradius(getVertex12(), getVertex22(), getVertex26());
	var incenter44 = calulateIncenter(getVertex12(), getVertex22(), getVertex26());
	var ringGeometry44 = new THREE.RingGeometry((inradius44 - 0.005),inradius44, 32);
	const ringMaterial44 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh44 = new THREE.Mesh(ringGeometry44, ringMaterial44);

	function setCircleRotation44(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,0.49999999979999998],[ -0.95105651599999996,0.,0.],[-0.11839324485420148,0.12561592502812169,0.015410196636810683]);

        ringMesh44.position.setX(incenter[0]);
        ringMesh44.position.setY(incenter[1]);
        ringMesh44.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex12(), getVertex22(), getVertex26());
        var relRadius = inradius/inradius44;

        ringMesh44.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A44 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,0.49999999979999998);
        const B44 = new THREE.Vector3(-0.95105651599999996,0.,0.);
        const C44 = new THREE.Vector3(-0.11839324485420148,0.12561592502812169,0.015410196636810683);

        const normalVec44 = new THREE.Vector3();
        normalVec44.crossVectors(B44.sub(A44), C44.sub(A44));
        normalVec44.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal44 = new THREE.Vector3(0,0,1);

        const quaternionRotation44 = new THREE.Quaternion();
        quaternionRotation44.setFromUnitVectors(initialNormal44, normalVec44);

        ringMesh44.setRotationFromQuaternion(quaternionRotation44);

        return quaternionRotation44;
    }

    ringRoot.add(ringMesh44);
            
	var inradius45 = calulateInradius(getVertex13(), getVertex15(), getVertex25());
	var incenter45 = calulateIncenter(getVertex13(), getVertex15(), getVertex25());
	var ringGeometry45 = new THREE.RingGeometry((inradius45 - 0.005),inradius45, 32);
	const ringMaterial45 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh45 = new THREE.Mesh(ringGeometry45, ringMaterial45);

	function setCircleRotation45(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,-0.49999999979999998],[ -0.10988673676227483,0.094546109739312031,-0.014589803345788771],[-0.0051189847495436017,0.17243941926201567,0.016499633421526383]);

        ringMesh45.position.setX(incenter[0]);
        ringMesh45.position.setY(incenter[1]);
        ringMesh45.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex13(), getVertex15(), getVertex25());
        var relRadius = inradius/inradius45;

        ringMesh45.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A45 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,-0.49999999979999998);
        const B45 = new THREE.Vector3(-0.10988673676227483,0.094546109739312031,-0.014589803345788771);
        const C45 = new THREE.Vector3(-0.0051189847495436017,0.17243941926201567,0.016499633421526383);

        const normalVec45 = new THREE.Vector3();
        normalVec45.crossVectors(B45.sub(A45), C45.sub(A45));
        normalVec45.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal45 = new THREE.Vector3(0,0,1);

        const quaternionRotation45 = new THREE.Quaternion();
        quaternionRotation45.setFromUnitVectors(initialNormal45, normalVec45);

        ringMesh45.setRotationFromQuaternion(quaternionRotation45);

        return quaternionRotation45;
    }

    ringRoot.add(ringMesh45);
            
	var inradius46 = calulateInradius(getVertex13(), getVertex15(), getVertex27());
	var incenter46 = calulateIncenter(getVertex13(), getVertex15(), getVertex27());
	var ringGeometry46 = new THREE.RingGeometry((inradius46 - 0.005),inradius46, 32);
	const ringMaterial46 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh46 = new THREE.Mesh(ringGeometry46, ringMaterial46);

	function setCircleRotation46(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,-0.49999999979999998],[ -0.10988673676227483,0.094546109739312031,-0.014589803345788771],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);

        ringMesh46.position.setX(incenter[0]);
        ringMesh46.position.setY(incenter[1]);
        ringMesh46.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex13(), getVertex15(), getVertex27());
        var relRadius = inradius/inradius46;

        ringMesh46.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A46 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,-0.49999999979999998);
        const B46 = new THREE.Vector3(-0.10988673676227483,0.094546109739312031,-0.014589803345788771);
        const C46 = new THREE.Vector3(-0.13574198610357255,0.062147794139137284,-0.088008863665099094);

        const normalVec46 = new THREE.Vector3();
        normalVec46.crossVectors(B46.sub(A46), C46.sub(A46));
        normalVec46.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal46 = new THREE.Vector3(0,0,1);

        const quaternionRotation46 = new THREE.Quaternion();
        quaternionRotation46.setFromUnitVectors(initialNormal46, normalVec46);

        ringMesh46.setRotationFromQuaternion(quaternionRotation46);

        return quaternionRotation46;
    }

    ringRoot.add(ringMesh46);
            
	var inradius47 = calulateInradius(getVertex13(), getVertex17(), getVertex27());
	var incenter47 = calulateIncenter(getVertex13(), getVertex17(), getVertex27());
	var ringGeometry47 = new THREE.RingGeometry((inradius47 - 0.005),inradius47, 32);
	const ringMaterial47 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh47 = new THREE.Mesh(ringGeometry47, ringMaterial47);

	function setCircleRotation47(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,-0.49999999979999998],[ -0.42532540400000002,-0.262865556,-0.80901699400000004],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);

        ringMesh47.position.setX(incenter[0]);
        ringMesh47.position.setY(incenter[1]);
        ringMesh47.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex13(), getVertex17(), getVertex27());
        var relRadius = inradius/inradius47;

        ringMesh47.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A47 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,-0.49999999979999998);
        const B47 = new THREE.Vector3(-0.42532540400000002,-0.262865556,-0.80901699400000004);
        const C47 = new THREE.Vector3(-0.13574198610357255,0.062147794139137284,-0.088008863665099094);

        const normalVec47 = new THREE.Vector3();
        normalVec47.crossVectors(B47.sub(A47), C47.sub(A47));
        normalVec47.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal47 = new THREE.Vector3(0,0,1);

        const quaternionRotation47 = new THREE.Quaternion();
        quaternionRotation47.setFromUnitVectors(initialNormal47, normalVec47);

        ringMesh47.setRotationFromQuaternion(quaternionRotation47);

        return quaternionRotation47;
    }

    ringRoot.add(ringMesh47);
            
	var inradius48 = calulateInradius(getVertex13(), getVertex17(), getVertex22());
	var incenter48 = calulateIncenter(getVertex13(), getVertex17(), getVertex22());
	var ringGeometry48 = new THREE.RingGeometry((inradius48 - 0.005),inradius48, 32);
	const ringMaterial48 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh48 = new THREE.Mesh(ringGeometry48, ringMaterial48);

	function setCircleRotation48(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,-0.49999999979999998],[ -0.42532540400000002,-0.262865556,-0.80901699400000004],[-0.95105651599999996,0.,0.]);

        ringMesh48.position.setX(incenter[0]);
        ringMesh48.position.setY(incenter[1]);
        ringMesh48.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex13(), getVertex17(), getVertex22());
        var relRadius = inradius/inradius48;

        ringMesh48.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A48 = new THREE.Vector3(-0.42532540400000002,0.68819096040000005,-0.49999999979999998);
        const B48 = new THREE.Vector3(-0.42532540400000002,-0.262865556,-0.80901699400000004);
        const C48 = new THREE.Vector3(-0.95105651599999996,0.,0.);

        const normalVec48 = new THREE.Vector3();
        normalVec48.crossVectors(B48.sub(A48), C48.sub(A48));
        normalVec48.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal48 = new THREE.Vector3(0,0,1);

        const quaternionRotation48 = new THREE.Quaternion();
        quaternionRotation48.setFromUnitVectors(initialNormal48, normalVec48);

        ringMesh48.setRotationFromQuaternion(quaternionRotation48);

        return quaternionRotation48;
    }

    ringRoot.add(ringMesh48);
            
	var inradius49 = calulateInradius(getVertex15(), getVertex25(), getVertex27());
	var incenter49 = calulateIncenter(getVertex15(), getVertex25(), getVertex27());
	var ringGeometry49 = new THREE.RingGeometry((inradius49 - 0.005),inradius49, 32);
	const ringMaterial49 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh49 = new THREE.Mesh(ringGeometry49, ringMaterial49);

	function setCircleRotation49(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.10988673676227483,0.094546109739312031,-0.014589803345788771],[ -0.0051189847495436017,0.17243941926201567,0.016499633421526383],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);

        ringMesh49.position.setX(incenter[0]);
        ringMesh49.position.setY(incenter[1]);
        ringMesh49.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex15(), getVertex25(), getVertex27());
        var relRadius = inradius/inradius49;

        ringMesh49.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A49 = new THREE.Vector3(-0.10988673676227483,0.094546109739312031,-0.014589803345788771);
        const B49 = new THREE.Vector3(-0.0051189847495436017,0.17243941926201567,0.016499633421526383);
        const C49 = new THREE.Vector3(-0.13574198610357255,0.062147794139137284,-0.088008863665099094);

        const normalVec49 = new THREE.Vector3();
        normalVec49.crossVectors(B49.sub(A49), C49.sub(A49));
        normalVec49.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal49 = new THREE.Vector3(0,0,1);

        const quaternionRotation49 = new THREE.Quaternion();
        quaternionRotation49.setFromUnitVectors(initialNormal49, normalVec49);

        ringMesh49.setRotationFromQuaternion(quaternionRotation49);

        return quaternionRotation49;
    }

    ringRoot.add(ringMesh49);
            
	var inradius50 = calulateInradius(getVertex16(), getVertex25(), getVertex27());
	var incenter50 = calulateIncenter(getVertex16(), getVertex25(), getVertex27());
	var ringGeometry50 = new THREE.RingGeometry((inradius50 - 0.005),inradius50, 32);
	const ringMaterial50 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh50 = new THREE.Mesh(ringGeometry50, ringMaterial50);

	function setCircleRotation50(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.044902797600000002,0.027751455099999999,-0.085410196499999994],[ -0.0051189847495436017,0.17243941926201567,0.016499633421526383],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);

        ringMesh50.position.setX(incenter[0]);
        ringMesh50.position.setY(incenter[1]);
        ringMesh50.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex16(), getVertex25(), getVertex27());
        var relRadius = inradius/inradius50;

        ringMesh50.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A50 = new THREE.Vector3(0.044902797600000002,0.027751455099999999,-0.085410196499999994);
        const B50 = new THREE.Vector3(-0.0051189847495436017,0.17243941926201567,0.016499633421526383);
        const C50 = new THREE.Vector3(-0.13574198610357255,0.062147794139137284,-0.088008863665099094);

        const normalVec50 = new THREE.Vector3();
        normalVec50.crossVectors(B50.sub(A50), C50.sub(A50));
        normalVec50.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal50 = new THREE.Vector3(0,0,1);

        const quaternionRotation50 = new THREE.Quaternion();
        quaternionRotation50.setFromUnitVectors(initialNormal50, normalVec50);

        ringMesh50.setRotationFromQuaternion(quaternionRotation50);

        return quaternionRotation50;
    }

    ringRoot.add(ringMesh50);
            
	var inradius51 = calulateInradius(getVertex20(), getVertex26(), getVertex28());
	var incenter51 = calulateIncenter(getVertex20(), getVertex26(), getVertex28());
	var ringGeometry51 = new THREE.RingGeometry((inradius51 - 0.005),inradius51, 32);
	const ringMaterial51 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh51 = new THREE.Mesh(ringGeometry51, ringMaterial51);

	function setCircleRotation51(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.12522736385654409,0.02301094063083842,-0.07082039315948313],[ -0.11839324485420148,0.12561592502812169,0.015410196636810683],[-0.15194522573557651,-0.056395058931322357,-0.061368077181590173]);

        ringMesh51.position.setX(incenter[0]);
        ringMesh51.position.setY(incenter[1]);
        ringMesh51.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex20(), getVertex26(), getVertex28());
        var relRadius = inradius/inradius51;

        ringMesh51.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A51 = new THREE.Vector3(-0.12522736385654409,0.02301094063083842,-0.07082039315948313);
        const B51 = new THREE.Vector3(-0.11839324485420148,0.12561592502812169,0.015410196636810683);
        const C51 = new THREE.Vector3(-0.15194522573557651,-0.056395058931322357,-0.061368077181590173);

        const normalVec51 = new THREE.Vector3();
        normalVec51.crossVectors(B51.sub(A51), C51.sub(A51));
        normalVec51.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal51 = new THREE.Vector3(0,0,1);

        const quaternionRotation51 = new THREE.Quaternion();
        quaternionRotation51.setFromUnitVectors(initialNormal51, normalVec51);

        ringMesh51.setRotationFromQuaternion(quaternionRotation51);

        return quaternionRotation51;
    }

    ringRoot.add(ringMesh51);
            
	var inradius52 = calulateInradius(getVertex20(), getVertex22(), getVertex26());
	var incenter52 = calulateIncenter(getVertex20(), getVertex22(), getVertex26());
	var ringGeometry52 = new THREE.RingGeometry((inradius52 - 0.005),inradius52, 32);
	const ringMaterial52 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh52 = new THREE.Mesh(ringGeometry52, ringMaterial52);

	function setCircleRotation52(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.12522736385654409,0.02301094063083842,-0.07082039315948313],[ -0.95105651599999996,0.,0.],[-0.11839324485420148,0.12561592502812169,0.015410196636810683]);

        ringMesh52.position.setX(incenter[0]);
        ringMesh52.position.setY(incenter[1]);
        ringMesh52.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex20(), getVertex22(), getVertex26());
        var relRadius = inradius/inradius52;

        ringMesh52.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A52 = new THREE.Vector3(-0.12522736385654409,0.02301094063083842,-0.07082039315948313);
        const B52 = new THREE.Vector3(-0.95105651599999996,0.,0.);
        const C52 = new THREE.Vector3(-0.11839324485420148,0.12561592502812169,0.015410196636810683);

        const normalVec52 = new THREE.Vector3();
        normalVec52.crossVectors(B52.sub(A52), C52.sub(A52));
        normalVec52.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal52 = new THREE.Vector3(0,0,1);

        const quaternionRotation52 = new THREE.Quaternion();
        quaternionRotation52.setFromUnitVectors(initialNormal52, normalVec52);

        ringMesh52.setRotationFromQuaternion(quaternionRotation52);

        return quaternionRotation52;
    }

    ringRoot.add(ringMesh52);
            
	var inradius53 = calulateInradius(getVertex16(), getVertex18(), getVertex27());
	var incenter53 = calulateIncenter(getVertex16(), getVertex18(), getVertex27());
	var ringGeometry53 = new THREE.RingGeometry((inradius53 - 0.005),inradius53, 32);
	const ringMaterial53 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh53 = new THREE.Mesh(ringGeometry53, ringMaterial53);

	function setCircleRotation53(){

        //translate ring to incenter
        var incenter = calulateIncenter([0.044902797600000002,0.027751455099999999,-0.085410196499999994],[ -0.035421768636917095,-0.12229756485481702,-0.070820393160411541],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);

        ringMesh53.position.setX(incenter[0]);
        ringMesh53.position.setY(incenter[1]);
        ringMesh53.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex16(), getVertex18(), getVertex27());
        var relRadius = inradius/inradius53;

        ringMesh53.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A53 = new THREE.Vector3(0.044902797600000002,0.027751455099999999,-0.085410196499999994);
        const B53 = new THREE.Vector3(-0.035421768636917095,-0.12229756485481702,-0.070820393160411541);
        const C53 = new THREE.Vector3(-0.13574198610357255,0.062147794139137284,-0.088008863665099094);

        const normalVec53 = new THREE.Vector3();
        normalVec53.crossVectors(B53.sub(A53), C53.sub(A53));
        normalVec53.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal53 = new THREE.Vector3(0,0,1);

        const quaternionRotation53 = new THREE.Quaternion();
        quaternionRotation53.setFromUnitVectors(initialNormal53, normalVec53);

        ringMesh53.setRotationFromQuaternion(quaternionRotation53);

        return quaternionRotation53;
    }

    ringRoot.add(ringMesh53);
            
	var inradius54 = calulateInradius(getVertex17(), getVertex18(), getVertex19());
	var incenter54 = calulateIncenter(getVertex17(), getVertex18(), getVertex19());
	var ringGeometry54 = new THREE.RingGeometry((inradius54 - 0.005),inradius54, 32);
	const ringMaterial54 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh54 = new THREE.Mesh(ringGeometry54, ringMaterial54);

	function setCircleRotation54(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.42532540400000002,-0.262865556,-0.80901699400000004],[ -0.035421768636917095,-0.12229756485481702,-0.070820393160411541],[-0.10988673677495864,-0.067913738242542182,-0.067376207793667486]);

        ringMesh54.position.setX(incenter[0]);
        ringMesh54.position.setY(incenter[1]);
        ringMesh54.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex17(), getVertex18(), getVertex19());
        var relRadius = inradius/inradius54;

        ringMesh54.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A54 = new THREE.Vector3(-0.42532540400000002,-0.262865556,-0.80901699400000004);
        const B54 = new THREE.Vector3(-0.035421768636917095,-0.12229756485481702,-0.070820393160411541);
        const C54 = new THREE.Vector3(-0.10988673677495864,-0.067913738242542182,-0.067376207793667486);

        const normalVec54 = new THREE.Vector3();
        normalVec54.crossVectors(B54.sub(A54), C54.sub(A54));
        normalVec54.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal54 = new THREE.Vector3(0,0,1);

        const quaternionRotation54 = new THREE.Quaternion();
        quaternionRotation54.setFromUnitVectors(initialNormal54, normalVec54);

        ringMesh54.setRotationFromQuaternion(quaternionRotation54);

        return quaternionRotation54;
    }

    ringRoot.add(ringMesh54);
            
	var inradius55 = calulateInradius(getVertex17(), getVertex19(), getVertex27());
	var incenter55 = calulateIncenter(getVertex17(), getVertex19(), getVertex27());
	var ringGeometry55 = new THREE.RingGeometry((inradius55 - 0.005),inradius55, 32);
	const ringMaterial55 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh55 = new THREE.Mesh(ringGeometry55, ringMaterial55);

	function setCircleRotation55(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.42532540400000002,-0.262865556,-0.80901699400000004],[ -0.10988673677495864,-0.067913738242542182,-0.067376207793667486],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);

        ringMesh55.position.setX(incenter[0]);
        ringMesh55.position.setY(incenter[1]);
        ringMesh55.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex17(), getVertex19(), getVertex27());
        var relRadius = inradius/inradius55;

        ringMesh55.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A55 = new THREE.Vector3(-0.42532540400000002,-0.262865556,-0.80901699400000004);
        const B55 = new THREE.Vector3(-0.10988673677495864,-0.067913738242542182,-0.067376207793667486);
        const C55 = new THREE.Vector3(-0.13574198610357255,0.062147794139137284,-0.088008863665099094);

        const normalVec55 = new THREE.Vector3();
        normalVec55.crossVectors(B55.sub(A55), C55.sub(A55));
        normalVec55.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal55 = new THREE.Vector3(0,0,1);

        const quaternionRotation55 = new THREE.Quaternion();
        quaternionRotation55.setFromUnitVectors(initialNormal55, normalVec55);

        ringMesh55.setRotationFromQuaternion(quaternionRotation55);

        return quaternionRotation55;
    }

    ringRoot.add(ringMesh55);
            
	var inradius56 = calulateInradius(getVertex17(), getVertex21(), getVertex22());
	var incenter56 = calulateIncenter(getVertex17(), getVertex21(), getVertex22());
	var ringGeometry56 = new THREE.RingGeometry((inradius56 - 0.005),inradius56, 32);
	const ringMaterial56 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh56 = new THREE.Mesh(ringGeometry56, ringMaterial56);

	function setCircleRotation56(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.42532540400000002,-0.262865556,-0.80901699400000004],[ -0.42532540400000002,-0.85065080849999997,0.],[-0.95105651599999996,0.,0.]);

        ringMesh56.position.setX(incenter[0]);
        ringMesh56.position.setY(incenter[1]);
        ringMesh56.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex17(), getVertex21(), getVertex22());
        var relRadius = inradius/inradius56;

        ringMesh56.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A56 = new THREE.Vector3(-0.42532540400000002,-0.262865556,-0.80901699400000004);
        const B56 = new THREE.Vector3(-0.42532540400000002,-0.85065080849999997,0.);
        const C56 = new THREE.Vector3(-0.95105651599999996,0.,0.);

        const normalVec56 = new THREE.Vector3();
        normalVec56.crossVectors(B56.sub(A56), C56.sub(A56));
        normalVec56.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal56 = new THREE.Vector3(0,0,1);

        const quaternionRotation56 = new THREE.Quaternion();
        quaternionRotation56.setFromUnitVectors(initialNormal56, normalVec56);

        ringMesh56.setRotationFromQuaternion(quaternionRotation56);

        return quaternionRotation56;
    }

    ringRoot.add(ringMesh56);
            
	var inradius57 = calulateInradius(getVertex18(), getVertex19(), getVertex27());
	var incenter57 = calulateIncenter(getVertex18(), getVertex19(), getVertex27());
	var ringGeometry57 = new THREE.RingGeometry((inradius57 - 0.005),inradius57, 32);
	const ringMaterial57 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh57 = new THREE.Mesh(ringGeometry57, ringMaterial57);

	function setCircleRotation57(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.035421768636917095,-0.12229756485481702,-0.070820393160411541],[ -0.10988673677495864,-0.067913738242542182,-0.067376207793667486],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);

        ringMesh57.position.setX(incenter[0]);
        ringMesh57.position.setY(incenter[1]);
        ringMesh57.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex18(), getVertex19(), getVertex27());
        var relRadius = inradius/inradius57;

        ringMesh57.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A57 = new THREE.Vector3(-0.035421768636917095,-0.12229756485481702,-0.070820393160411541);
        const B57 = new THREE.Vector3(-0.10988673677495864,-0.067913738242542182,-0.067376207793667486);
        const C57 = new THREE.Vector3(-0.13574198610357255,0.062147794139137284,-0.088008863665099094);

        const normalVec57 = new THREE.Vector3();
        normalVec57.crossVectors(B57.sub(A57), C57.sub(A57));
        normalVec57.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal57 = new THREE.Vector3(0,0,1);

        const quaternionRotation57 = new THREE.Quaternion();
        quaternionRotation57.setFromUnitVectors(initialNormal57, normalVec57);

        ringMesh57.setRotationFromQuaternion(quaternionRotation57);

        return quaternionRotation57;
    }

    ringRoot.add(ringMesh57);
            
	var inradius58 = calulateInradius(getVertex21(), getVertex28(), getVertex29());
	var incenter58 = calulateIncenter(getVertex21(), getVertex28(), getVertex29());
	var ringGeometry58 = new THREE.RingGeometry((inradius58 - 0.005),inradius58, 32);
	const ringMaterial58 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh58 = new THREE.Mesh(ringGeometry58, ringMaterial58);

	function setCircleRotation58(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.42532540400000002,-0.85065080849999997,0.],[ -0.15194522573557651,-0.056395058931322357,-0.061368077181590173],[-0.051374773540542526,-0.15962874834571802,-0.064467844012806114]);

        ringMesh58.position.setX(incenter[0]);
        ringMesh58.position.setY(incenter[1]);
        ringMesh58.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex21(), getVertex28(), getVertex29());
        var relRadius = inradius/inradius58;

        ringMesh58.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A58 = new THREE.Vector3(-0.42532540400000002,-0.85065080849999997,0.);
        const B58 = new THREE.Vector3(-0.15194522573557651,-0.056395058931322357,-0.061368077181590173);
        const C58 = new THREE.Vector3(-0.051374773540542526,-0.15962874834571802,-0.064467844012806114);

        const normalVec58 = new THREE.Vector3();
        normalVec58.crossVectors(B58.sub(A58), C58.sub(A58));
        normalVec58.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal58 = new THREE.Vector3(0,0,1);

        const quaternionRotation58 = new THREE.Quaternion();
        quaternionRotation58.setFromUnitVectors(initialNormal58, normalVec58);

        ringMesh58.setRotationFromQuaternion(quaternionRotation58);

        return quaternionRotation58;
    }

    ringRoot.add(ringMesh58);
            
	var inradius59 = calulateInradius(getVertex20(), getVertex22(), getVertex28());
	var incenter59 = calulateIncenter(getVertex20(), getVertex22(), getVertex28());
	var ringGeometry59 = new THREE.RingGeometry((inradius59 - 0.005),inradius59, 32);
	const ringMaterial59 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh59 = new THREE.Mesh(ringGeometry59, ringMaterial59);

	function setCircleRotation59(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.12522736385654409,0.02301094063083842,-0.07082039315948313],[ -0.95105651599999996,0.,0.],[-0.15194522573557651,-0.056395058931322357,-0.061368077181590173]);

        ringMesh59.position.setX(incenter[0]);
        ringMesh59.position.setY(incenter[1]);
        ringMesh59.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex20(), getVertex22(), getVertex28());
        var relRadius = inradius/inradius59;

        ringMesh59.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A59 = new THREE.Vector3(-0.12522736385654409,0.02301094063083842,-0.07082039315948313);
        const B59 = new THREE.Vector3(-0.95105651599999996,0.,0.);
        const C59 = new THREE.Vector3(-0.15194522573557651,-0.056395058931322357,-0.061368077181590173);

        const normalVec59 = new THREE.Vector3();
        normalVec59.crossVectors(B59.sub(A59), C59.sub(A59));
        normalVec59.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal59 = new THREE.Vector3(0,0,1);

        const quaternionRotation59 = new THREE.Quaternion();
        quaternionRotation59.setFromUnitVectors(initialNormal59, normalVec59);

        ringMesh59.setRotationFromQuaternion(quaternionRotation59);

        return quaternionRotation59;
    }

    ringRoot.add(ringMesh59);
            
	var inradius60 = calulateInradius(getVertex21(), getVertex22(), getVertex28());
	var incenter60 = calulateIncenter(getVertex21(), getVertex22(), getVertex28());
	var ringGeometry60 = new THREE.RingGeometry((inradius60 - 0.005),inradius60, 32);
	const ringMaterial60 = new THREE.LineBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } );
	const ringMesh60 = new THREE.Mesh(ringGeometry60, ringMaterial60);

	function setCircleRotation60(){

        //translate ring to incenter
        var incenter = calulateIncenter([-0.42532540400000002,-0.85065080849999997,0.],[ -0.95105651599999996,0.,0.],[-0.15194522573557651,-0.056395058931322357,-0.061368077181590173]);

        ringMesh60.position.setX(incenter[0]);
        ringMesh60.position.setY(incenter[1]);
        ringMesh60.position.setZ(incenter[2]);

        // set the size right. Is done relative to the initial value, as we can only scale the mesh
        var inradius = calulateInradius(getVertex21(), getVertex22(), getVertex28());
        var relRadius = inradius/inradius60;

        ringMesh60.scale.set(relRadius, relRadius, relRadius);

        // rotate ring to right angle
        const A60 = new THREE.Vector3(-0.42532540400000002,-0.85065080849999997,0.);
        const B60 = new THREE.Vector3(-0.95105651599999996,0.,0.);
        const C60 = new THREE.Vector3(-0.15194522573557651,-0.056395058931322357,-0.061368077181590173);

        const normalVec60 = new THREE.Vector3();
        normalVec60.crossVectors(B60.sub(A60), C60.sub(A60));
        normalVec60.normalize();

        //initial normal vector of ringGeometry is (0,0,1), so we use that
        const initialNormal60 = new THREE.Vector3(0,0,1);

        const quaternionRotation60 = new THREE.Quaternion();
        quaternionRotation60.setFromUnitVectors(initialNormal60, normalVec60);

        ringMesh60.setRotationFromQuaternion(quaternionRotation60);

        return quaternionRotation60;
    }

    ringRoot.add(ringMesh60);
            	// function to update the circles every frame 
	function updateCircles(){
		setCircleRotation1();
		setCircleRotation2();
		setCircleRotation3();
		setCircleRotation4();
		setCircleRotation5();
		setCircleRotation6();
		setCircleRotation7();
		setCircleRotation8();
		setCircleRotation9();
		setCircleRotation10();
		setCircleRotation11();
		setCircleRotation12();
		setCircleRotation13();
		setCircleRotation14();
		setCircleRotation15();
		setCircleRotation16();
		setCircleRotation17();
		setCircleRotation18();
		setCircleRotation19();
		setCircleRotation20();
		setCircleRotation21();
		setCircleRotation22();
		setCircleRotation23();
		setCircleRotation24();
		setCircleRotation25();
		setCircleRotation26();
		setCircleRotation27();
		setCircleRotation28();
		setCircleRotation29();
		setCircleRotation30();
		setCircleRotation31();
		setCircleRotation32();
		setCircleRotation33();
		setCircleRotation34();
		setCircleRotation35();
		setCircleRotation36();
		setCircleRotation37();
		setCircleRotation38();
		setCircleRotation39();
		setCircleRotation40();
		setCircleRotation41();
		setCircleRotation42();
		setCircleRotation43();
		setCircleRotation44();
		setCircleRotation45();
		setCircleRotation46();
		setCircleRotation47();
		setCircleRotation48();
		setCircleRotation49();
		setCircleRotation50();
		setCircleRotation51();
		setCircleRotation52();
		setCircleRotation53();
		setCircleRotation54();
		setCircleRotation55();
		setCircleRotation56();
		setCircleRotation57();
		setCircleRotation58();
		setCircleRotation59();
		setCircleRotation60();
	}

	// needs to be called once to be initialized 
	updateCircles();

	// function to update the circles width, that is called every frame even if the surface is not parameterized 
	function updateCircleWidth(){
		ringGeometry1.dispose();
		ringGeometry1 = new THREE.RingGeometry((inradius1 - guiParameters.circleWidth),inradius1, 32);
		ringMesh1.geometry = ringGeometry1; 
		ringGeometry2.dispose();
		ringGeometry2 = new THREE.RingGeometry((inradius2 - guiParameters.circleWidth),inradius2, 32);
		ringMesh2.geometry = ringGeometry2; 
		ringGeometry3.dispose();
		ringGeometry3 = new THREE.RingGeometry((inradius3 - guiParameters.circleWidth),inradius3, 32);
		ringMesh3.geometry = ringGeometry3; 
		ringGeometry4.dispose();
		ringGeometry4 = new THREE.RingGeometry((inradius4 - guiParameters.circleWidth),inradius4, 32);
		ringMesh4.geometry = ringGeometry4; 
		ringGeometry5.dispose();
		ringGeometry5 = new THREE.RingGeometry((inradius5 - guiParameters.circleWidth),inradius5, 32);
		ringMesh5.geometry = ringGeometry5; 
		ringGeometry6.dispose();
		ringGeometry6 = new THREE.RingGeometry((inradius6 - guiParameters.circleWidth),inradius6, 32);
		ringMesh6.geometry = ringGeometry6; 
		ringGeometry7.dispose();
		ringGeometry7 = new THREE.RingGeometry((inradius7 - guiParameters.circleWidth),inradius7, 32);
		ringMesh7.geometry = ringGeometry7; 
		ringGeometry8.dispose();
		ringGeometry8 = new THREE.RingGeometry((inradius8 - guiParameters.circleWidth),inradius8, 32);
		ringMesh8.geometry = ringGeometry8; 
		ringGeometry9.dispose();
		ringGeometry9 = new THREE.RingGeometry((inradius9 - guiParameters.circleWidth),inradius9, 32);
		ringMesh9.geometry = ringGeometry9; 
		ringGeometry10.dispose();
		ringGeometry10 = new THREE.RingGeometry((inradius10 - guiParameters.circleWidth),inradius10, 32);
		ringMesh10.geometry = ringGeometry10; 
		ringGeometry11.dispose();
		ringGeometry11 = new THREE.RingGeometry((inradius11 - guiParameters.circleWidth),inradius11, 32);
		ringMesh11.geometry = ringGeometry11; 
		ringGeometry12.dispose();
		ringGeometry12 = new THREE.RingGeometry((inradius12 - guiParameters.circleWidth),inradius12, 32);
		ringMesh12.geometry = ringGeometry12; 
		ringGeometry13.dispose();
		ringGeometry13 = new THREE.RingGeometry((inradius13 - guiParameters.circleWidth),inradius13, 32);
		ringMesh13.geometry = ringGeometry13; 
		ringGeometry14.dispose();
		ringGeometry14 = new THREE.RingGeometry((inradius14 - guiParameters.circleWidth),inradius14, 32);
		ringMesh14.geometry = ringGeometry14; 
		ringGeometry15.dispose();
		ringGeometry15 = new THREE.RingGeometry((inradius15 - guiParameters.circleWidth),inradius15, 32);
		ringMesh15.geometry = ringGeometry15; 
		ringGeometry16.dispose();
		ringGeometry16 = new THREE.RingGeometry((inradius16 - guiParameters.circleWidth),inradius16, 32);
		ringMesh16.geometry = ringGeometry16; 
		ringGeometry17.dispose();
		ringGeometry17 = new THREE.RingGeometry((inradius17 - guiParameters.circleWidth),inradius17, 32);
		ringMesh17.geometry = ringGeometry17; 
		ringGeometry18.dispose();
		ringGeometry18 = new THREE.RingGeometry((inradius18 - guiParameters.circleWidth),inradius18, 32);
		ringMesh18.geometry = ringGeometry18; 
		ringGeometry19.dispose();
		ringGeometry19 = new THREE.RingGeometry((inradius19 - guiParameters.circleWidth),inradius19, 32);
		ringMesh19.geometry = ringGeometry19; 
		ringGeometry20.dispose();
		ringGeometry20 = new THREE.RingGeometry((inradius20 - guiParameters.circleWidth),inradius20, 32);
		ringMesh20.geometry = ringGeometry20; 
		ringGeometry21.dispose();
		ringGeometry21 = new THREE.RingGeometry((inradius21 - guiParameters.circleWidth),inradius21, 32);
		ringMesh21.geometry = ringGeometry21; 
		ringGeometry22.dispose();
		ringGeometry22 = new THREE.RingGeometry((inradius22 - guiParameters.circleWidth),inradius22, 32);
		ringMesh22.geometry = ringGeometry22; 
		ringGeometry23.dispose();
		ringGeometry23 = new THREE.RingGeometry((inradius23 - guiParameters.circleWidth),inradius23, 32);
		ringMesh23.geometry = ringGeometry23; 
		ringGeometry24.dispose();
		ringGeometry24 = new THREE.RingGeometry((inradius24 - guiParameters.circleWidth),inradius24, 32);
		ringMesh24.geometry = ringGeometry24; 
		ringGeometry25.dispose();
		ringGeometry25 = new THREE.RingGeometry((inradius25 - guiParameters.circleWidth),inradius25, 32);
		ringMesh25.geometry = ringGeometry25; 
		ringGeometry26.dispose();
		ringGeometry26 = new THREE.RingGeometry((inradius26 - guiParameters.circleWidth),inradius26, 32);
		ringMesh26.geometry = ringGeometry26; 
		ringGeometry27.dispose();
		ringGeometry27 = new THREE.RingGeometry((inradius27 - guiParameters.circleWidth),inradius27, 32);
		ringMesh27.geometry = ringGeometry27; 
		ringGeometry28.dispose();
		ringGeometry28 = new THREE.RingGeometry((inradius28 - guiParameters.circleWidth),inradius28, 32);
		ringMesh28.geometry = ringGeometry28; 
		ringGeometry29.dispose();
		ringGeometry29 = new THREE.RingGeometry((inradius29 - guiParameters.circleWidth),inradius29, 32);
		ringMesh29.geometry = ringGeometry29; 
		ringGeometry30.dispose();
		ringGeometry30 = new THREE.RingGeometry((inradius30 - guiParameters.circleWidth),inradius30, 32);
		ringMesh30.geometry = ringGeometry30; 
		ringGeometry31.dispose();
		ringGeometry31 = new THREE.RingGeometry((inradius31 - guiParameters.circleWidth),inradius31, 32);
		ringMesh31.geometry = ringGeometry31; 
		ringGeometry32.dispose();
		ringGeometry32 = new THREE.RingGeometry((inradius32 - guiParameters.circleWidth),inradius32, 32);
		ringMesh32.geometry = ringGeometry32; 
		ringGeometry33.dispose();
		ringGeometry33 = new THREE.RingGeometry((inradius33 - guiParameters.circleWidth),inradius33, 32);
		ringMesh33.geometry = ringGeometry33; 
		ringGeometry34.dispose();
		ringGeometry34 = new THREE.RingGeometry((inradius34 - guiParameters.circleWidth),inradius34, 32);
		ringMesh34.geometry = ringGeometry34; 
		ringGeometry35.dispose();
		ringGeometry35 = new THREE.RingGeometry((inradius35 - guiParameters.circleWidth),inradius35, 32);
		ringMesh35.geometry = ringGeometry35; 
		ringGeometry36.dispose();
		ringGeometry36 = new THREE.RingGeometry((inradius36 - guiParameters.circleWidth),inradius36, 32);
		ringMesh36.geometry = ringGeometry36; 
		ringGeometry37.dispose();
		ringGeometry37 = new THREE.RingGeometry((inradius37 - guiParameters.circleWidth),inradius37, 32);
		ringMesh37.geometry = ringGeometry37; 
		ringGeometry38.dispose();
		ringGeometry38 = new THREE.RingGeometry((inradius38 - guiParameters.circleWidth),inradius38, 32);
		ringMesh38.geometry = ringGeometry38; 
		ringGeometry39.dispose();
		ringGeometry39 = new THREE.RingGeometry((inradius39 - guiParameters.circleWidth),inradius39, 32);
		ringMesh39.geometry = ringGeometry39; 
		ringGeometry40.dispose();
		ringGeometry40 = new THREE.RingGeometry((inradius40 - guiParameters.circleWidth),inradius40, 32);
		ringMesh40.geometry = ringGeometry40; 
		ringGeometry41.dispose();
		ringGeometry41 = new THREE.RingGeometry((inradius41 - guiParameters.circleWidth),inradius41, 32);
		ringMesh41.geometry = ringGeometry41; 
		ringGeometry42.dispose();
		ringGeometry42 = new THREE.RingGeometry((inradius42 - guiParameters.circleWidth),inradius42, 32);
		ringMesh42.geometry = ringGeometry42; 
		ringGeometry43.dispose();
		ringGeometry43 = new THREE.RingGeometry((inradius43 - guiParameters.circleWidth),inradius43, 32);
		ringMesh43.geometry = ringGeometry43; 
		ringGeometry44.dispose();
		ringGeometry44 = new THREE.RingGeometry((inradius44 - guiParameters.circleWidth),inradius44, 32);
		ringMesh44.geometry = ringGeometry44; 
		ringGeometry45.dispose();
		ringGeometry45 = new THREE.RingGeometry((inradius45 - guiParameters.circleWidth),inradius45, 32);
		ringMesh45.geometry = ringGeometry45; 
		ringGeometry46.dispose();
		ringGeometry46 = new THREE.RingGeometry((inradius46 - guiParameters.circleWidth),inradius46, 32);
		ringMesh46.geometry = ringGeometry46; 
		ringGeometry47.dispose();
		ringGeometry47 = new THREE.RingGeometry((inradius47 - guiParameters.circleWidth),inradius47, 32);
		ringMesh47.geometry = ringGeometry47; 
		ringGeometry48.dispose();
		ringGeometry48 = new THREE.RingGeometry((inradius48 - guiParameters.circleWidth),inradius48, 32);
		ringMesh48.geometry = ringGeometry48; 
		ringGeometry49.dispose();
		ringGeometry49 = new THREE.RingGeometry((inradius49 - guiParameters.circleWidth),inradius49, 32);
		ringMesh49.geometry = ringGeometry49; 
		ringGeometry50.dispose();
		ringGeometry50 = new THREE.RingGeometry((inradius50 - guiParameters.circleWidth),inradius50, 32);
		ringMesh50.geometry = ringGeometry50; 
		ringGeometry51.dispose();
		ringGeometry51 = new THREE.RingGeometry((inradius51 - guiParameters.circleWidth),inradius51, 32);
		ringMesh51.geometry = ringGeometry51; 
		ringGeometry52.dispose();
		ringGeometry52 = new THREE.RingGeometry((inradius52 - guiParameters.circleWidth),inradius52, 32);
		ringMesh52.geometry = ringGeometry52; 
		ringGeometry53.dispose();
		ringGeometry53 = new THREE.RingGeometry((inradius53 - guiParameters.circleWidth),inradius53, 32);
		ringMesh53.geometry = ringGeometry53; 
		ringGeometry54.dispose();
		ringGeometry54 = new THREE.RingGeometry((inradius54 - guiParameters.circleWidth),inradius54, 32);
		ringMesh54.geometry = ringGeometry54; 
		ringGeometry55.dispose();
		ringGeometry55 = new THREE.RingGeometry((inradius55 - guiParameters.circleWidth),inradius55, 32);
		ringMesh55.geometry = ringGeometry55; 
		ringGeometry56.dispose();
		ringGeometry56 = new THREE.RingGeometry((inradius56 - guiParameters.circleWidth),inradius56, 32);
		ringMesh56.geometry = ringGeometry56; 
		ringGeometry57.dispose();
		ringGeometry57 = new THREE.RingGeometry((inradius57 - guiParameters.circleWidth),inradius57, 32);
		ringMesh57.geometry = ringGeometry57; 
		ringGeometry58.dispose();
		ringGeometry58 = new THREE.RingGeometry((inradius58 - guiParameters.circleWidth),inradius58, 32);
		ringMesh58.geometry = ringGeometry58; 
		ringGeometry59.dispose();
		ringGeometry59 = new THREE.RingGeometry((inradius59 - guiParameters.circleWidth),inradius59, 32);
		ringMesh59.geometry = ringGeometry59; 
		ringGeometry60.dispose();
		ringGeometry60 = new THREE.RingGeometry((inradius60 - guiParameters.circleWidth),inradius60, 32);
		ringMesh60.geometry = ringGeometry60; 
	}

	updateCircleWidth();

	// generate the normals trough the incenter orthogonal to the face 
	// getNormalsVectors generates the coordinates for the current values of the parameterized surface 
	function getNormalsVectors(){
		var vector1;
		var vector2;

		var normals = [];
		vector1 = [];
		vector2 = [];
		vector1[0] = (0.425325404)-(0.951056516);
		vector1[1] = (0.8506508085)-(0.);
		vector1[2] = (0.)-(0.);

		vector2[0] = (0.425325404)-(0.951056516);
		vector2[1] = (0.262865556)-(0.);
		vector2[2] = (0.809016994)-(0.);

		var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.42532540400000002,0.85065080849999997,0.],[0.42532540400000002,0.262865556,0.80901699400000004]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.425325404)-(0.951056516);
		vector1[1] = (0.8506508085)-(0.);
		vector1[2] = (0.)-(0.);

		vector2[0] = (0.1519452257355765)-(0.951056516);
		vector2[1] = (0.05639505893132235)-(0.);
		vector2[2] = (0.06136807718159009)-(0.);

		var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.42532540400000002,0.85065080849999997,0.],[0.15194522573557648,0.05639505893132235,0.06136807718159009]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.425325404)-(0.951056516);
		vector1[1] = (0.262865556)-(0.);
		vector1[2] = (0.809016994)-(0.);

		vector2[0] = (0.425325404)-(0.951056516);
		vector2[1] = (-0.6881909604000001)-(0.);
		vector2[2] = (0.4999999998)-(0.);

		var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.42532540400000002,0.262865556,0.80901699400000004],[0.42532540400000002,-0.68819096040000005,0.49999999979999998]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.1519452257355765)-(0.951056516);
		vector1[1] = (0.05639505893132235)-(0.);
		vector1[2] = (0.06136807718159009)-(0.);

		vector2[0] = (0.1657517901096376)-(0.951056516);
		vector2[1] = (-0.01731415965562747)-(0.);
		vector2[2] = (0.06710716423321821)-(0.);

		var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.15194522573557648,0.05639505893132235,0.06136807718159009],[0.16575179010963761,-0.017314159655627472,0.067107164233218206]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.1098867367622748)-(0.951056516);
		vector1[1] = (-0.0945461097393121)-(0.);
		vector1[2] = (0.01458980334578874)-(0.);

		vector2[0] = (0.1657517901096376)-(0.951056516);
		vector2[1] = (-0.01731415965562747)-(0.);
		vector2[2] = (0.06710716423321821)-(0.);

		var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.10988673676227484,-0.094546109739312101,0.014589803345788743],[0.16575179010963761,-0.017314159655627472,0.067107164233218206]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.425325404)-(0.951056516);
		vector1[1] = (-0.6881909604000001)-(0.);
		vector1[2] = (0.4999999998)-(0.);

		vector2[0] = (0.425325404)-(0.951056516);
		vector2[1] = (-0.6881909604000001)-(0.);
		vector2[2] = (-0.4999999998)-(0.);

		var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.42532540400000002,-0.68819096040000005,0.49999999979999998],[0.42532540400000002,-0.68819096040000005,-0.49999999979999998]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.425325404)-(0.951056516);
		vector1[1] = (-0.6881909604000001)-(0.);
		vector1[2] = (-0.4999999998)-(0.);

		vector2[0] = (0.1098867367622748)-(0.951056516);
		vector2[1] = (-0.0945461097393121)-(0.);
		vector2[2] = (0.01458980334578874)-(0.);

		var incenter = calulateIncenter([0.95105651599999996,0.,0.],[ 0.42532540400000002,-0.68819096040000005,-0.49999999979999998],[0.10988673676227484,-0.094546109739312101,0.014589803345788743]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.425325404)-(0.425325404);
		vector1[1] = (0.262865556)-(0.8506508085);
		vector1[2] = (0.809016994)-(0.);

		vector2[0] = (-0.425325404)-(0.425325404);
		vector2[1] = (0.6881909604000001)-(0.8506508085);
		vector2[2] = (0.4999999998)-(0.);

		var incenter = calulateIncenter([0.42532540400000002,0.85065080849999997,0.],[ 0.42532540400000002,0.262865556,0.80901699400000004],[-0.42532540400000002,0.68819096040000005,0.49999999979999998]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.1519452257355765)-(0.425325404);
		vector1[1] = (0.05639505893132235)-(0.8506508085);
		vector1[2] = (0.06136807718159009)-(0.);

		vector2[0] = (0.05137477354054257)-(0.425325404);
		vector2[1] = (0.1596287483457181)-(0.8506508085);
		vector2[2] = (0.0644678440128061)-(0.);

		var incenter = calulateIncenter([0.42532540400000002,0.85065080849999997,0.],[ 0.15194522573557648,0.05639505893132235,0.06136807718159009],[0.051374773540542575,0.15962874834571811,0.0644678440128061]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.05137477354054257)-(0.425325404);
		vector1[1] = (0.1596287483457181)-(0.8506508085);
		vector1[2] = (0.0644678440128061)-(0.);

		vector2[0] = (-0.005118984749543602)-(0.425325404);
		vector2[1] = (0.1724394192620157)-(0.8506508085);
		vector2[2] = (0.01649963342152638)-(0.);

		var incenter = calulateIncenter([0.42532540400000002,0.85065080849999997,0.],[ 0.051374773540542575,0.15962874834571811,0.0644678440128061],[-0.0051189847495436017,0.17243941926201567,0.016499633421526383]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.425325404)-(0.425325404);
		vector1[1] = (0.6881909604000001)-(0.8506508085);
		vector1[2] = (0.4999999998)-(0.);

		vector2[0] = (-0.425325404)-(0.425325404);
		vector2[1] = (0.6881909604000001)-(0.8506508085);
		vector2[2] = (-0.4999999998)-(0.);

		var incenter = calulateIncenter([0.42532540400000002,0.85065080849999997,0.],[ -0.42532540400000002,0.68819096040000005,0.49999999979999998],[-0.42532540400000002,0.68819096040000005,-0.49999999979999998]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.425325404)-(0.425325404);
		vector1[1] = (0.6881909604000001)-(0.8506508085);
		vector1[2] = (-0.4999999998)-(0.);

		vector2[0] = (-0.005118984749543602)-(0.425325404);
		vector2[1] = (0.1724394192620157)-(0.8506508085);
		vector2[2] = (0.01649963342152638)-(0.);

		var incenter = calulateIncenter([0.42532540400000002,0.85065080849999997,0.],[ -0.42532540400000002,0.68819096040000005,-0.49999999979999998],[-0.0051189847495436017,0.17243941926201567,0.016499633421526383]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.1098867367749586)-(0.425325404);
		vector1[1] = (0.06791373824254217)-(0.262865556);
		vector1[2] = (0.06737620779366739)-(0.809016994);

		vector2[0] = (0.1252273638565441)-(0.425325404);
		vector2[1] = (-0.02301094063083842)-(0.262865556);
		vector2[2] = (0.07082039315948314)-(0.809016994);

		var incenter = calulateIncenter([0.42532540400000002,0.262865556,0.80901699400000004],[ 0.10988673677495858,0.067913738242542168,0.067376207793667389],[0.12522736385654409,-0.02301094063083842,0.070820393159483144]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.1098867367749586)-(0.425325404);
		vector1[1] = (0.06791373824254217)-(0.262865556);
		vector1[2] = (0.06737620779366739)-(0.809016994);

		vector2[0] = (0.03542176863691715)-(0.425325404);
		vector2[1] = (0.1222975648548171)-(0.262865556);
		vector2[2] = (0.07082039316041153)-(0.809016994);

		var incenter = calulateIncenter([0.42532540400000002,0.262865556,0.80901699400000004],[ 0.10988673677495858,0.067913738242542168,0.067376207793667389],[0.03542176863691715,0.12229756485481713,0.070820393160411527]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.1252273638565441)-(0.425325404);
		vector1[1] = (-0.02301094063083842)-(0.262865556);
		vector1[2] = (0.07082039315948314)-(0.809016994);

		vector2[0] = (0.425325404)-(0.425325404);
		vector2[1] = (-0.6881909604000001)-(0.262865556);
		vector2[2] = (0.4999999998)-(0.809016994);

		var incenter = calulateIncenter([0.42532540400000002,0.262865556,0.80901699400000004],[ 0.12522736385654409,-0.02301094063083842,0.070820393159483144],[0.42532540400000002,-0.68819096040000005,0.49999999979999998]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.03542176863691715)-(0.425325404);
		vector1[1] = (0.1222975648548171)-(0.262865556);
		vector1[2] = (0.07082039316041153)-(0.809016994);

		vector2[0] = (-0.425325404)-(0.425325404);
		vector2[1] = (0.6881909604000001)-(0.262865556);
		vector2[2] = (0.4999999998)-(0.809016994);

		var incenter = calulateIncenter([0.42532540400000002,0.262865556,0.80901699400000004],[ 0.03542176863691715,0.12229756485481713,0.070820393160411527],[-0.42532540400000002,0.68819096040000005,0.49999999979999998]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.1252273638565441)-(-0.0449027976);
		vector1[1] = (-0.02301094063083842)-(-0.0277514551);
		vector1[2] = (0.07082039315948314)-(0.08541019649999999);

		vector2[0] = (0.03542176863691715)-(-0.0449027976);
		vector2[1] = (0.1222975648548171)-(-0.0277514551);
		vector2[2] = (0.07082039316041153)-(0.08541019649999999);

		var incenter = calulateIncenter([-0.044902797600000002,-0.027751455099999999,0.085410196499999994],[ 0.12522736385654409,-0.02301094063083842,0.070820393159483144],[0.03542176863691715,0.12229756485481713,0.070820393160411527]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.1252273638565441)-(-0.0449027976);
		vector1[1] = (-0.02301094063083842)-(-0.0277514551);
		vector1[2] = (0.07082039315948314)-(0.08541019649999999);

		vector2[0] = (0.0354217686536573)-(-0.0449027976);
		vector2[1] = (-0.140567991027654)-(-0.0277514551);
		vector2[2] = (-0.01458980336871456)-(0.08541019649999999);

		var incenter = calulateIncenter([-0.044902797600000002,-0.027751455099999999,0.085410196499999994],[ 0.12522736385654409,-0.02301094063083842,0.070820393159483144],[0.035421768653657301,-0.14056799102765397,-0.014589803368714557]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.03542176863691715)-(-0.0449027976);
		vector1[1] = (0.1222975648548171)-(-0.0277514551);
		vector1[2] = (0.07082039316041153)-(0.08541019649999999);

		vector2[0] = (-0.1183932448542015)-(-0.0449027976);
		vector2[1] = (0.1256159250281217)-(-0.0277514551);
		vector2[2] = (0.01541019663681068)-(0.08541019649999999);

		var incenter = calulateIncenter([-0.044902797600000002,-0.027751455099999999,0.085410196499999994],[ 0.03542176863691715,0.12229756485481713,0.070820393160411527],[-0.11839324485420148,0.12561592502812169,0.015410196636810683]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.0354217686536573)-(-0.0449027976);
		vector1[1] = (-0.140567991027654)-(-0.0277514551);
		vector1[2] = (-0.01458980336871456)-(0.08541019649999999);

		vector2[0] = (-0.1519452257355765)-(-0.0449027976);
		vector2[1] = (-0.05639505893132236)-(-0.0277514551);
		vector2[2] = (-0.06136807718159017)-(0.08541019649999999);

		var incenter = calulateIncenter([-0.044902797600000002,-0.027751455099999999,0.085410196499999994],[ 0.035421768653657301,-0.14056799102765397,-0.014589803368714557],[-0.15194522573557651,-0.056395058931322357,-0.061368077181590173]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.1183932448542015)-(-0.0449027976);
		vector1[1] = (0.1256159250281217)-(-0.0277514551);
		vector1[2] = (0.01541019663681068)-(0.08541019649999999);

		vector2[0] = (-0.1519452257355765)-(-0.0449027976);
		vector2[1] = (-0.05639505893132236)-(-0.0277514551);
		vector2[2] = (-0.06136807718159017)-(0.08541019649999999);

		var incenter = calulateIncenter([-0.044902797600000002,-0.027751455099999999,0.085410196499999994],[ -0.11839324485420148,0.12561592502812169,0.015410196636810683],[-0.15194522573557651,-0.056395058931322357,-0.061368077181590173]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.1252273638565441)-(0.1098867367749586);
		vector1[1] = (-0.02301094063083842)-(0.06791373824254217);
		vector1[2] = (0.07082039315948314)-(0.06737620779366739);

		vector2[0] = (0.03542176863691715)-(0.1098867367749586);
		vector2[1] = (0.1222975648548171)-(0.06791373824254217);
		vector2[2] = (0.07082039316041153)-(0.06737620779366739);

		var incenter = calulateIncenter([0.10988673677495858,0.067913738242542168,0.067376207793667389],[ 0.12522736385654409,-0.02301094063083842,0.070820393159483144],[0.03542176863691715,0.12229756485481713,0.070820393160411527]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.1519452257355765)-(0.1098867367622748);
		vector1[1] = (0.05639505893132235)-(-0.0945461097393121);
		vector1[2] = (0.06136807718159009)-(0.01458980334578874);

		vector2[0] = (0.1657517901096376)-(0.1098867367622748);
		vector2[1] = (-0.01731415965562747)-(-0.0945461097393121);
		vector2[2] = (0.06710716423321821)-(0.01458980334578874);

		var incenter = calulateIncenter([0.10988673676227484,-0.094546109739312101,0.014589803345788743],[ 0.15194522573557648,0.05639505893132235,0.06136807718159009],[0.16575179010963761,-0.017314159655627472,0.067107164233218206]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.05137477354054257)-(0.1519452257355765);
		vector1[1] = (0.1596287483457181)-(0.05639505893132235);
		vector1[2] = (0.0644678440128061)-(0.06136807718159009);

		vector2[0] = (-0.005118984749543602)-(0.1519452257355765);
		vector2[1] = (0.1724394192620157)-(0.05639505893132235);
		vector2[2] = (0.01649963342152638)-(0.06136807718159009);

		var incenter = calulateIncenter([0.15194522573557648,0.05639505893132235,0.06136807718159009],[ 0.051374773540542575,0.15962874834571811,0.0644678440128061],[-0.0051189847495436017,0.17243941926201567,0.016499633421526383]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.0449027976)-(0.1098867367622748);
		vector1[1] = (0.0277514551)-(-0.0945461097393121);
		vector1[2] = (-0.08541019649999999)-(0.01458980334578874);

		vector2[0] = (0.1519452257355765)-(0.1098867367622748);
		vector2[1] = (0.05639505893132235)-(-0.0945461097393121);
		vector2[2] = (0.06136807718159009)-(0.01458980334578874);

		var incenter = calulateIncenter([0.10988673676227484,-0.094546109739312101,0.014589803345788743],[ 0.044902797600000002,0.027751455099999999,-0.085410196499999994],[0.15194522573557648,0.05639505893132235,0.06136807718159009]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.1519452257355765)-(0.0449027976);
		vector1[1] = (0.05639505893132235)-(0.0277514551);
		vector1[2] = (0.06136807718159009)-(-0.08541019649999999);

		vector2[0] = (-0.005118984749543602)-(0.0449027976);
		vector2[1] = (0.1724394192620157)-(0.0277514551);
		vector2[2] = (0.01649963342152638)-(-0.08541019649999999);

		var incenter = calulateIncenter([0.044902797600000002,0.027751455099999999,-0.085410196499999994],[ 0.15194522573557648,0.05639505893132235,0.06136807718159009],[-0.0051189847495436017,0.17243941926201567,0.016499633421526383]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.425325404)-(0.1252273638565441);
		vector1[1] = (-0.6881909604000001)-(-0.02301094063083842);
		vector1[2] = (0.4999999998)-(0.07082039315948314);

		vector2[0] = (0.1264257014788746)-(0.1252273638565441);
		vector2[1] = (-0.1206515938169228)-(-0.02301094063083842);
		vector2[2] = (0.04167184265918403)-(0.07082039315948314);

		var incenter = calulateIncenter([0.12522736385654409,-0.02301094063083842,0.070820393159483144],[ 0.42532540400000002,-0.68819096040000005,0.49999999979999998],[0.12642570147887455,-0.12065159381692281,0.041671842659184027]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.0354217686536573)-(0.1252273638565441);
		vector1[1] = (-0.140567991027654)-(-0.02301094063083842);
		vector1[2] = (-0.01458980336871456)-(0.07082039315948314);

		vector2[0] = (0.1264257014788746)-(0.1252273638565441);
		vector2[1] = (-0.1206515938169228)-(-0.02301094063083842);
		vector2[2] = (0.04167184265918403)-(0.07082039315948314);

		var incenter = calulateIncenter([0.12522736385654409,-0.02301094063083842,0.070820393159483144],[ 0.035421768653657301,-0.14056799102765397,-0.014589803368714557],[0.12642570147887455,-0.12065159381692281,0.041671842659184027]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.425325404)-(0.03542176863691715);
		vector1[1] = (0.6881909604000001)-(0.1222975648548171);
		vector1[2] = (0.4999999998)-(0.07082039316041153);

		vector2[0] = (-0.03542176865365726)-(0.03542176863691715);
		vector2[1] = (0.1405679910276539)-(0.1222975648548171);
		vector2[2] = (0.01458980336871446)-(0.07082039316041153);

		var incenter = calulateIncenter([0.03542176863691715,0.12229756485481713,0.070820393160411527],[ -0.42532540400000002,0.68819096040000005,0.49999999979999998],[-0.03542176865365726,0.14056799102765394,0.01458980336871446]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.03542176865365726)-(0.03542176863691715);
		vector1[1] = (0.1405679910276539)-(0.1222975648548171);
		vector1[2] = (0.01458980336871446)-(0.07082039316041153);

		vector2[0] = (-0.1183932448542015)-(0.03542176863691715);
		vector2[1] = (0.1256159250281217)-(0.1222975648548171);
		vector2[2] = (0.01541019663681068)-(0.07082039316041153);

		var incenter = calulateIncenter([0.03542176863691715,0.12229756485481713,0.070820393160411527],[ -0.03542176865365726,0.14056799102765394,0.01458980336871446],[-0.11839324485420148,0.12561592502812169,0.015410196636810683]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.425325404)-(0.425325404);
		vector1[1] = (-0.6881909604000001)-(-0.6881909604000001);
		vector1[2] = (-0.4999999998)-(0.4999999998);

		vector2[0] = (-0.425325404)-(0.425325404);
		vector2[1] = (-0.8506508085)-(-0.6881909604000001);
		vector2[2] = (0.)-(0.4999999998);

		var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,0.49999999979999998],[ 0.42532540400000002,-0.68819096040000005,-0.49999999979999998],[-0.42532540400000002,-0.85065080849999997,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.0354217686536573)-(0.425325404);
		vector1[1] = (-0.140567991027654)-(-0.6881909604000001);
		vector1[2] = (-0.01458980336871456)-(0.4999999998);

		vector2[0] = (0.1264257014788746)-(0.425325404);
		vector2[1] = (-0.1206515938169228)-(-0.6881909604000001);
		vector2[2] = (0.04167184265918403)-(0.4999999998);

		var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,0.49999999979999998],[ 0.035421768653657301,-0.14056799102765397,-0.014589803368714557],[0.12642570147887455,-0.12065159381692281,0.041671842659184027]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.0354217686536573)-(0.425325404);
		vector1[1] = (-0.140567991027654)-(-0.6881909604000001);
		vector1[2] = (-0.01458980336871456)-(0.4999999998);

		vector2[0] = (-0.425325404)-(0.425325404);
		vector2[1] = (-0.8506508085)-(-0.6881909604000001);
		vector2[2] = (0.)-(0.4999999998);

		var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,0.49999999979999998],[ 0.035421768653657301,-0.14056799102765397,-0.014589803368714557],[-0.42532540400000002,-0.85065080849999997,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.1098867367622748)-(0.425325404);
		vector1[1] = (-0.0945461097393121)-(-0.6881909604000001);
		vector1[2] = (0.01458980334578874)-(-0.4999999998);

		vector2[0] = (0.05864019882640532)-(0.425325404);
		vector2[1] = (-0.1656480454318542)-(-0.6881909604000001);
		vector2[2] = (-0.03740133285455366)-(-0.4999999998);

		var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,-0.49999999979999998],[ 0.10988673676227484,-0.094546109739312101,0.014589803345788743],[0.058640198826405317,-0.16564804543185419,-0.037401332854553659]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.03542176863691709)-(0.425325404);
		vector1[1] = (-0.122297564854817)-(-0.6881909604000001);
		vector1[2] = (-0.07082039316041154)-(-0.4999999998);

		vector2[0] = (0.05864019882640532)-(0.425325404);
		vector2[1] = (-0.1656480454318542)-(-0.6881909604000001);
		vector2[2] = (-0.03740133285455366)-(-0.4999999998);

		var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,-0.49999999979999998],[ -0.035421768636917095,-0.12229756485481702,-0.070820393160411541],[0.058640198826405317,-0.16564804543185419,-0.037401332854553659]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.425325404)-(0.425325404);
		vector1[1] = (-0.262865556)-(-0.6881909604000001);
		vector1[2] = (-0.809016994)-(-0.4999999998);

		vector2[0] = (-0.03542176863691709)-(0.425325404);
		vector2[1] = (-0.122297564854817)-(-0.6881909604000001);
		vector2[2] = (-0.07082039316041154)-(-0.4999999998);

		var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,-0.49999999979999998],[ -0.42532540400000002,-0.262865556,-0.80901699400000004],[-0.035421768636917095,-0.12229756485481702,-0.070820393160411541]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.425325404)-(0.425325404);
		vector1[1] = (-0.262865556)-(-0.6881909604000001);
		vector1[2] = (-0.809016994)-(-0.4999999998);

		vector2[0] = (-0.425325404)-(0.425325404);
		vector2[1] = (-0.8506508085)-(-0.6881909604000001);
		vector2[2] = (0.)-(-0.4999999998);

		var incenter = calulateIncenter([0.42532540400000002,-0.68819096040000005,-0.49999999979999998],[ -0.42532540400000002,-0.262865556,-0.80901699400000004],[-0.42532540400000002,-0.85065080849999997,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.03542176863691709)-(0.1098867367622748);
		vector1[1] = (-0.122297564854817)-(-0.0945461097393121);
		vector1[2] = (-0.07082039316041154)-(0.01458980334578874);

		vector2[0] = (0.05864019882640532)-(0.1098867367622748);
		vector2[1] = (-0.1656480454318542)-(-0.0945461097393121);
		vector2[2] = (-0.03740133285455366)-(0.01458980334578874);

		var incenter = calulateIncenter([0.10988673676227484,-0.094546109739312101,0.014589803345788743],[ -0.035421768636917095,-0.12229756485481702,-0.070820393160411541],[0.058640198826405317,-0.16564804543185419,-0.037401332854553659]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (0.0449027976)-(0.1098867367622748);
		vector1[1] = (0.0277514551)-(-0.0945461097393121);
		vector1[2] = (-0.08541019649999999)-(0.01458980334578874);

		vector2[0] = (-0.03542176863691709)-(0.1098867367622748);
		vector2[1] = (-0.122297564854817)-(-0.0945461097393121);
		vector2[2] = (-0.07082039316041154)-(0.01458980334578874);

		var incenter = calulateIncenter([0.10988673676227484,-0.094546109739312101,0.014589803345788743],[ 0.044902797600000002,0.027751455099999999,-0.085410196499999994],[-0.035421768636917095,-0.12229756485481702,-0.070820393160411541]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.1519452257355765)-(0.0354217686536573);
		vector1[1] = (-0.05639505893132236)-(-0.140567991027654);
		vector1[2] = (-0.06136807718159017)-(-0.01458980336871456);

		vector2[0] = (-0.05137477354054253)-(0.0354217686536573);
		vector2[1] = (-0.159628748345718)-(-0.140567991027654);
		vector2[2] = (-0.06446784401280611)-(-0.01458980336871456);

		var incenter = calulateIncenter([0.035421768653657301,-0.14056799102765397,-0.014589803368714557],[ -0.15194522573557651,-0.056395058931322357,-0.061368077181590173],[-0.051374773540542526,-0.15962874834571802,-0.064467844012806114]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.425325404)-(0.0354217686536573);
		vector1[1] = (-0.8506508085)-(-0.140567991027654);
		vector1[2] = (0.)-(-0.01458980336871456);

		vector2[0] = (-0.05137477354054253)-(0.0354217686536573);
		vector2[1] = (-0.159628748345718)-(-0.140567991027654);
		vector2[2] = (-0.06446784401280611)-(-0.01458980336871456);

		var incenter = calulateIncenter([0.035421768653657301,-0.14056799102765397,-0.014589803368714557],[ -0.42532540400000002,-0.85065080849999997,0.],[-0.051374773540542526,-0.15962874834571802,-0.064467844012806114]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.425325404)-(-0.425325404);
		vector1[1] = (0.6881909604000001)-(0.6881909604000001);
		vector1[2] = (-0.4999999998)-(0.4999999998);

		vector2[0] = (-0.951056516)-(-0.425325404);
		vector2[1] = (0.)-(0.6881909604000001);
		vector2[2] = (0.)-(0.4999999998);

		var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,0.49999999979999998],[ -0.42532540400000002,0.68819096040000005,-0.49999999979999998],[-0.95105651599999996,0.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.03542176865365726)-(-0.425325404);
		vector1[1] = (0.1405679910276539)-(0.6881909604000001);
		vector1[2] = (0.01458980336871446)-(0.4999999998);

		vector2[0] = (-0.1183932448542015)-(-0.425325404);
		vector2[1] = (0.1256159250281217)-(0.6881909604000001);
		vector2[2] = (0.01541019663681068)-(0.4999999998);

		var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,0.49999999979999998],[ -0.03542176865365726,0.14056799102765394,0.01458980336871446],[-0.11839324485420148,0.12561592502812169,0.015410196636810683]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.951056516)-(-0.425325404);
		vector1[1] = (0.)-(0.6881909604000001);
		vector1[2] = (0.)-(0.4999999998);

		vector2[0] = (-0.1183932448542015)-(-0.425325404);
		vector2[1] = (0.1256159250281217)-(0.6881909604000001);
		vector2[2] = (0.01541019663681068)-(0.4999999998);

		var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,0.49999999979999998],[ -0.95105651599999996,0.,0.],[-0.11839324485420148,0.12561592502812169,0.015410196636810683]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.1098867367622748)-(-0.425325404);
		vector1[1] = (0.09454610973931203)-(0.6881909604000001);
		vector1[2] = (-0.01458980334578877)-(-0.4999999998);

		vector2[0] = (-0.005118984749543602)-(-0.425325404);
		vector2[1] = (0.1724394192620157)-(0.6881909604000001);
		vector2[2] = (0.01649963342152638)-(-0.4999999998);

		var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,-0.49999999979999998],[ -0.10988673676227483,0.094546109739312031,-0.014589803345788771],[-0.0051189847495436017,0.17243941926201567,0.016499633421526383]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.1098867367622748)-(-0.425325404);
		vector1[1] = (0.09454610973931203)-(0.6881909604000001);
		vector1[2] = (-0.01458980334578877)-(-0.4999999998);

		vector2[0] = (-0.1357419861035725)-(-0.425325404);
		vector2[1] = (0.06214779413913728)-(0.6881909604000001);
		vector2[2] = (-0.08800886366509909)-(-0.4999999998);

		var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,-0.49999999979999998],[ -0.10988673676227483,0.094546109739312031,-0.014589803345788771],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.425325404)-(-0.425325404);
		vector1[1] = (-0.262865556)-(0.6881909604000001);
		vector1[2] = (-0.809016994)-(-0.4999999998);

		vector2[0] = (-0.1357419861035725)-(-0.425325404);
		vector2[1] = (0.06214779413913728)-(0.6881909604000001);
		vector2[2] = (-0.08800886366509909)-(-0.4999999998);

		var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,-0.49999999979999998],[ -0.42532540400000002,-0.262865556,-0.80901699400000004],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.425325404)-(-0.425325404);
		vector1[1] = (-0.262865556)-(0.6881909604000001);
		vector1[2] = (-0.809016994)-(-0.4999999998);

		vector2[0] = (-0.951056516)-(-0.425325404);
		vector2[1] = (0.)-(0.6881909604000001);
		vector2[2] = (0.)-(-0.4999999998);

		var incenter = calulateIncenter([-0.42532540400000002,0.68819096040000005,-0.49999999979999998],[ -0.42532540400000002,-0.262865556,-0.80901699400000004],[-0.95105651599999996,0.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.005118984749543602)-(-0.1098867367622748);
		vector1[1] = (0.1724394192620157)-(0.09454610973931203);
		vector1[2] = (0.01649963342152638)-(-0.01458980334578877);

		vector2[0] = (-0.1357419861035725)-(-0.1098867367622748);
		vector2[1] = (0.06214779413913728)-(0.09454610973931203);
		vector2[2] = (-0.08800886366509909)-(-0.01458980334578877);

		var incenter = calulateIncenter([-0.10988673676227483,0.094546109739312031,-0.014589803345788771],[ -0.0051189847495436017,0.17243941926201567,0.016499633421526383],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.005118984749543602)-(0.0449027976);
		vector1[1] = (0.1724394192620157)-(0.0277514551);
		vector1[2] = (0.01649963342152638)-(-0.08541019649999999);

		vector2[0] = (-0.1357419861035725)-(0.0449027976);
		vector2[1] = (0.06214779413913728)-(0.0277514551);
		vector2[2] = (-0.08800886366509909)-(-0.08541019649999999);

		var incenter = calulateIncenter([0.044902797600000002,0.027751455099999999,-0.085410196499999994],[ -0.0051189847495436017,0.17243941926201567,0.016499633421526383],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.1183932448542015)-(-0.1252273638565441);
		vector1[1] = (0.1256159250281217)-(0.02301094063083842);
		vector1[2] = (0.01541019663681068)-(-0.07082039315948313);

		vector2[0] = (-0.1519452257355765)-(-0.1252273638565441);
		vector2[1] = (-0.05639505893132236)-(0.02301094063083842);
		vector2[2] = (-0.06136807718159017)-(-0.07082039315948313);

		var incenter = calulateIncenter([-0.12522736385654409,0.02301094063083842,-0.07082039315948313],[ -0.11839324485420148,0.12561592502812169,0.015410196636810683],[-0.15194522573557651,-0.056395058931322357,-0.061368077181590173]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.951056516)-(-0.1252273638565441);
		vector1[1] = (0.)-(0.02301094063083842);
		vector1[2] = (0.)-(-0.07082039315948313);

		vector2[0] = (-0.1183932448542015)-(-0.1252273638565441);
		vector2[1] = (0.1256159250281217)-(0.02301094063083842);
		vector2[2] = (0.01541019663681068)-(-0.07082039315948313);

		var incenter = calulateIncenter([-0.12522736385654409,0.02301094063083842,-0.07082039315948313],[ -0.95105651599999996,0.,0.],[-0.11839324485420148,0.12561592502812169,0.015410196636810683]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.03542176863691709)-(0.0449027976);
		vector1[1] = (-0.122297564854817)-(0.0277514551);
		vector1[2] = (-0.07082039316041154)-(-0.08541019649999999);

		vector2[0] = (-0.1357419861035725)-(0.0449027976);
		vector2[1] = (0.06214779413913728)-(0.0277514551);
		vector2[2] = (-0.08800886366509909)-(-0.08541019649999999);

		var incenter = calulateIncenter([0.044902797600000002,0.027751455099999999,-0.085410196499999994],[ -0.035421768636917095,-0.12229756485481702,-0.070820393160411541],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.03542176863691709)-(-0.425325404);
		vector1[1] = (-0.122297564854817)-(-0.262865556);
		vector1[2] = (-0.07082039316041154)-(-0.809016994);

		vector2[0] = (-0.1098867367749586)-(-0.425325404);
		vector2[1] = (-0.06791373824254218)-(-0.262865556);
		vector2[2] = (-0.06737620779366749)-(-0.809016994);

		var incenter = calulateIncenter([-0.42532540400000002,-0.262865556,-0.80901699400000004],[ -0.035421768636917095,-0.12229756485481702,-0.070820393160411541],[-0.10988673677495864,-0.067913738242542182,-0.067376207793667486]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.1098867367749586)-(-0.425325404);
		vector1[1] = (-0.06791373824254218)-(-0.262865556);
		vector1[2] = (-0.06737620779366749)-(-0.809016994);

		vector2[0] = (-0.1357419861035725)-(-0.425325404);
		vector2[1] = (0.06214779413913728)-(-0.262865556);
		vector2[2] = (-0.08800886366509909)-(-0.809016994);

		var incenter = calulateIncenter([-0.42532540400000002,-0.262865556,-0.80901699400000004],[ -0.10988673677495864,-0.067913738242542182,-0.067376207793667486],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.425325404)-(-0.425325404);
		vector1[1] = (-0.8506508085)-(-0.262865556);
		vector1[2] = (0.)-(-0.809016994);

		vector2[0] = (-0.951056516)-(-0.425325404);
		vector2[1] = (0.)-(-0.262865556);
		vector2[2] = (0.)-(-0.809016994);

		var incenter = calulateIncenter([-0.42532540400000002,-0.262865556,-0.80901699400000004],[ -0.42532540400000002,-0.85065080849999997,0.],[-0.95105651599999996,0.,0.]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.1098867367749586)-(-0.03542176863691709);
		vector1[1] = (-0.06791373824254218)-(-0.122297564854817);
		vector1[2] = (-0.06737620779366749)-(-0.07082039316041154);

		vector2[0] = (-0.1357419861035725)-(-0.03542176863691709);
		vector2[1] = (0.06214779413913728)-(-0.122297564854817);
		vector2[2] = (-0.08800886366509909)-(-0.07082039316041154);

		var incenter = calulateIncenter([-0.035421768636917095,-0.12229756485481702,-0.070820393160411541],[ -0.10988673677495864,-0.067913738242542182,-0.067376207793667486],[-0.13574198610357255,0.062147794139137284,-0.088008863665099094]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.1519452257355765)-(-0.425325404);
		vector1[1] = (-0.05639505893132236)-(-0.8506508085);
		vector1[2] = (-0.06136807718159017)-(0.);

		vector2[0] = (-0.05137477354054253)-(-0.425325404);
		vector2[1] = (-0.159628748345718)-(-0.8506508085);
		vector2[2] = (-0.06446784401280611)-(0.);

		var incenter = calulateIncenter([-0.42532540400000002,-0.85065080849999997,0.],[ -0.15194522573557651,-0.056395058931322357,-0.061368077181590173],[-0.051374773540542526,-0.15962874834571802,-0.064467844012806114]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.951056516)-(-0.1252273638565441);
		vector1[1] = (0.)-(0.02301094063083842);
		vector1[2] = (0.)-(-0.07082039315948313);

		vector2[0] = (-0.1519452257355765)-(-0.1252273638565441);
		vector2[1] = (-0.05639505893132236)-(0.02301094063083842);
		vector2[2] = (-0.06136807718159017)-(-0.07082039315948313);

		var incenter = calulateIncenter([-0.12522736385654409,0.02301094063083842,-0.07082039315948313],[ -0.95105651599999996,0.,0.],[-0.15194522573557651,-0.056395058931322357,-0.061368077181590173]);
		normals.push([vector1, vector2, incenter]);

		vector1 = [];
		vector2 = [];
		vector1[0] = (-0.951056516)-(-0.425325404);
		vector1[1] = (0.)-(-0.8506508085);
		vector1[2] = (0.)-(0.);

		vector2[0] = (-0.1519452257355765)-(-0.425325404);
		vector2[1] = (-0.05639505893132236)-(-0.8506508085);
		vector2[2] = (-0.06136807718159017)-(0.);

		var incenter = calulateIncenter([-0.42532540400000002,-0.85065080849999997,0.],[ -0.95105651599999996,0.,0.],[-0.15194522573557651,-0.056395058931322357,-0.061368077181590173]);
		normals.push([vector1, vector2, incenter]);

	return normals;
	}
	// getNormalsCoordinates calculates the right coordinates for the ortogonality and fitting values from the gui 
	function getNormalsCoordinates(){
		var res = [];
		var normals = getNormalsVectors(); 
        for(var i = 0; i < normals.length; i++){
            var plus = [];
            var minus = [];

            minus[0] = normals[i][2][0] - (1/2)*guiParameters.normalsLength*(normals[i][0][1]*normals[i][1][2] - normals[i][0][2]*normals[i][1][1]);
            minus[1] = normals[i][2][1] - (1/2)*guiParameters.normalsLength*(normals[i][0][2]*normals[i][1][0] - normals[i][0][0]*normals[i][1][2]);
            minus[2] = normals[i][2][2] - (1/2)*guiParameters.normalsLength*(normals[i][0][0]*normals[i][1][1] - normals[i][0][1]*normals[i][1][0]);

            plus[0] = normals[i][2][0] + (1/2)*guiParameters.normalsLength*(normals[i][0][1]*normals[i][1][2] - normals[i][0][2]*normals[i][1][1]);
            plus[1] = normals[i][2][1] + (1/2)*guiParameters.normalsLength*(normals[i][0][2]*normals[i][1][0] - normals[i][0][0]*normals[i][1][2]);
            plus[2] = normals[i][2][2] + (1/2)*guiParameters.normalsLength*(normals[i][0][0]*normals[i][1][1] - normals[i][0][1]*normals[i][1][0]);

            res.push(minus[0]);
            res.push(minus[1]);
            res.push(minus[2]);
            res.push(plus[0]);
            res.push(plus[1]);
            res.push(plus[2]);
        }
        res = Float32Array.from(res);

    
		return res;
	}


    const normalsMaterial = new THREE.LineBasicMaterial( {
        color: 0x000000,
    } );
    
    const normalsGeometry = new THREE.BufferGeometry();
    normalsGeometry.setAttribute( 'position', new THREE.BufferAttribute( getNormalsCoordinates(), 3 ) );
    var normalsLine = new THREE.LineSegments( normalsGeometry, normalsMaterial );

    function updateNormals(){
        normalsGeometry.setAttribute( 'position', new THREE.BufferAttribute( getNormalsCoordinates(), 3 ) );
        normalsLine = new THREE.LineSegments( normalsGeometry, normalsMaterial );
    }
    
    normalsRoot.add(normalsLine);

    
	// generate automatic ranges for the intersections if the surface is not parameterized 
	guiParameters.maxX = 0.951056516;
	guiParameters.maxY = 0.8506508085;
	guiParameters.maxZ = 0.809016994;
	guiParameters.minX = -0.951056516;
	guiParameters.minY = -0.8506508085;
	guiParameters.minZ = -0.809016994;

	guiParameters.planeX = 0.;
	guiParameters.planeY = 0.;
	guiParameters.planeZ = 0.;
	// --- end of generated output --- //

    const planeFolder = gui.addFolder("Intersection Planes");
    planeFolder.add(guiParameters, 'planeXactive');
    planeFolder.add(guiParameters, 'planeX', guiParameters.minX*1.1, guiParameters.maxX*1.1);
    planeFolder.add(guiParameters, 'planeYactive');
    planeFolder.add(guiParameters, 'planeY', guiParameters.minY*1.1, guiParameters.maxY*1.1);
    planeFolder.add(guiParameters, 'planeZactive');
    planeFolder.add(guiParameters, 'planeZ', guiParameters.minZ*1.1, guiParameters.maxZ*1.1);
    
    camera.position.z = Math.min((1.5)*guiParameters.minZ, -1)
    camera.lookAt(0,0,-1);

    scene.background = new THREE.Color( 'white' );

    // add both roots to the scene
    scene.add( meshRoot );
    scene.add( wireRoot );
    scene.add( vertexRoot );
    scene.add( vertexlabelRoot );
    scene.add( edgeRoot );
    scene.add( ringRoot );
    scene.add( normalsRoot );
    scene.add( normalMeshRoot );

    //presave some current gui parameters to only update if they change
    var currentCircleWidth = guiParameters.circleWidth;

    function animate() {
        requestAnimationFrame( animate );
        meshRoot.rotation.x += guiParameters.speedX/100;
        meshRoot.rotation.y += guiParameters.speedY/100;
        meshRoot.rotation.z += guiParameters.speedZ/100;

        wireRoot.rotation.x += guiParameters.speedX/100;
        wireRoot.rotation.y += guiParameters.speedY/100;
        wireRoot.rotation.z += guiParameters.speedZ/100;

        vertexRoot.rotation.x += guiParameters.speedX/100;
        vertexRoot.rotation.y += guiParameters.speedY/100;
        vertexRoot.rotation.z += guiParameters.speedZ/100;

        vertexlabelRoot.rotation.x += guiParameters.speedX/100;
        vertexlabelRoot.rotation.y += guiParameters.speedY/100;
        vertexlabelRoot.rotation.z += guiParameters.speedZ/100;

        edgeRoot.rotation.x += guiParameters.speedX/100;
        edgeRoot.rotation.y += guiParameters.speedY/100;
        edgeRoot.rotation.z += guiParameters.speedZ/100;

        ringRoot.rotation.x += guiParameters.speedX/100;
        ringRoot.rotation.y += guiParameters.speedY/100;
        ringRoot.rotation.z += guiParameters.speedZ/100;

        normalsRoot.rotation.x += guiParameters.speedX/100;
        normalsRoot.rotation.y += guiParameters.speedY/100;
        normalsRoot.rotation.z += guiParameters.speedZ/100;

        normalMeshRoot.rotation.x += guiParameters.speedX/100;
        normalMeshRoot.rotation.y += guiParameters.speedY/100;
        normalMeshRoot.rotation.z += guiParameters.speedZ/100;

        //update the light when the camera moves (with orbitcontrols)
        light.position.set(camera.position.x, camera.position.y, camera.position.z);

        planeX.constant = guiParameters.planeX;
        planeY.constant = guiParameters.planeY;
        planeZ.constant = guiParameters.planeZ;

        activePlanes = [];
        if(guiParameters.planeXactive){
            activePlanes.push(planeX);
        }
        if(guiParameters.planeYactive){
            activePlanes.push(planeY);
        }
        if(guiParameters.planeZactive){
            activePlanes.push(planeZ);
        }

        if(vertexParametriziation){
            updateFaceCoordinates();
            if(guiParameters.edgeVisibility){
                updateEdgeCoordinates();
            }
            if(guiParameters.vertexlabelVisibility || guiParameters.vertexVisibility){
                updateVertexCoordinates();
            }
            if(guiParameters.circleVisibility){
                updateCircles();
            }
        }                

        //update stuff that changes from the gui
        meshRoot.traverse( function( node ) {
            if ( node instanceof THREE.Mesh ) {
                node.material.opacity = guiParameters.transparency;
                node.material.clippingPlanes = activePlanes;
                if(guiParameters.normalsMaterial){
                    node.material.opacity = 0;
                }
            }
        } );

        normalMeshRoot.traverse( function( node ) {
            if ( node instanceof THREE.Mesh ) {
                node.material.opacity = guiParameters.transparency;
                node.material.clippingPlanes = activePlanes;
                if(!guiParameters.normalsMaterial){
                    node.material.opacity = 0;
                }
            }
        } );

        edgeRoot.traverse( function( node ) {
            if ( node instanceof Line2 ) {
                node.material.visible = guiParameters.edgeVisibility;
                node.material.linewidth = guiParameters.edgeWidth/100;
            }
            if ( node instanceof THREE.LineSegments ) {
                node.material.visible = guiParameters.edgeVisibility;
            }
        } );

        vertexRoot.traverse( function( node ) {
            if ( node instanceof THREE.Mesh ) {
                node.material.visible = guiParameters.vertexVisibility;
                node.scale.setScalar(guiParameters.vertexSize);
            }
        } );

        vertexlabelRoot.traverse( function( node ) {
            if( node instanceof CSS2DObject) {
                node.visible = guiParameters.vertexlabelVisibility;
            }
        } );

        ringRoot.traverse( function( node ) {
            if( node instanceof THREE.Mesh) {
                node.visible = guiParameters.circleVisibility;
            }
        } );

        normalsRoot.traverse( function( node ) {
            if( node instanceof THREE.LineSegments) {
                node.visible = guiParameters.normalsVisibility;
            }
        } );

        // update the circle width
        if(guiParameters.circleVisibility && currentCircleWidth != guiParameters.circleWidth){
            updateCircleWidth();
            currentCircleWidth = guiParameters.circleWidth;
        }

        //update the normals length 
        if(guiParameters.normalsVisibility){
            updateNormals();
        }

        controls.update();

        renderer.localClippingEnabled = true;

        renderer.render( scene, camera );
        labelRenderer.render( scene, camera );
    }
    animate();

    //resize of window size changes
    window.addEventListener( 'resize', onWindowResize );
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
        labelRenderer.setSize( window.innerWidth, window.innerHeight );
    }
</script>

</body>
</html>